<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="张珂玮的博客">
<meta property="og:url" content="http://www.flyingkw.com/page/25/index.html">
<meta property="og:site_name" content="张珂玮的博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="张珂玮的博客">





  
  
  <link rel="canonical" href="http://www.flyingkw.com/page/25/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>张珂玮的博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张珂玮的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-leetcode题目">

    
    
    
      
    

    

    <a href="/categories/leetcode题目/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>leetcode题目</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-hexo">

    
    
    
      
    

    

    <a href="/categories/Hexo" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Hexo</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-android-studio">

    
    
    
      
    

    

    <a href="/categories/Android-studio/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Android studio</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-c++">

    
    
    
      
    

    

    <a href="/categories/c/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>c++</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-python">

    
    
    
      
    

    

    <a href="/categories/python/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>python</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.flyingkw.com/2020/10/26/leetcode 5546. 按键持续时间最长的键/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张珂玮">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张珂玮的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/10/26/leetcode 5546. 按键持续时间最长的键/" class="post-title-link" itemprop="url">leetcode 5546. 按键持续时间最长的键</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-10-26 10:20:01" itemprop="dateCreated datePublished" datetime="2020-10-26T10:20:01+08:00">2020-10-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-11-16 17:04:27" itemprop="dateModified" datetime="2020-11-16T17:04:27+08:00">2020-11-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode题目/" itemprop="url" rel="index"><span itemprop="name">leetcode题目</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/10/26/leetcode 5546. 按键持续时间最长的键/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/10/26/leetcode 5546. 按键持续时间最长的键/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。</p>
<p>给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。</p>
<p>测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。</p>
<p>注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。</p>
<p>请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>示例 1：</p>
<pre><code>输入：releaseTimes = [9,29,49,50], keysPressed = &quot;cbcd&quot;
输出：&quot;c&quot;
解释：按键顺序和持续时间如下：
按下 &apos;c&apos; ，持续时间 9（时间 0 按下，时间 9 松开）
按下 &apos;b&apos; ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）
按下 &apos;c&apos; ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）
按下 &apos;d&apos; ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）
按键持续时间最长的键是 &apos;b&apos; 和 &apos;c&apos;（第二次按下时），持续时间都是 20
&apos;c&apos; 按字母顺序排列比 &apos;b&apos; 大，所以答案是 &apos;c&apos;
</code></pre><p>示例 2：</p>
<pre><code>输入：releaseTimes = [12,23,36,46,62], keysPressed = &quot;spuda&quot;
输出：&quot;a&quot;
解释：按键顺序和持续时间如下：
按下 &apos;s&apos; ，持续时间 12
按下 &apos;p&apos; ，持续时间 23 - 12 = 11
按下 &apos;u&apos; ，持续时间 36 - 23 = 13
按下 &apos;d&apos; ，持续时间 46 - 36 = 10
按下 &apos;a&apos; ，持续时间 62 - 46 = 16
按键持续时间最长的键是 &apos;a&apos; ，持续时间 16
</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul>
<li>releaseTimes.length == n</li>
<li>keysPressed.length == n</li>
<li>2 &lt;= n &lt;= 1000</li>
<li>0 &lt;= releaseTimes[i] &lt;= 109</li>
<li>releaseTimes[i] &lt; releaseTimes[i+1]</li>
<li>keysPressed 仅由小写英文字母组成</li>
</ul>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>一次遍历，遇到间隔大的字母就更新，如果间隔相等，比较一下字母大小再更新</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution {
public:
    char slowestKey(vector&lt;int&gt;&amp; releaseTimes, string keysPressed) {
        int m = releaseTimes[0];
        int ret = keysPressed[0];
        for(int i = 1; i &lt; releaseTimes.size(); i++){
            if(releaseTimes[i] - releaseTimes[i-1] &gt; m){
                m = releaseTimes[i] - releaseTimes[i-1];
                ret = keysPressed[i];
            }
            if(releaseTimes[i] - releaseTimes[i-1] == m){
                ret = keysPressed[i] &gt; ret ? keysPressed[i] : ret;
            }
        }
        return ret;
    }
};
</code></pre><blockquote>
<p>题目地址:<a href="https://leetcode-cn.com/problems/slowest-key/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/slowest-key/</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.flyingkw.com/2020/09/27/leetcode 5526. 最多可达成的换楼请求数目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张珂玮">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张珂玮的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/27/leetcode 5526. 最多可达成的换楼请求数目/" class="post-title-link" itemprop="url">leetcode 5526. 最多可达成的换楼请求数目</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-27 17:16:04 / 修改时间：17:22:16" itemprop="dateCreated datePublished" datetime="2020-09-27T17:16:04+08:00">2020-09-27</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode题目/" itemprop="url" rel="index"><span itemprop="name">leetcode题目</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/09/27/leetcode 5526. 最多可达成的换楼请求数目/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/27/leetcode 5526. 最多可达成的换楼请求数目/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>我们有 n 栋楼，编号从 0 到 n - 1 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。</p>
<p>给你一个数组 requests ，其中 requests[i] = [fromi, toi] ，表示一个员工请求从编号为 fromi 的楼搬到编号为 toi 的楼。</p>
<p>一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。</p>
<p>请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>示例 1：</p>
<pre><code>输入：n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]
输出：5
解释：请求列表如下：
从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。
从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。
从楼 2 离开的员工为 z ，且他想要搬到楼 0 。
从楼 3 离开的员工为 c ，且他想要搬到楼 4 。
没有员工从楼 4 离开。
我们可以让 x 和 b 交换他们的楼，以满足他们的请求。
我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。
所以最多可以满足 5 个请求。
</code></pre><p>示例 2：</p>
<pre><code>输入：n = 3, requests = [[0,0],[1,2],[2,1]]
输出：3
解释：请求列表如下：
从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。
从楼 1 离开的员工为 y ，且他想要搬到楼 2 。
从楼 2 离开的员工为 z ，且他想要搬到楼 1 。
我们可以满足所有的请求。
</code></pre><p>示例 3：</p>
<pre><code>输入：n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]
输出：4
</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul>
<li>1 &lt;= n &lt;= 20</li>
<li>1 &lt;= requests.length &lt;= 16</li>
<li>requests[i].length == 2</li>
<li>0 &lt;= fromi, toi &lt; n</li>
</ul>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>所有的可能最多有 1&lt;&lt;16 种，可以直接遍历，使用状态压缩，0表示不选择此请求，1表示选择此请求</p>
<p>记录每种可能每栋楼员工进出平衡的人数即可，如果不平衡说明此方案无法通过</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution {
public:
    int maximumRequests(int n, vector&lt;vector&lt;int&gt;&gt;&amp; requests) {
        int m = 0;
        for(int state = 0; state &lt; (1 &lt;&lt; requests.size()); state++){
            int res = 0;
            vector&lt;int&gt; out(n, 0);
            vector&lt;int&gt; in(n, 0);
            for(int i = 0; i &lt; requests.size(); i++){
                if((state &amp; (1 &lt;&lt; i)) &gt; 0){
                    in[requests[i][1]]++;
                    out[requests[i][0]]++;
                } 
            }
            bool b = false;
            for(int i = 0; i &lt; n; i++){
                if(in[i] == out[i]) res += in[i];
                else{
                    b = true;
                    break;
                }
            }
            if(b) continue;
            m = max(m, res);
        }
        return m;
    }
};
</code></pre><blockquote>
<p>题目地址:<a href="https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.flyingkw.com/2020/09/27/leetcode 5525. 皇位继承顺序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张珂玮">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张珂玮的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/27/leetcode 5525. 皇位继承顺序/" class="post-title-link" itemprop="url">leetcode 5525. 皇位继承顺序</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-27 17:08:03 / 修改时间：17:14:43" itemprop="dateCreated datePublished" datetime="2020-09-27T17:08:03+08:00">2020-09-27</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode题目/" itemprop="url" rel="index"><span itemprop="name">leetcode题目</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/09/27/leetcode 5525. 皇位继承顺序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/27/leetcode 5525. 皇位继承顺序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。</p>
<p>这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。</p>
<pre><code>Successor(x, curOrder):
如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：
    如果 x 是国王，那么返回 null
    否则，返回 Successor(x 的父亲, curOrder)
否则，返回 x 不在 curOrder 中最年长的孩子
</code></pre><p>比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。</p>
<ul>
<li>一开始， curOrder 为 [“king”].</li>
<li>调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [“king”, “Alice”] 。</li>
<li>调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”] 。</li>
<li>调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”, “Bob”] 。</li>
<li>调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [“king”, “Alice”, “Jack”, “Bob”] 。<br>通过以上的函数，我们总是能得到一个唯一的继承顺序。</li>
</ul>
<p>请你实现 ThroneInheritance 类：</p>
<ul>
<li>ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。</li>
<li>void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。</li>
<li>void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。</li>
<li>string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code>输入：
[&quot;ThroneInheritance&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;getInheritanceOrder&quot;, &quot;death&quot;, &quot;getInheritanceOrder&quot;]
[[&quot;king&quot;], [&quot;king&quot;, &quot;andy&quot;], [&quot;king&quot;, &quot;bob&quot;], [&quot;king&quot;, &quot;catherine&quot;], [&quot;andy&quot;, &quot;matthew&quot;], [&quot;bob&quot;, &quot;alex&quot;], [&quot;bob&quot;, &quot;asha&quot;], [null], [&quot;bob&quot;], [null]]
输出：
[null, null, null, null, null, null, null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;], null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]]

解释：
ThroneInheritance t= new ThroneInheritance(&quot;king&quot;); // 继承顺序：king
t.birth(&quot;king&quot;, &quot;andy&quot;); // 继承顺序：king &gt; andy
t.birth(&quot;king&quot;, &quot;bob&quot;); // 继承顺序：king &gt; andy &gt; bob
t.birth(&quot;king&quot;, &quot;catherine&quot;); // 继承顺序：king &gt; andy &gt; bob &gt; catherine
t.birth(&quot;andy&quot;, &quot;matthew&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; catherine
t.birth(&quot;bob&quot;, &quot;alex&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; catherine
t.birth(&quot;bob&quot;, &quot;asha&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; asha &gt; catherine
t.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]
t.death(&quot;bob&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob（已经去世）&gt; alex &gt; asha &gt; catherine
t.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]
</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul>
<li>1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15</li>
<li>kingName，parentName， childName 和 name 仅包含小写英文字母。</li>
<li>所有的参数 childName 和 kingName 互不相同。</li>
<li>所有 death 函数中的死亡名字 name 要么是国王，要么是已经出生了的人员名字。</li>
<li>每次调用 birth(parentName, childName) 时，测试用例都保证 parentName 对应的人员是活着的。</li>
<li>最多调用 105 次birth 和 death 。</li>
<li>最多调用 10 次 getInheritanceOrder 。</li>
</ul>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>构建一棵树，需要返回继承顺序时遍历一遍即可（记得去掉死亡的人）</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class ThroneInheritance {
private:
    unordered_map&lt;string, vector&lt;string&gt;&gt; m;
    vector&lt;string&gt; ret;
    map&lt;string, int&gt; sw;
    string kingName1;
public:
    ThroneInheritance(string kingName) {
        m[kingName];
        kingName1 = kingName;
    }

    void birth(string parentName, string childName) {
        m[parentName].push_back(childName);
    }

    void death(string name) {
        sw[name] = 1;
    }
    void dfs(string n){
        if(sw.count(n) == 0) ret.push_back(n);
        for(int i = 0; i &lt; m[n].size(); i++){
            dfs(m[n][i]);
        }
    }
    vector&lt;string&gt; getInheritanceOrder() {
        ret.clear();
        dfs(kingName1);
        return ret;
    }
};

/**
 * Your ThroneInheritance object will be instantiated and called as such:
 * ThroneInheritance* obj = new ThroneInheritance(kingName);
 * obj-&gt;birth(parentName,childName);
 * obj-&gt;death(name);
 * vector&lt;string&gt; param_3 = obj-&gt;getInheritanceOrder();
 */
</code></pre><blockquote>
<p>题目地址:<a href="https://leetcode-cn.com/problems/throne-inheritance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/throne-inheritance/</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.flyingkw.com/2020/09/27/leetcode 5524. 经营摩天轮的最大利润/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张珂玮">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张珂玮的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/27/leetcode 5524. 经营摩天轮的最大利润/" class="post-title-link" itemprop="url">leetcode 5524. 经营摩天轮的最大利润</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-27 17:03:02 / 修改时间：17:14:43" itemprop="dateCreated datePublished" datetime="2020-09-27T17:03:02+08:00">2020-09-27</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode题目/" itemprop="url" rel="index"><span itemprop="name">leetcode题目</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/09/27/leetcode 5524. 经营摩天轮的最大利润/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/27/leetcode 5524. 经营摩天轮的最大利润/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。</p>
<p>给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。</p>
<p>你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将免费进行所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。</p>
<p>返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>示例 1：</p>
<pre><code>输入：customers = [8,3], boardingCost = 5, runningCost = 6
输出：3
解释：座舱上标注的数字是该座舱的当前游客数。
1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。
2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 = $28 。
3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 = $37 。
轮转 3 次得到最大利润，最大利润为 $37 。
</code></pre><p>示例 2：</p>
<pre><code>输入：customers = [10,9,6], boardingCost = 6, runningCost = 4
输出：7
解释：
1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 = $20 。
2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 = $40 。
3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 = $60 。
4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 = $80 。
5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 = $100 。
6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 = $120 。
7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 = $122 。
轮转 7 次得到最大利润，最大利润为$122 。
</code></pre><p>示例 3：</p>
<pre><code>输入：customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92
输出：-1
解释：
1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 = -$89 。
2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 = -$177 。
3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 = -$269 。
4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 = -$356 。
5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 = -$447 。
利润永不为正，所以返回 -1 。
</code></pre><p>示例 4：</p>
<pre><code>输入：customers = [10,10,6,4,7], boardingCost = 3, runningCost = 8
输出：9
解释：
1. 10 位游客抵达，4 位登舱，6 位等待，摩天轮轮转。当前利润为 4 * $3 - 1 * $8 = $4 。
2. 10 位游客抵达，4 位登舱，12 位等待，摩天轮轮转。当前利润为 8 * $3 - 2 * $8 = $8 。
3. 6 位游客抵达，4 位登舱，14 位等待，摩天轮轮转。当前利润为 12 * $3 - 3 * $8 = $12 。
4. 4 位游客抵达，4 位登舱，14 位等待，摩天轮轮转。当前利润为 16 * $3 - 4 * $8 = $16 。
5. 7 位游客抵达，4 位登舱，17 位等待，摩天轮轮转。当前利润为 20 * $3 - 5 * $8 = $20 。
6. 4 位登舱，13 位等待，摩天轮轮转。当前利润为 24 * $3 - 6 * $8 = $24 。
7. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 28 * $3 - 7 * $8 = $28 。
8. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 32 * $3 - 8 * $8 = $32 。
9. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 36 * $3 - 9 * $8 = $36 。
​​​​​​​10. 1 位登舱，0 位等待，摩天轮轮转。当前利润为 37 * $3 - 10 * $8 = $31 。
轮转 9 次得到最大利润，最大利润为 $36 。
</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul>
<li>n == customers.length</li>
<li>1 &lt;= n &lt;= 105</li>
<li>0 &lt;= customers[i] &lt;= 50</li>
<li>1 &lt;= boardingCost, runningCost &lt;= 100</li>
</ul>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>直接记录每次载客利润和次数，当利润大于最大值的时候记录次数即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution {
public:
    int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) {
        int m = 0;
        int sy = 0;
        int dd = 0;
        int ret = 0;
        int lz = 0;
        for(int i = 0; i &lt; customers.size(); i++){
            lz += 1;
            dd += customers[i];
            if(dd &gt;= 4){
                dd -= 4;
                sy += 4*boardingCost;
            }
            else{
                sy += dd*4;
                dd = 0;
            }
            sy -= runningCost;
            if(m &lt; sy){
                m = sy;
                ret = lz;
            }
        }
        while(dd &gt; 0){
            lz += 1;
            if(dd &gt;= 4){
                dd -= 4;
                sy += 4*boardingCost;
            }
            else{
                sy += dd*boardingCost;
                dd = 0;
            }
            sy -= runningCost;
            if(m &lt; sy){
                m = sy;
                ret = lz;
            }
        }
        return ret &gt; 0 ? ret : -1;
    }
};
</code></pre><blockquote>
<p>题目地址:<a href="https://leetcode-cn.com/problems/maximum-profit-of-operating-a-centennial-wheel/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-profit-of-operating-a-centennial-wheel/</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.flyingkw.com/2020/09/27/leetcode 5523. 文件夹操作日志搜集器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张珂玮">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张珂玮的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/27/leetcode 5523. 文件夹操作日志搜集器/" class="post-title-link" itemprop="url">leetcode 5523. 文件夹操作日志搜集器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-27 16:57:01 / 修改时间：17:02:31" itemprop="dateCreated datePublished" datetime="2020-09-27T16:57:01+08:00">2020-09-27</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode题目/" itemprop="url" rel="index"><span itemprop="name">leetcode题目</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/09/27/leetcode 5523. 文件夹操作日志搜集器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/27/leetcode 5523. 文件夹操作日志搜集器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。</p>
<p>下面给出对变更操作的说明：</p>
<ul>
<li>“../“ ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。</li>
<li>“./“ ：继续停留在当前文件夹。</li>
<li>“x/“ ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。<br>给你一个字符串列表 logs ，其中 logs[i] 是用户在 ith 步执行的操作。</li>
</ul>
<p>文件系统启动时位于主文件夹，然后执行 logs 中的操作。</p>
<p>执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>示例 1：</p>
<pre><code>输入：logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;../&quot;,&quot;d21/&quot;,&quot;./&quot;]
输出：2
解释：执行 &quot;../&quot; 操作变更文件夹 2 次，即可回到主文件夹
</code></pre><p>示例 2：</p>
<pre><code>输入：logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;./&quot;,&quot;d3/&quot;,&quot;../&quot;,&quot;d31/&quot;]
输出：3
</code></pre><p>示例 3：</p>
<pre><code>输入：logs = [&quot;d1/&quot;,&quot;../&quot;,&quot;../&quot;,&quot;../&quot;]
输出：0
</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul>
<li>1 &lt;= logs.length &lt;= 103</li>
<li>2 &lt;= logs[i].length &lt;= 10</li>
<li>logs[i] 包含小写英文字母，数字，’.’ 和 ‘/‘</li>
<li>logs[i] 符合语句中描述的格式</li>
<li>文件夹名称由小写英文字母和数字组成</li>
</ul>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>判断字符串倒数第二个字符</p>
<ul>
<li>为“.”，判断字符串长度，如果为2，无操作，如果大于2，减少一步返回主文件夹所需的步数，当为0时，无效</li>
<li>为其他字符，增加一步返回主文件夹所需的步数</li>
</ul>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution {
public:
    int minOperations(vector&lt;string&gt;&amp; logs) {
        int ret = 0;
        for(int i = 0; i &lt; logs.size(); i++){
            if(logs[i][logs[i].size()-2] == &apos;.&apos;){
                if(logs[i].size() == 3) ret--;
            }
            else{
                ret++;
            }
            if(ret &lt; 0) ret = 0;
        }
        return ret;
    }
};
</code></pre><blockquote>
<p>题目地址:<a href="https://leetcode-cn.com/problems/crawler-log-folder/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/crawler-log-folder/</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.flyingkw.com/2020/09/21/leetcode 1595. 连通两组点的最小成本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张珂玮">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张珂玮的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/21/leetcode 1595. 连通两组点的最小成本/" class="post-title-link" itemprop="url">leetcode 1595. 连通两组点的最小成本</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-21 11:53:04 / 修改时间：16:35:30" itemprop="dateCreated datePublished" datetime="2020-09-21T11:53:04+08:00">2020-09-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode题目/" itemprop="url" rel="index"><span itemprop="name">leetcode题目</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/09/21/leetcode 1595. 连通两组点的最小成本/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/21/leetcode 1595. 连通两组点的最小成本/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你两组点，其中第一组中有 size1 个点，第二组中有 size2 个点，且 size1 &gt;= size2 。</p>
<p>任意两点间的连接成本 cost 由大小为 size1 x size2 矩阵给出，其中 cost[i][j] 是第一组中的点 i 和第二组中的点 j 的连接成本。如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。</p>
<p>返回连通两组点所需的最小成本。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>示例 1：</p>
<pre><code>输入：cost = [[15, 96], [36, 2]]
输出：17
解释：连通两组点的最佳方法是：
1--A
2--B
总成本为 17 。
</code></pre><p>示例 2：</p>
<pre><code>输入：cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]
输出：4
解释：连通两组点的最佳方法是：
1--A
2--B
2--C
3--A
最小成本为 4 。
请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。
</code></pre><p>示例 3：</p>
<pre><code>输入：cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]
输出：10
</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul>
<li>size1 == cost.length</li>
<li>size2 == cost[i].length</li>
<li>1 &lt;= size1, size2 &lt;= 12</li>
<li>size1 &gt;= size2</li>
<li>0 &lt;= cost[i][j] &lt;= 100</li>
</ul>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>题目相当于：在一个矩阵中选取一些值, 要求满足矩阵的每一行和每一列都至少有一个元素被选中, 同时选中元素的总和最小 </p>
<p>使用状态压缩dp，因为列数比较少，所以使用状压dp来表示每一行的选取情况</p>
<p>维护一个dp矩阵 dp[m][1 &lt;&lt; n], dp[i][j]表示当前选择第i行，行中的选取情况为j（二进制下，0表示未选中，1表示选中）</p>
<p>每一行选择的时候有两种策略</p>
<ul>
<li>一种是随便选择一个（因为每行都需要至少选择一个）</li>
<li>一种是从未选择的列中挑选一部分选择（代码中遍历所有可能性）</li>
</ul>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution {
public:
    int connectTwoGroups(vector&lt;vector&lt;int&gt;&gt;&amp; cost) {
        vector&lt;vector&lt;int&gt;&gt; dp(cost.size(), vector&lt;int&gt;(1 &lt;&lt; cost[0].size(), INT_MAX));
        // 计算第一行各种状态下的结果
        for(int i = 1; i &lt; (1 &lt;&lt; cost[0].size()); i++){
            int z = 0;
            for(int j = 0; j &lt; cost[0].size(); j++)
                if((i &amp; (1 &lt;&lt; j)) != 0) z += cost[0][j];
            dp[0][i] = z;
        }
        // 从第二行开始遍历
        for(int i = 1; i &lt; cost.size(); i++){
            for(int j = 1; j &lt; (1 &lt;&lt; cost[0].size()); j++){
                // 先计算第i行至少选择一个的情况
                for(int k = 0; k &lt; cost[0].size(); k++){
                    dp[i][j | (1 &lt;&lt; k)] = min(dp[i][j | (1 &lt;&lt; k)], dp[i-1][j] + cost[i][k]);
                }
                // 统计出到第i行时还未选择的列
                int rest = (1 &lt;&lt; cost[0].size()) - 1 - j;
                // 将未选择的列的每种组合都遍历一遍， k = rest &amp; (k-1)可以得到所有的组合
                for(int k = rest; k &gt;= 1; k = rest &amp; (k-1)){
                    int z = 0;
                    for(int l = 0; l &lt; cost[0].size(); l++)
                        if((k &amp; (1 &lt;&lt; l)) != 0) z += cost[i][l];
                    dp[i][j | k] = min(dp[i][j | k], dp[i-1][j] + z);
                }
            }
        }

        return dp[cost.size()-1][(1 &lt;&lt; cost[0].size()) - 1];
    }
};
</code></pre><blockquote>
<p>题目地址:<a href="https://leetcode-cn.com/problems/minimum-cost-to-connect-two-groups-of-points/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-to-connect-two-groups-of-points/</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.flyingkw.com/2020/09/21/leetcode 1594. 矩阵的最大非负积/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张珂玮">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张珂玮的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/21/leetcode 1594. 矩阵的最大非负积/" class="post-title-link" itemprop="url">leetcode 1594. 矩阵的最大非负积</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-21 10:51:03 / 修改时间：11:44:46" itemprop="dateCreated datePublished" datetime="2020-09-21T10:51:03+08:00">2020-09-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode题目/" itemprop="url" rel="index"><span itemprop="name">leetcode题目</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/09/21/leetcode 1594. 矩阵的最大非负积/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/21/leetcode 1594. 矩阵的最大非负积/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个大小为 rows x cols 的矩阵 grid 。最初，你位于左上角 (0, 0) ，每一步，你可以在矩阵中 向右 或 向下 移动。</p>
<p>在从左上角 (0, 0) 开始到右下角 (rows - 1, cols - 1) 结束的所有路径中，找出具有 最大非负积 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。</p>
<p>返回 最大非负积 对 10^9 + 7 取余 的结果。如果最大积为负数，则返回 -1 。</p>
<p>注意，取余是在得到最大积之后执行的。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>示例 1：</p>
<pre><code>输入：grid = [[-1,-2,-3],
             [-2,-3,-3],
             [-3,-3,-2]]
输出：-1
解释：从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1
</code></pre><p>示例 2：</p>
<pre><code>输入：grid = [[1,-2,1],
             [1,-2,1],
             [3,-4,1]]
输出：8
解释：最大非负积对应的路径已经用粗体标出 (1 * 1 * -2 * -4 * 1 = 8)
</code></pre><p>示例 3：</p>
<pre><code>输入：grid = [[1, 3],
             [0,-4]]
输出：0
解释：最大非负积对应的路径已经用粗体标出 (1 * 0 * -4 = 0)
</code></pre><p>示例 4：</p>
<pre><code>输入：grid = [[ 1, 4,4,0],
             [-2, 0,0,1],
             [ 1,-1,1,1]]
输出：2
解释：最大非负积对应的路径已经用粗体标出 (1 * -2 * 1 * -1 * 1 * 1 = 2)
</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul>
<li>1 &lt;= rows, cols &lt;= 15</li>
<li>-4 &lt;= grid[i][j] &lt;= 4</li>
</ul>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>使用动态规划，每一个单元格有两种情况，一种是计算到当前单元格为正数，另一种为负数，同时维护两种情况即可</p>
<p>dp[i][j].first 表示到第i行第j列的非负数状态</p>
<p>dp[i][j].second 表示到第i行第j列的非正数状态</p>
<p>正数状态下设一个-1，表示到达当前格没办法为非负数</p>
<p>负数状态下设一个1，表示到达当前格没办法为非正数</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution {
public:
    int maxProductPath(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; dp(grid.size(), vector&lt;pair&lt;int, int&gt;&gt;(grid[0].size(), pair&lt;int, int&gt;{-1,1}));
        if(grid[0][0] == 0) return 0;

        if(grid[0][0] &gt; 0)
            dp[0][0].first = grid[0][0];
        else 
            dp[0][0].second = grid[0][0];

        for(int i = 1; i &lt; grid.size(); i++){
            int z = -1;
            int f = 1;
            if(dp[i-1][0].first != -1){
                if(dp[i-1][0].first * grid[i][0] &gt;= 0) z = max(z, dp[i-1][0].first * grid[i][0]);
                if(dp[i-1][0].first * grid[i][0] &lt; 0) f = min(f, dp[i-1][0].first * grid[i][0]);
            }
            if(dp[i-1][0].second != 1){
                if(dp[i-1][0].second * grid[i][0] &gt;= 0) z = max(z, dp[i-1][0].second * grid[i][0]);
                if(dp[i-1][0].second * grid[i][0] &lt; 0) f = min(f, dp[i-1][0].second * grid[i][0]);
            }
            dp[i][0].first = z;
            dp[i][0].second = f;
        }
        for(int i = 1; i &lt; grid[0].size(); i++){

            int z = -1;
            int f = 1;
            if(dp[0][i-1].first != -1){
                if(dp[0][i-1].first * grid[0][i] &gt;= 0) z = dp[0][i-1].first * grid[0][i];
                if(dp[0][i-1].first * grid[0][i] &lt;= 0) f = dp[0][i-1].first * grid[0][i];
            }
            if(dp[0][i-1].second != 1){
                if(dp[0][i-1].second * grid[0][i] &gt;= 0) z = dp[0][i-1].second * grid[0][i];
                if(dp[0][i-1].second * grid[0][i] &lt;= 0) f = dp[0][i-1].second * grid[0][i];
            }
            dp[0][i].first = z;
            dp[0][i].second = f;

        }
        for(int i = 1; i &lt; grid.size(); i++){
            for(int j = 1; j &lt; grid[0].size(); j++){
                int z = -1;
                int f = 1;

                if(dp[i][j-1].first != -1){
                    if(dp[i][j-1].first * grid[i][j] &gt;= 0) z = max(z, dp[i][j-1].first * grid[i][j]);
                    if(dp[i][j-1].first * grid[i][j] &lt;= 0) f = min(f, dp[i][j-1].first * grid[i][j]);
                }

                if(dp[i][j-1].second != 1){
                    if(dp[i][j-1].second * grid[i][j] &gt;= 0) z = max(z, dp[i][j-1].second * grid[i][j]);
                    if(dp[i][j-1].second * grid[i][j] &lt;= 0) f = min(f, dp[i][j-1].second * grid[i][j]);
                }

                if(dp[i-1][j].first != -1){
                    if(dp[i-1][j].first * grid[i][j] &gt;= 0) z = max(z, dp[i-1][j].first * grid[i][j]);
                    if(dp[i-1][j].first * grid[i][j] &lt;= 0) f = min(f, dp[i-1][j].first * grid[i][j]);
                }

                if(dp[i-1][j].second != 1){
                    if(dp[i-1][j].second * grid[i][j] &gt;= 0) z = max(z, dp[i-1][j].second * grid[i][j]);
                    if(dp[i-1][j].second * grid[i][j] &lt;= 0) f = min(f, dp[i-1][j].second * grid[i][j]);
                }

                dp[i][j].first = z;
                dp[i][j].second = f;
                cout &lt;&lt; dp[i][j].first &lt;&lt; &quot; &quot;;
            }
            cout &lt;&lt; &quot;\n&quot;;
        }

        return dp[grid.size()-1][grid[0].size()-1].first;
    }
};
</code></pre><blockquote>
<p>题目地址:<a href="https://leetcode-cn.com/problems/maximum-non-negative-product-in-a-matrix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-non-negative-product-in-a-matrix/</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.flyingkw.com/2020/09/21/leetcode 1593. 拆分字符串使唯一子字符串的数目最大/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张珂玮">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张珂玮的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/21/leetcode 1593. 拆分字符串使唯一子字符串的数目最大/" class="post-title-link" itemprop="url">leetcode 1593. 拆分字符串使唯一子字符串的数目最大</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-21 10:45:02 / 修改时间：11:44:46" itemprop="dateCreated datePublished" datetime="2020-09-21T10:45:02+08:00">2020-09-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode题目/" itemprop="url" rel="index"><span itemprop="name">leetcode题目</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/09/21/leetcode 1593. 拆分字符串使唯一子字符串的数目最大/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/21/leetcode 1593. 拆分字符串使唯一子字符串的数目最大/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个字符串 s ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。</p>
<p>字符串 s 拆分后可以得到若干 非空子字符串 ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 唯一的 。</p>
<p>注意：子字符串 是字符串中的一个连续字符序列。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>示例 1：</p>
<pre><code>输入：s = &quot;ababccc&quot;
输出：5
解释：一种最大拆分方法为 [&apos;a&apos;, &apos;b&apos;, &apos;ab&apos;, &apos;c&apos;, &apos;cc&apos;] 。像 [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;cc&apos;] 这样拆分不满足题目要求，因为其中的 &apos;a&apos; 和 &apos;b&apos; 都出现了不止一次。
</code></pre><p>示例 2：</p>
<pre><code>输入：s = &quot;aba&quot;
输出：2
解释：一种最大拆分方法为 [&apos;a&apos;, &apos;ba&apos;] 。
</code></pre><p>示例 3：</p>
<pre><code>输入：s = &quot;aa&quot;
输出：1
解释：无法进一步拆分字符串。
</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul>
<li><p>1 &lt;= s.length &lt;= 16</p>
</li>
<li><p>s 仅包含小写英文字母</p>
</li>
</ul>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>回溯，直接暴力判断每种情况，使用一个map判断是否已经有此子字符串</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution {
private:
    int ret;
public:
    void dg(int i, string &amp;s, unordered_map&lt;string, int&gt; &amp;m, string str, int ans){
        if(i == s.size()){
            ret = max(ret, ans);
            return;
        }
        str += s[i];
        dg(i+1, s, m, str, ans);
        if(m[str] == 0){
            m[str] = 1;
            ans++;
            dg(i+1, s, m, &quot;&quot;, ans);
            m[str] = 0;
            str = &quot;&quot;;
        }
    }
    int maxUniqueSplit(string s) {
        ret = 0;
        unordered_map&lt;string, int&gt; m;
        dg(0, s, m, &quot;&quot;, 0);
        return ret;
    }
};
</code></pre><blockquote>
<p>题目地址:<a href="https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings/</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.flyingkw.com/2020/09/21/leetcode 1592. 重新排列单词间的空格/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张珂玮">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张珂玮的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/21/leetcode 1592. 重新排列单词间的空格/" class="post-title-link" itemprop="url">leetcode 1592. 重新排列单词间的空格</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-21 10:38:01 / 修改时间：11:44:46" itemprop="dateCreated datePublished" datetime="2020-09-21T10:38:01+08:00">2020-09-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode题目/" itemprop="url" rel="index"><span itemprop="name">leetcode题目</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/09/21/leetcode 1592. 重新排列单词间的空格/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/21/leetcode 1592. 重新排列单词间的空格/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你一个字符串 text ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 text 至少包含一个单词 。</p>
<p>请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。</p>
<p>返回 重新排列空格后的字符串 。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>示例 1：</p>
<pre><code>输入：text = &quot;  this   is  a sentence &quot;
输出：&quot;this   is   a   sentence&quot;
解释：总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 / (4-1) = 3 个。
</code></pre><p>示例 2：</p>
<pre><code>输入：text = &quot; practice   makes   perfect&quot;
输出：&quot;practice   makes   perfect &quot;
解释：总共有 7 个空格和 3 个单词。7 / (3-1) = 3 个空格加上 1 个多余的空格。多余的空格需要放在字符串的末尾。
</code></pre><p>示例 3：</p>
<pre><code>输入：text = &quot;hello   world&quot;
输出：&quot;hello   world&quot;
</code></pre><p>示例 4：</p>
<pre><code>输入：text = &quot;  walks  udp package   into  bar a&quot;
输出：&quot;walks  udp  package  into  bar  a &quot;
</code></pre><p>示例 5：</p>
<pre><code>输入：text = &quot;a&quot;
输出：&quot;a&quot;
</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul>
<li>1 &lt;= text.length &lt;= 100</li>
<li>text 由小写英文字母和 ‘ ‘ 组成</li>
<li>text 中至少包含一个单词</li>
</ul>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>遍历一遍统计空格和单词数量，第二遍遍历时在每两个单词中间插入合适的空格数量即可</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution {
public:
    string reorderSpaces(string text) {
        int k = 0;
        int d = 0;

        for(int i = 0; i &lt; text.size(); i++){
            if(text[i] == &apos; &apos;) k++;
            if(i - 1 &gt;= 0 &amp;&amp; text[i-1] == &apos; &apos; &amp;&amp; text[i] != &apos; &apos;) d++;
        }
        if(text[0] == &apos; &apos;) d--;
        int z = d == 0 ? 0 : k / d;
        int y = d == 0 ? k : k % d;
        string str = &quot;&quot;;
        int i = 0;
        while(i &lt; text.size() &amp;&amp; text[i] == &apos; &apos;) i++;

        for(; i &lt; text.size(); i++){

            if(text[i] != &apos; &apos;) str += text[i];
            else{
                while(i &lt; text.size() &amp;&amp; text[i] == &apos; &apos;) i++;

                if(i == text.size()) break;
                i--;
                for(int j = 0; j &lt; z; j++) str += &apos; &apos;;
                cout &lt;&lt; i;
            }

        }

        for(int j = 0; j &lt; y; j++) str += &apos; &apos;;
        return str;
    }
};
</code></pre><blockquote>
<p>题目地址:<a href="https://leetcode-cn.com/problems/rearrange-spaces-between-words/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rearrange-spaces-between-words/</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.flyingkw.com/2020/09/14/leetcode 5514. 检查字符串是否可以通过排序子字符串得到另一个字符串/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张珂玮">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张珂玮的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/09/14/leetcode 5514. 检查字符串是否可以通过排序子字符串得到另一个字符串/" class="post-title-link" itemprop="url">leetcode 5514. 检查字符串是否可以通过排序子字符串得到另一个字符串</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-09-14 12:07:04 / 修改时间：12:13:23" itemprop="dateCreated datePublished" datetime="2020-09-14T12:07:04+08:00">2020-09-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/leetcode题目/" itemprop="url" rel="index"><span itemprop="name">leetcode题目</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/09/14/leetcode 5514. 检查字符串是否可以通过排序子字符串得到另一个字符串/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/09/14/leetcode 5514. 检查字符串是否可以通过排序子字符串得到另一个字符串/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>给你两个字符串 s 和 t ，请你通过若干次以下操作将字符串 s 转化成字符串 t ：</p>
<ul>
<li>选择 s 中一个 非空 子字符串并将它包含的字符就地 升序 排序。</li>
</ul>
<p>比方说，对下划线所示的子字符串进行操作可以由 “14234” 得到 “12344” 。</p>
<p>如果可以将字符串 s 变成 t ，返回 true 。否则，返回 false 。</p>
<p>一个 子字符串 定义为一个字符串中连续的若干字符。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>示例 1：</p>
<pre><code>输入：s = &quot;84532&quot;, t = &quot;34852&quot;
输出：true
解释：你可以按以下操作将 s 转变为 t ：
&quot;84532&quot; （从下标 2 到下标 3）-&gt; &quot;84352&quot;
&quot;84352&quot; （从下标 0 到下标 2） -&gt; &quot;34852&quot;
</code></pre><p>示例 2：</p>
<pre><code>输入：s = &quot;34521&quot;, t = &quot;23415&quot;
输出：true
解释：你可以按以下操作将 s 转变为 t ：
&quot;34521&quot; -&gt; &quot;23451&quot;
&quot;23451&quot; -&gt; &quot;23415&quot;
</code></pre><p>示例 3：</p>
<pre><code>输入：s = &quot;12345&quot;, t = &quot;12435&quot;
输出：false
</code></pre><p>示例 4：</p>
<pre><code>输入：s = &quot;1&quot;, t = &quot;2&quot;
输出：false
</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ul>
<li>s.length == t.length</li>
<li>1 &lt;= s.length &lt;= 105</li>
<li>s 和 t 都只包含数字字符，即 ‘0’ 到 ‘9’ 。</li>
</ul>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>将字符串排序简单化，每次只排序相邻两个字符，因为排序一整个字符串可以拆分成多次排序相邻字符</p>
<p>如果要将一个字符移动到后面，那么只需要看看移动的路径中是否有大于此字符的字符，若有，则不可能实现移动</p>
<p>只需要从后往前遍历，判断每次是否可以将最近的所需字符移动到最后即可</p>
<p>可以使用vector&lt;vector<int>&gt;记录每种数字的下标组，可以节省时间</int></p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>class Solution {
public:
    bool isTransformable(string s, string t) {
        vector&lt;vector&lt;int&gt;&gt; num(10);
        for(int i = 0; i &lt; s.size(); i++){
            num[s[i] - &apos;0&apos;].push_back(i);
        }
        for(int i = s.size()-1; i &gt;= 0; i--){
            int z = t[i] - &apos;0&apos;;
            if(num[z].size() == 0) return false;
            for(int j = z + 1; j &lt; 9; j++){
                if(num[j].size() == 0) continue;
                if(num[j].back() &gt; num[z].back()) return false;
            }
            num[z].pop_back();
        }
        return true;
    }
};
</code></pre><blockquote>
<p>题目地址:<a href="https://leetcode-cn.com/problems/check-if-string-is-transformable-with-substring-sort-operations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-string-is-transformable-with-substring-sort-operations/</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/24/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><span class="space">&hellip;</span><a class="page-number" href="/page/53/">53</a><a class="extend next" rel="next" href="/page/26/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">张珂玮</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">521</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张珂玮</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'LxmtRYn5DWNiNgi5ODGhX8C4-gzGzoHsz',
    appKey: 'H7Ht36ROr9og7lakRrKj6gss',
    placeholder: 'ヾﾉ≧∀≦)o写点啥呗',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
</script>





  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>

