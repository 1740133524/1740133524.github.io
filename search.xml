<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode 6019. 替换数组中的非互质数]]></title>
    <url>%2F2022%2F03%2F07%2Fleetcode%206019.%20%E6%9B%BF%E6%8D%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9D%9E%E4%BA%92%E8%B4%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 。请你对数组执行下述操作： 从 nums 中找出 任意 两个 相邻 的 非互质 数。 如果不存在这样的数，终止 这一过程。 否则，删除这两个数，并 替换 为它们的 最小公倍数（Least Common Multiple，LCM）。 只要还能找出两个相邻的非互质数就继续 重复 这一过程。 返回修改后得到的 最终 数组。可以证明的是，以 任意 顺序替换相邻的非互质数都可以得到相同的结果。 生成的测试用例可以保证最终数组中的值 小于或者等于 108 。 两个数字 x 和 y 满足 非互质数 的条件是：GCD(x, y) &gt; 1 ，其中 GCD(x, y) 是 x 和 y 的 最大公约数 。 示例：示例 1 ： 输入：nums = [6,4,3,2,7,6,2] 输出：[12,7,6] 解释： - (6, 4) 是一组非互质数，且 LCM(6, 4) = 12 。得到 nums = [12,3,2,7,6,2] 。 - (12, 3) 是一组非互质数，且 LCM(12, 3) = 12 。得到 nums = [12,2,7,6,2] 。 - (12, 2) 是一组非互质数，且 LCM(12, 2) = 12 。得到 nums = [12,7,6,2] 。 - (6, 2) 是一组非互质数，且 LCM(6, 2) = 6 。得到 nums = [12,7,6] 。 现在，nums 中不存在相邻的非互质数。 因此，修改后得到的最终数组是 [12,7,6] 。 注意，存在其他方法可以获得相同的最终数组。 示例 2 ： 输入：nums = [2,2,1,1,3,3,3] 输出：[2,1,1,3] 解释： - (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,3,3] 。 - (3, 3) 是一组非互质数，且 LCM(3, 3) = 3 。得到 nums = [2,2,1,1,3] 。 - (2, 2) 是一组非互质数，且 LCM(2, 2) = 2 。得到 nums = [2,1,1,3] 。 现在，nums 中不存在相邻的非互质数。 因此，修改后得到的最终数组是 [2,1,1,3] 。 注意，存在其他方法可以获得相同的最终数组。 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^5 生成的测试用例可以保证最终数组中的值 小于或者等于 10^8 。 分析：使用栈 遍历nums，nums[i]表示遍历到第i个数 判断nums[i]和栈顶的数是否为互质数 是 栈中大于一个数，将nums[i]替换为两数的最小公倍数，删除栈顶的数（下轮遍历时下标还是i，而不是i+1） 栈中为一个数，将栈顶的数替换为两数的最小公倍数 不是，将nums[i]入栈 代码：class Solution { public: vector&lt;int&gt; replaceNonCoprimes(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ret; ret.push_back(nums[0]); for(int i = 1; i &lt; nums.size(); i++){ int a = gcd(ret.back(), nums[i]); if(a != 1){ if(ret.size() == 1){ ret[ret.size()-1] = ret.back() / a * nums[i] / a * a; } else{ nums[i] = ret.back() / a * nums[i] / a * a; ret.pop_back(); i--; } } else{ ret.push_back(nums[i]); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/replace-non-coprime-numbers-in-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 6018. 根据描述创建二叉树]]></title>
    <url>%2F2022%2F03%2F07%2Fleetcode%206018.%20%E6%A0%B9%E6%8D%AE%E6%8F%8F%E8%BF%B0%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目：给你一个二维整数数组 descriptions ，其中 descriptions[i] = [parenti, childi, isLefti] 表示 parenti 是 childi 在 二叉树 中的 父节点，二叉树中各节点的值 互不相同 。此外： 如果 isLefti == 1 ，那么 childi 就是 parenti 的左子节点。 如果 isLefti == 0 ，那么 childi 就是 parenti 的右子节点。 请你根据 descriptions 的描述来构造二叉树并返回其 根节点 。 测试用例会保证可以构造出 有效 的二叉树。 示例：示例 1： 输入：descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]] 输出：[50,20,80,15,17,19] 解释：根节点是值为 50 的节点，因为它没有父节点。 结果二叉树如上图所示。 示例 2： 输入：descriptions = [[1,2,1],[2,3,0],[3,4,1]] 输出：[1,2,null,null,3,4] 解释：根节点是值为 1 的节点，因为它没有父节点。 结果二叉树如上图所示。 提示： 1 &lt;= descriptions.length &lt;= 10^4 descriptions[i].length == 3 1 &lt;= parenti, childi &lt;= 10^5 0 &lt;= isLefti &lt;= 1 descriptions 所描述的二叉树是一棵有效二叉树 分析：将其转换成父节点所拥有的子节点的格式，找出根结点，从根结点开始转换成二叉树 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { map&lt;int, vector&lt;int&gt;&gt; m; void dfs(TreeNode* t){ if(m.count(t-&gt;val)){ if(m[t-&gt;val][0] != 0){ t -&gt; left = new TreeNode(m[t-&gt;val][0]); dfs(t -&gt; left); } if(m[t-&gt;val][1] != 0){ t -&gt; right = new TreeNode(m[t-&gt;val][1]); dfs(t -&gt; right); } } } public: TreeNode* createBinaryTree(vector&lt;vector&lt;int&gt;&gt;&amp; descriptions) { map&lt;int, int&gt; m1; int h; for(int i = 0; i &lt; descriptions.size(); i++){ m1[descriptions[i][1]] = 1; } for(int i = 0; i &lt; descriptions.size(); i++){ if(descriptions[i][2] == 1){ if(m.count(descriptions[i][0]) == 0){ m[descriptions[i][0]] = {descriptions[i][1], 0}; } else{ m[descriptions[i][0]][0] = descriptions[i][1]; } } else{ if(m.count(descriptions[i][0]) == 0){ m[descriptions[i][0]] = {0, descriptions[i][1]}; } else{ m[descriptions[i][0]][1] = descriptions[i][1]; } } if(m1.count(descriptions[i][0]) == 0){ h = descriptions[i][0]; } } TreeNode* t = new TreeNode(h); dfs(t); return t; } }; 题目地址:https://leetcode-cn.com/problems/create-binary-tree-from-descriptions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 6017. 向数组中追加 K 个整数]]></title>
    <url>%2F2022%2F03%2F07%2Fleetcode%206017.%20%E5%90%91%E6%95%B0%E7%BB%84%E4%B8%AD%E8%BF%BD%E5%8A%A0%20K%20%E4%B8%AA%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 和一个整数 k 。请你向 nums 中追加 k 个 未 出现在 nums 中的、互不相同 的 正 整数，并使结果数组的元素和 最小 。 返回追加到 nums 中的 k 个整数之和。 示例：示例 1： 输入：nums = [1,4,25,10,25], k = 2 输出：5 解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 2 和 3 。 nums 最终元素和为 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70 ，这是所有情况中的最小值。 所以追加到数组中的两个整数之和是 2 + 3 = 5 ，所以返回 5 。 示例 2： 输入：nums = [5,6], k = 6 输出：25 解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 1 、2 、3 、4 、7 和 8 。 nums 最终元素和为 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36 ，这是所有情况中的最小值。 所以追加到数组中的两个整数之和是 1 + 2 + 3 + 4 + 7 + 8 = 25 ，所以返回 25 。 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i], k &lt;= 10^9 分析：因为要使数组元素和尽可能小，所以最好的情况应该是1加到k，但给出的数组里面有可能有会有这之间的数存在，所以一但出现一个，就k++。结果要记得减去这些数 代码：class Solution { public: long long minimalKSum(vector&lt;int&gt;&amp; nums, int k) { sort(nums.begin(), nums.end()); long long k1 = k; long long ret = 0; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] &lt;= k1){ if(i == 0 || nums[i] != nums[i-1]){ k1++; ret -= nums[i]; } } } ret += (1+k1)*k1/2; return ret; } }; 题目地址:https://leetcode-cn.com/problems/append-k-integers-with-minimal-sum/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 6016. Excel 表中某个范围内的单元格]]></title>
    <url>%2F2022%2F03%2F07%2Fleetcode%206016.%20Excel%20%E8%A1%A8%E4%B8%AD%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%8D%95%E5%85%83%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目：Excel 表中的一个单元格 (r, c) 会以字符串 ““ 的形式进行表示，其中： 即单元格的列号 c 。用英文字母表中的 字母 标识。 例如，第 1 列用 ‘A’ 表示，第 2 列用 ‘B’ 表示，第 3 列用 ‘C’ 表示，以此类推。 即单元格的行号 r 。第 r 行就用 整数 r 标识。 给你一个格式为 “:“ 的字符串 s ，其中 表示 c1 列， 表示 r1 行， 表示 c2 列， 表示 r2 行，并满足 r1 &lt;= r2 且 c1 &lt;= c2 。 找出所有满足 r1 &lt;= x &lt;= r2 且 c1 &lt;= y &lt;= c2 的单元格，并以列表形式返回。单元格应该按前面描述的格式用 字符串 表示，并以 非递减 顺序排列（先按列排，再按行排）。 示例：示例 1： 输入：s = &quot;K1:L2&quot; 输出：[&quot;K1&quot;,&quot;K2&quot;,&quot;L1&quot;,&quot;L2&quot;] 解释： 上图显示了列表中应该出现的单元格。 红色箭头指示单元格的出现顺序。 示例 2： 输入：s = &quot;A1:F1&quot; 输出：[&quot;A1&quot;,&quot;B1&quot;,&quot;C1&quot;,&quot;D1&quot;,&quot;E1&quot;,&quot;F1&quot;] 解释： 上图显示了列表中应该出现的单元格。 红色箭头指示单元格的出现顺序。 提示： s.length == 5 ‘A’ &lt;= s[0] &lt;= s[3] &lt;= ‘Z’ ‘1’ &lt;= s[1] &lt;= s[4] &lt;= ‘9’ s 由大写英文字母、数字、和 ‘:’ 组成 分析：两层循环 代码：class Solution { public: vector&lt;string&gt; cellsInRange(string s) { vector&lt;string&gt; ret; char a1 = s[0]; char a2 = s[3]; char b1 = s[1]; char b2 = s[4]; for(char i = a1; i &lt;= a2; i++){ for(int j = b1; j &lt;= b2; j++){ string str = &quot;&quot;; str += i; str += j; ret.push_back(str); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/cells-in-a-range-on-an-excel-sheet/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 6011. 完成比赛的最少时间]]></title>
    <url>%2F2022%2F02%2F28%2Fleetcode%206011.%20%E5%AE%8C%E6%88%90%E6%AF%94%E8%B5%9B%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的二维整数数组 tires ，其中 tires[i] = [fi, ri] 表示第 i 种轮胎如果连续使用，第 x 圈需要耗时 fi * ri(x-1) 秒。 比方说，如果 fi = 3 且 ri = 2 ，且一直使用这种类型的同一条轮胎，那么该轮胎完成第 1 圈赛道耗时 3 秒，完成第 2 圈耗时 3 2 = 6 秒，完成第 3 圈耗时 3 22 = 12 秒，依次类推。 同时给你一个整数 changeTime 和一个整数 numLaps 。 比赛总共包含 numLaps 圈，你可以选择 任意 一种轮胎开始比赛。每一种轮胎都有 无数条 。每一圈后，你可以选择耗费 changeTime 秒 换成 任意一种轮胎（也可以换成当前种类的新轮胎）。 请你返回完成比赛需要耗费的 最少 时间。 示例：示例 1： 输入：tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4 输出：21 解释： 第 1 圈：使用轮胎 0 ，耗时 2 秒。 第 2 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。 第 3 圈：耗费 5 秒换一条新的轮胎 0 ，然后耗时 2 秒完成这一圈。 第 4 圈：继续使用轮胎 0 ，耗时 2 * 3 = 6 秒。 总耗时 = 2 + 6 + 5 + 2 + 6 = 21 秒。 完成比赛的最少时间为 21 秒。 示例 2： 输入：tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5 输出：25 解释： 第 1 圈：使用轮胎 1 ，耗时 2 秒。 第 2 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。 第 3 圈：耗时 6 秒换一条新的轮胎 1 ，然后耗时 2 秒完成这一圈。 第 4 圈：继续使用轮胎 1 ，耗时 2 * 2 = 4 秒。 第 5 圈：耗时 6 秒换成轮胎 0 ，然后耗时 1 秒完成这一圈。 总耗时 = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 秒。 完成比赛的最少时间为 25 秒。 提示： 1 &lt;= tires.length &lt;= 10^5 tires[i].length == 2 1 &lt;= fi, changeTime &lt;= 10^5 2 &lt;= ri &lt;= 10^5 1 &lt;= numLaps &lt;= 1000 分析： 当一个轮胎跑一圈耗时大于同一个轮胎跑第一圈耗时加换胎时间时必然选择换胎 轮胎连续使用耗时会指数增长，最多一个轮胎使用19天，因为2^18 = 262144，而轮胎跑第一圈耗时加换胎时间为 2*10^5 可以预处理 1~19 每个圈数所需最少时间存储在mintime数组中（预处理时第一个轮胎也加上换胎时间，返回结果时记得去掉） 之后使用动态规划： dp[i+j] = min(dp[i+j], dp[i] + mintime[j]) i表示当前圈数，j为1~19之间的数，dp[i]为跑第i圈所需最小时间，mintime[j]表示j圈所需最小花费 代码：class Solution { public: int minimumFinishTime(vector&lt;vector&lt;int&gt;&gt;&amp; tires, int changeTime, int numLaps) { vector&lt;int&gt; mintime(20, 1e9); vector&lt;int&gt; dp(numLaps+1, 1e9); for(auto a : tires){ long long t = a[0]; for(int i = 1, sum = t+changeTime; t &lt;= a[0]+changeTime; i++, t *= a[1], sum += t){ mintime[i] = min(mintime[i], sum); } } dp[0] = 0; for(int i = 0; i &lt;= numLaps; i++){ for(int j = 1; j &lt; 20 &amp;&amp; i+j &lt;= numLaps; j++){ dp[i+j] = min(dp[i+j], dp[i] + mintime[j]); } } return dp[numLaps] - changeTime; } }; 题目地址:https://leetcode-cn.com/problems/minimum-time-to-finish-the-race/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 6010. 完成旅途的最少时间]]></title>
    <url>%2F2022%2F02%2F28%2Fleetcode%206010.%20%E5%AE%8C%E6%88%90%E6%97%85%E9%80%94%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。 每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。 给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。 示例：示例 1： 输入：time = [1,2,3], totalTrips = 5 输出：3 解释： - 时刻 t = 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。 已完成的总旅途数为 1 + 0 + 0 = 1 。 - 时刻 t = 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。 已完成的总旅途数为 2 + 1 + 0 = 3 。 - 时刻 t = 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。 已完成的总旅途数为 3 + 1 + 1 = 5 。 所以总共完成至少 5 趟旅途的最少时间为 3 。 示例 2： 输入：time = [2], totalTrips = 1 输出：2 解释： 只有一辆公交车，它将在时刻 t = 2 完成第一趟旅途。 所以完成 1 趟旅途的最少时间为 2 。 提示： 1 &lt;= time.length &lt;= 10^5 1 &lt;= time[i], totalTrips &lt;= 10^7 分析：使用二分法 代码：class Solution { public: long long minimumTime(vector&lt;int&gt;&amp; time, int totalTrips) { long long l = 0; long long r = 100000000000000; while(l &lt; r){ long long m = (l+r)/2; long long t = 0; for(int i = 0; i &lt; time.size(); i++) t += m / time[i]; if(t &lt; totalTrips) l = m+1; else r = m; } return l; } }; 题目地址:https://leetcode-cn.com/problems/minimum-time-to-complete-trips/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 6009. 使两字符串互为字母异位词的最少步骤数]]></title>
    <url>%2F2022%2F02%2F28%2Fleetcode%206009.%20%E4%BD%BF%E4%B8%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%92%E4%B8%BA%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E7%9A%84%E6%9C%80%E5%B0%91%E6%AD%A5%E9%AA%A4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你两个字符串 s 和 t 。在一步操作中，你可以给 s 或者 t 追加 任一字符 。 返回使 s 和 t 互为 字母异位词 所需的最少步骤数。 字母异位词 指字母相同但是顺序不同（或者相同）的字符串。 示例：示例 1： 输入：s = &quot;leetcode&quot;, t = &quot;coats&quot; 输出：7 解释： - 执行 2 步操作，将 &quot;as&quot; 追加到 s = &quot;leetcode&quot; 中，得到 s = &quot;leetcodeas&quot; 。 - 执行 5 步操作，将 &quot;leede&quot; 追加到 t = &quot;coats&quot; 中，得到 t = &quot;coatsleede&quot; 。 &quot;leetcodeas&quot; 和 &quot;coatsleede&quot; 互为字母异位词。 总共用去 2 + 5 = 7 步。 可以证明，无法用少于 7 步操作使这两个字符串互为字母异位词。 示例 2： 输入：s = &quot;night&quot;, t = &quot;thing&quot; 输出：0 解释：给出的字符串已经互为字母异位词。因此，不需要任何进一步操作。 提示： 1 &lt;= s.length, t.length &lt;= 2 * 10^5 s 和 t 由小写英文字符组成 分析：统计两个字符串各自的字符出现个数 将每个字符出现次数的差相加 代码：class Solution { public: int minSteps(string s, string t) { int ret = 0; vector&lt;int&gt; scnt(26, 0); vector&lt;int&gt; tcnt(26, 0); for(auto a : s){ scnt[a-&apos;a&apos;]++; } for(auto a : t){ tcnt[a-&apos;a&apos;]++; } for(int i = 0; i &lt; 26; i++){ ret += abs(scnt[i] - tcnt[i]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 6008. 统计包含给定前缀的字符串]]></title>
    <url>%2F2022%2F02%2F28%2Fleetcode%206008.%20%E7%BB%9F%E8%AE%A1%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%89%8D%E7%BC%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串数组 words 和一个字符串 pref 。 返回 words 中以 pref 作为 前缀 的字符串的数目。 字符串 s 的 前缀 就是 s 的任一前导连续字符串。 示例：示例 1： 输入：words = [&quot;pay&quot;,&quot;attention&quot;,&quot;practice&quot;,&quot;attend&quot;], pref = &quot;at&quot; 输出：2 解释：以 &quot;at&quot; 作为前缀的字符串有两个，分别是：&quot;attention&quot; 和 &quot;attend&quot; 。 示例 2： 输入：words = [&quot;leetcode&quot;,&quot;win&quot;,&quot;loops&quot;,&quot;success&quot;], pref = &quot;code&quot; 输出：0 解释：不存在以 &quot;code&quot; 作为前缀的字符串。 提示： 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length, pref.length &lt;= 100 words[i] 和 pref 由小写英文字母组成 分析：遍历数组words，将每个字符串和pref匹配 代码：class Solution { public: int prefixCount(vector&lt;string&gt;&amp; words, string pref) { int ret = 0; for(int i = 0; i &lt; words.size(); i++){ bool b = true; for(int j = 0; j &lt; pref.size(); j++){ if(words[i][j] != pref[j]){ b = false; break; } } if(b) ret++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/counting-words-with-a-given-prefix/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 6015. 统计可以被 K 整除的下标对数目]]></title>
    <url>%2F2022%2F02%2F21%2Fleetcode%206015.%20%E7%BB%9F%E8%AE%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%20K%20%E6%95%B4%E9%99%A4%E7%9A%84%E4%B8%8B%E6%A0%87%E5%AF%B9%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始、长度为 n 的整数数组 nums 和一个整数 k ，返回满足下述条件的下标对 (i, j) 的数目： 0 &lt;= i &lt; j &lt;= n - 1 且 nums[i] * nums[j] 能被 k 整除。 示例：示例 1： 输入：nums = [1,2,3,4,5], k = 2 输出：7 解释： 共有 7 对下标的对应积可以被 2 整除： (0, 1)、(0, 3)、(1, 2)、(1, 3)、(1, 4)、(2, 3) 和 (3, 4) 它们的积分别是 2、4、6、8、10、12 和 20 。 其他下标对，例如 (0, 2) 和 (2, 4) 的乘积分别是 3 和 15 ，都无法被 2 整除。 示例 2： 输入：nums = [1,2,3,4], k = 5 输出：0 解释：不存在对应积可以被 5 整除的下标对。 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i], k &lt;= 10^5 分析：通过枚举得到其中一个数nums[i] ，目标找到另一个符合条件的整数nums[j] 为了让 nums[i] * nums[j] / k 余 0，先将nums[i] 和 k 约分，nums[j]的值就得是约分后的 k 的倍数 可以先在类外使用匿名函数预处理每个数的因子 参考：https://leetcode-cn.com/problems/count-array-pairs-divisible-by-k/solution/tong-ji-yin-zi-chu-xian-ci-shu-by-endles-t5k8/ 代码：vector&lt;int&gt; divisors[1000001]; int init = []() { // 预处理每个数的因子 for (int i = 1; i &lt; 100001; ++i) for (int j = i; j &lt; 100001; j += i) divisors[j].push_back(i); return 0; }(); class Solution { public: long long coutPairs(vector&lt;int&gt;&amp; nums, int k) { long long ret = 0; unordered_map&lt;int, int&gt; cnt; for(int a : nums){ ret += cnt[k/gcd(k, a)]; for(int b : divisors[a]){ cnt[b]++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-array-pairs-divisible-by-k/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 6014. 构造限制重复的字符串]]></title>
    <url>%2F2022%2F02%2F21%2Fleetcode%206014.%20%E6%9E%84%E9%80%A0%E9%99%90%E5%88%B6%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s 和一个整数 repeatLimit ，用 s 中的字符构造一个新字符串 repeatLimitedString ，使任何字母 连续 出现的次数都不超过 repeatLimit 次。你不必使用 s 中的全部字符。 返回 字典序最大的 repeatLimitedString 。 如果在字符串 a 和 b 不同的第一个位置，字符串 a 中的字母在字母表中出现时间比字符串 b 对应的字母晚，则认为字符串 a 比字符串 b 字典序更大 。如果字符串中前 min(a.length, b.length) 个字符都相同，那么较长的字符串字典序更大。 示例：示例 1： 输入：s = &quot;cczazcc&quot;, repeatLimit = 3 输出：&quot;zzcccac&quot; 解释：使用 s 中的所有字符来构造 repeatLimitedString &quot;zzcccac&quot;。 字母 &apos;a&apos; 连续出现至多 1 次。 字母 &apos;c&apos; 连续出现至多 3 次。 字母 &apos;z&apos; 连续出现至多 2 次。 因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。 该字符串是字典序最大的 repeatLimitedString ，所以返回 &quot;zzcccac&quot; 。 注意，尽管 &quot;zzcccca&quot; 字典序更大，但字母 &apos;c&apos; 连续出现超过 3 次，所以它不是一个有效的 repeatLimitedString 。 示例 2： 输入：s = &quot;aababab&quot;, repeatLimit = 2 输出：&quot;bbabaa&quot; 解释： 使用 s 中的一些字符来构造 repeatLimitedString &quot;bbabaa&quot;。 字母 &apos;a&apos; 连续出现至多 2 次。 字母 &apos;b&apos; 连续出现至多 2 次。 因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。 该字符串是字典序最大的 repeatLimitedString ，所以返回 &quot;bbabaa&quot; 。 注意，尽管 &quot;bbabaaa&quot; 字典序更大，但字母 &apos;a&apos; 连续出现超过 2 次，所以它不是一个有效的 repeatLimitedString 。 提示： 1 &lt;= repeatLimit &lt;= s.length &lt;= 10^5 s 由小写英文字母组成 分析：使用长度为26的数组存储各个字符的出现次数 从后往前遍历，最多连续出现 repeatLimit 个同样字符就要加入一个比当前字符小一点的字符，如果没有可以添加的字符，舍弃掉剩下的字符 代码：class Solution { public: string repeatLimitedString(string s, int repeatLimit) { vector&lt;int&gt; v(26, 0); string ret = &quot;&quot;; for(int i = 0; i &lt; s.size(); i++){ v[s[i]-&apos;a&apos;]++; } for(int i = 25; i &gt;= 0; i--){ int n = 0; while(v[i] &gt; 0){ if(n &lt; repeatLimit){ ret += char(&apos;a&apos; + i); v[i]--; n++; } else{ n = 0; if(i == 0) return ret; for(int j = i-1; j &gt;= 0; j--){ if(v[j] &gt; 0){ ret += char(&apos;a&apos; + j); v[j]--; break; } if(j == 0){ return ret; } } } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/construct-string-with-repeat-limit/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 6013. 合并零之间的节点]]></title>
    <url>%2F2022%2F02%2F21%2Fleetcode%206013.%20%E5%90%88%E5%B9%B6%E9%9B%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：给你一个链表的头节点 head ，该链表包含由 0 分隔开的一连串整数。链表的 开端 和 末尾 的节点都满足 Node.val == 0 。 对于每两个相邻的 0 ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 0 移除，修改后的链表不应该含有任何 0 。 返回修改后链表的头节点 head 。 示例：示例 1： 输入：head = [0,3,1,0,4,5,2,0] 输出：[4,11] 解释： 上图表示输入的链表。修改后的链表包含： - 标记为绿色的节点之和：3 + 1 = 4 - 标记为红色的节点之和：4 + 5 + 2 = 11 示例 2： 输入：head = [0,1,0,3,0,2,2,0] 输出：[1,3,4] 解释： 上图表示输入的链表。修改后的链表包含： - 标记为绿色的节点之和：1 = 1 - 标记为红色的节点之和：3 = 3 - 标记为黄色的节点之和：2 + 2 = 4 提示： 列表中的节点数目在范围 [3, 2 * 105] 内 0 &lt;= Node.val &lt;= 1000 不存在连续两个 Node.val == 0 的节点 链表的 开端 和 末尾 节点都满足 Node.val == 0 分析：遍历链表。遇到非零值相加；遇到0，将之前相加的值存入 vector。以此类推 之后将vector转化成链表 代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeNodes(ListNode* head) { ListNode* ret = new ListNode(); vector&lt;int&gt; v; int s = 0; while(head != NULL){ if(head -&gt; val == 0){ if(s &gt; 0){ v.push_back(s); s = 0; } } else{ s += head -&gt; val; } head = head -&gt; next; } for(int i = v.size()-1; i &gt;= 0; i--){ ret-&gt;next = new ListNode(v[i], ret-&gt;next); } return ret-&gt;next; } }; 题目地址:https://leetcode-cn.com/problems/merge-nodes-in-between-zeros/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 6012. 统计各位数字之和为偶数的整数个数]]></title>
    <url>%2F2022%2F02%2F21%2Fleetcode%206012.%20%E7%BB%9F%E8%AE%A1%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B4%E6%95%B0%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个正整数 num ，请你统计并返回 小于或等于 num 且各位数字之和为 偶数 的正整数的数目。 正整数的 各位数字之和 是其所有位上的对应数字相加的结果。 示例：示例 1： 输入：num = 4 输出：2 解释： 只有 2 和 4 满足小于等于 4 且各位数字之和为偶数。 示例 2： 输入：num = 30 输出：14 解释： 只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是： 2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。 提示： 1 &lt;= num &lt;= 1000 分析：照题目计算一遍 代码：class Solution { public: int countEven(int num) { int ret = 0; for(int i = 1; i &lt;= num; i++){ int a = i; int b = 0; while(a &gt; 0){ b += a % 10; a /= 10; } if(b % 2 == 0) ret++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-integers-with-even-digit-sum/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2172. 数组的最大与和]]></title>
    <url>%2F2022%2F02%2F14%2Fleetcode%202172.%20%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B8%8E%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个长度为 n 的整数数组 nums 和一个整数 numSlots ，满足2 * numSlots &gt;= n 。总共有 numSlots 个篮子，编号为 1 到 numSlots 。 你需要把所有 n 个整数分到这些篮子中，且每个篮子 至多 有 2 个整数。一种分配方案的 与和 定义为每个数与它所在篮子编号的 按位与运算 结果之和。 比方说，将数字 [1, 3] 放入篮子 1 中，[4, 6] 放入篮子 2 中，这个方案的与和为 (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4 。 请你返回将 nums 中所有数放入 numSlots 个篮子中的最大与和。 示例：示例 1： 输入：nums = [1,2,3,4,5,6], numSlots = 3 输出：9 解释：一个可行的方案是 [1, 4] 放入篮子 1 中，[2, 6] 放入篮子 2 中，[3, 5] 放入篮子 3 中。 最大与和为 (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9 。 示例 2： 输入：nums = [1,3,10,4,7,1], numSlots = 9 输出：24 解释：一个可行的方案是 [1, 1] 放入篮子 1 中，[3] 放入篮子 3 中，[4] 放入篮子 4 中，[7] 放入篮子 7 中，[10] 放入篮子 9 中。 最大与和为 (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24 。 注意，篮子 2 ，5 ，6 和 8 是空的，这是允许的。 提示： n == nums.length 1 &lt;= numSlots &lt;= 9 1 &lt;= n &lt;= 2 * numSlots 1 &lt;= nums[i] &lt;= 15 分析：numSlots个篮子每个可以装两个可以看做numSlots*2个篮子每个可以装一个 使用动态规划和状态压缩 将 numSlots*2 个篮子看做 numSlots*2 位的二进制数，遍历每种可能 详细见代码 代码：class Solution { public: int maximumANDSum(vector&lt;int&gt;&amp; nums, int numSlots) { vector&lt;int&gt; dp(1 &lt;&lt; (numSlots*2), 0); // numSlots*2 个篮子 int ret = 0; // 需要返回的最大与和 for(int i = 0; i &lt; (1 &lt;&lt; (numSlots*2)); i++){ // 遍历篮子会出现的所有情况 // 二进制中1的数量，也就是已经装满的篮子 // 篮子中1的数量c表示已经装了前c个数字 int c = __builtin_popcount(i); if (c &gt;= nums.size()) continue; // 当1的数量大于等于整数的数量时就可以跳过 for(int j = 0; j &lt; numSlots*2; j++){ // 遍历所有篮子 if((i &amp; (1 &lt;&lt; j)) == 0){ // 找到空的篮子 int n = i | (1 &lt;&lt; j); // 为空的篮子加入数字 dp[n] = max(dp[n], dp[i] + (nums[c] &amp; (j/2+1))); //因为篮子数量乘2，并且以1开始，所以用j/2+1 } } } for(int i = 0; i &lt; (1 &lt;&lt; (numSlots*2)); i++){ // 找到所有状态中的最大与和 ret = max(ret, dp[i]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-and-sum-of-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2171. 拿出最少数目的魔法豆]]></title>
    <url>%2F2022%2F02%2F14%2Fleetcode%202171.%20%E6%8B%BF%E5%87%BA%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E9%AD%94%E6%B3%95%E8%B1%86%2F</url>
    <content type="text"><![CDATA[题目：给你一个 正 整数数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。 请你从每个袋子中 拿出 一些豆子（也可以 不拿出），使得剩下的 非空 袋子中（即 至少 还有 一颗 魔法豆的袋子）魔法豆的数目 相等 。一旦魔法豆从袋子中取出，你不能将它放到任何其他的袋子中。 请你返回你需要拿出魔法豆的 最少数目。 示例：示例 1： 输入：beans = [4,1,6,5] 输出：4 解释： - 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。 剩下袋子中魔法豆的数目为：[4,0,6,5] - 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,5] - 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,4] 总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 4 个魔法豆更少的方案。 示例 2： 输入：beans = [2,10,3,2] 输出：7 解释： - 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,2] - 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,0] - 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,0,0] 总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 7 个魔法豆更少的方案。 提示： 1 &lt;= beans.length &lt;= 10^5 1 &lt;= beans[i] &lt;= 10^5 分析：取豆子时有两种可能，全部取完或取到除取完的袋子外的最少豆子数 可以先将数组从小到大排序，遍历数组，下标左侧的全部拿空，右侧（包括当前下标）的全部取到和下标相同为止 可以使用前后缀和来减少时间复杂度 代码：class Solution { public: long long minimumRemoval(vector&lt;int&gt;&amp; beans) { sort(beans.begin(), beans.end()); long long l = 0; long long r = 0; for(auto a : beans){ r += a; } long long mi = r; for(int i = 0; i &lt; beans.size(); i++){ mi = mi &lt; l + (r - beans[i] * (beans.size()-i)) ? mi : l + (r - beans[i] * (beans.size()-i)); l += beans[i]; r -= beans[i]; } return mi; } }; 题目地址:https://leetcode-cn.com/problems/removing-minimum-number-of-magic-beans/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2170. 使数组变成交替数组的最少操作数]]></title>
    <url>%2F2022%2F02%2F14%2Fleetcode%202170.%20%E4%BD%BF%E6%95%B0%E7%BB%84%E5%8F%98%E6%88%90%E4%BA%A4%E6%9B%BF%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的数组 nums ，该数组由 n 个正整数组成。 如果满足下述条件，则数组 nums 是一个 交替数组 ： nums[i - 2] == nums[i] ，其中 2 &lt;= i &lt;= n - 1 。 nums[i - 1] != nums[i] ，其中 1 &lt;= i &lt;= n - 1 。 在一步 操作 中，你可以选择下标 i 并将 nums[i] 更改 为 任一 正整数。 返回使数组变成交替数组的 最少操作数 。 示例：示例 1： 输入：nums = [3,1,3,2,4,3] 输出：3 解释： 使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。 在这种情况下，操作数为 3 。 可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。 示例 2： 输入：nums = [1,2,2,2,2] 输出：2 解释： 使数组变成交替数组的方法之一是将该数组转换为 [1,2,1,2,1]. 在这种情况下，操作数为 2 。 注意，数组不能转换成 [2,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^5 分析：各自统计奇数和偶数位各个数字出现数量，并排序 接下来有两种可能 如果最大出现数量的数字相同，比较是奇数选择第二大的结果大还是偶数选择第二大的结果大，之后计算最小操作数 如果最大出现数量的数字不同，直接计算最小操作数 要注意特殊情况，当只有一种数的时候，奇数和偶数的数字相同，要小心数组溢出 代码：bool px(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ return a[1] &gt; b[1]; } class Solution { public: int minimumOperations(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; dan; unordered_map&lt;int, int&gt; fu; for(int i = 0; i &lt; nums.size(); i++){ if(i%2 == 0){ fu[nums[i]]++; } else{ dan[nums[i]]++; } } vector&lt;vector&lt;int&gt;&gt; v1; vector&lt;vector&lt;int&gt;&gt; v2; v1.push_back({-1, 0}); v2.push_back({-1, 0}); for(auto a = dan.begin(); a != dan.end(); a++){ v1.push_back({a-&gt;first, a-&gt;second}); } for(auto a = fu.begin(); a != fu.end(); a++){ v2.push_back({a-&gt;first, a-&gt;second}); } sort(v1.begin(), v1.end(), px); sort(v2.begin(), v2.end(), px); if(v1[0][0] == v2[0][0]){ return min(nums.size() - v1[0][1] - v2[1][1], nums.size() - v1[1][1] - v2[0][1]); } else{ return nums.size() - v1[0][1] - v2[0][1]; } } }; 题目地址:https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-alternating/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2169. 得到 0 的操作数]]></title>
    <url>%2F2022%2F02%2F14%2Fleetcode%202169.%20%E5%BE%97%E5%88%B0%200%20%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你两个 非负 整数 num1 和 num2 。 每一步 操作 中，如果 num1 &gt;= num2 ，你必须用 num1 减 num2 ；否则，你必须用 num2 减 num1 。 例如，num1 = 5 且 num2 = 4 ，应该用 num1 减 num2 ，因此，得到 num1 = 1 和 num2 = 4 。然而，如果 num1 = 4且 num2 = 5 ，一步操作后，得到 num1 = 4 和 num2 = 1 。 返回使 num1 = 0 或 num2 = 0 的 操作数 。 示例：示例 1： 输入：num1 = 2, num2 = 3 输出：3 解释： - 操作 1 ：num1 = 2 ，num2 = 3 。由于 num1 &lt; num2 ，num2 减 num1 得到 num1 = 2 ，num2 = 3 - 2 = 1 。 - 操作 2 ：num1 = 2 ，num2 = 1 。由于 num1 &gt; num2 ，num1 减 num2 。 - 操作 3 ：num1 = 1 ，num2 = 1 。由于 num1 == num2 ，num1 减 num2 。 此时 num1 = 0 ，num2 = 1 。由于 num1 == 0 ，不需要再执行任何操作。 所以总操作数是 3 。 示例 2： 输入：num1 = 10, num2 = 10 输出：1 解释： - 操作 1 ：num1 = 10 ，num2 = 10 。由于 num1 == num2 ，num1 减 num2 得到 num1 = 10 - 10 = 0 。 此时 num1 = 0 ，num2 = 10 。由于 num1 == 0 ，不需要再执行任何操作。 所以总操作数是 1 。 提示： 0 &lt;= num1, num2 &lt;= 10^5 分析：按照要求循环相减 代码：class Solution { public: int countOperations(int num1, int num2) { int ret = 0; while(num1 &gt; 0 &amp;&amp; num2 &gt; 0){ if(num1 &gt;= num2) num1 -= num2; else num2 -= num1; ret++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-operations-to-obtain-zero/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2167. 移除所有载有违禁货物车厢所需的最少时间]]></title>
    <url>%2F2022%2F02%2F07%2Fleetcode%202167.%20%E7%A7%BB%E9%99%A4%E6%89%80%E6%9C%89%E8%BD%BD%E6%9C%89%E8%BF%9D%E7%A6%81%E8%B4%A7%E7%89%A9%E8%BD%A6%E5%8E%A2%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的二进制字符串 s ，表示一个列车车厢序列。s[i] = ‘0’ 表示第 i 节车厢 不 含违禁货物，而 s[i] = ‘1’ 表示第 i 节车厢含违禁货物。 作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个： 从列车 左 端移除一节车厢（即移除 s[0]），用去 1 单位时间。 从列车 右 端移除一节车厢（即移除 s[s.length - 1]），用去 1 单位时间。 从列车车厢序列的 任意位置 移除一节车厢，用去 2 单位时间。 返回移除所有载有违禁货物车厢所需要的 最少 单位时间数。 注意，空的列车车厢序列视为没有车厢含违禁货物。 示例：示例 1： 输入：s = &quot;1100101&quot; 输出：5 解释： 一种从序列中移除所有载有违禁货物的车厢的方法是： - 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。 - 从右端移除一节车厢 1 次。所用时间是 1 。 - 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。 总时间是 2 + 1 + 2 = 5 。 一种替代方法是： - 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。 - 从右端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。 总时间也是 2 + 3 = 5 。 5 是移除所有载有违禁货物的车厢所需要的最少单位时间数。 没有其他方法能够用更少的时间移除这些车厢。 示例 2： 输入：s = &quot;0010&quot; 输出：2 解释： 一种从序列中移除所有载有违禁货物的车厢的方法是： - 从左端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。 总时间是 3. 另一种从序列中移除所有载有违禁货物的车厢的方法是： - 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。 总时间是 2. 另一种从序列中移除所有载有违禁货物的车厢的方法是： - 从右端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。 总时间是 2. 2 是移除所有载有违禁货物的车厢所需要的最少单位时间数。 没有其他方法能够用更少的时间移除这些车厢。 提示： 1 &lt;= s.length &lt;= 2 * 10^5 s[i] 为 ‘0’ 或 ‘1’ 分析：进行两遍动态规划，最后找出合适的分割点 dp[i] = min(dp[i-1]+2, i+1) dp[i]表示遍历到第i个车厢，dp[i-1]+2表示使用从中间删除车厢操作，需要2单位时间，i+1表示从左到i的车厢全部移除遇到的单位时间 右侧的动态规划同理 代码：class Solution { public: int minimumTime(string s) { vector&lt;int&gt; dpl(s.size(), 0); vector&lt;int&gt; dpr(s.size(), 0); if(s[0] == &apos;1&apos;) dpl[0] = 1; for(int i = 1; i &lt; s.size(); i++){ if(s[i] == &apos;1&apos;){ dpl[i] = min(dpl[i-1]+2, i+1); } else{ dpl[i] = dpl[i-1]; } } if(s[s.size()-1] == &apos;1&apos;) dpr[s.size()-1] = 1; for(int i = s.size()-2; i &gt;= 0; i--){ if(s[i] == &apos;1&apos;){ dpr[i] = min(dpr[i+1]+2, int(s.size())-i); } else{ dpr[i] = dpr[i+1]; } } int ret = min(dpr[0], dpl[s.size()-1]); for(int i = 1; i &lt; s.size(); i++){ ret = min(dpl[i-1] + dpr[i], ret); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2166. 设计位集]]></title>
    <url>%2F2022%2F02%2F07%2Fleetcode%202166.%20%E8%AE%BE%E8%AE%A1%E4%BD%8D%E9%9B%86%2F</url>
    <content type="text"><![CDATA[题目：位集 Bitset 是一种能以紧凑形式存储位的数据结构。 请你实现 Bitset 类。 Bitset(int size) 用 size 个位初始化 Bitset ，所有位都是 0 。 void fix(int idx) 将下标为 idx 的位上的值更新为 1 。如果值已经是 1 ，则不会发生任何改变。 void unfix(int idx) 将下标为 idx 的位上的值更新为 0 。如果值已经是 0 ，则不会发生任何改变。 void flip() 翻转 Bitset 中每一位上的值。换句话说，所有值为 0 的位将会变成 1 ，反之亦然。 boolean all() 检查 Bitset 中 每一位 的值是否都是 1 。如果满足此条件，返回 true ；否则，返回 false 。 boolean one() 检查 Bitset 中 是否 至少一位 的值是 1 。如果满足此条件，返回 true ；否则，返回 false 。 int count() 返回 Bitset 中值为 1 的位的 总数 。 String toString() 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 i 个下标处的字符应该与 Bitset 中的第 i 位一致。 示例：输入 [&quot;Bitset&quot;, &quot;fix&quot;, &quot;fix&quot;, &quot;flip&quot;, &quot;all&quot;, &quot;unfix&quot;, &quot;flip&quot;, &quot;one&quot;, &quot;unfix&quot;, &quot;count&quot;, &quot;toString&quot;] [[5], [3], [1], [], [], [0], [], [], [0], [], []] 输出 [null, null, null, null, false, null, null, true, null, 2, &quot;01010&quot;] 解释 Bitset bs = new Bitset(5); // bitset = &quot;00000&quot;. bs.fix(3); // 将 idx = 3 处的值更新为 1 ，此时 bitset = &quot;00010&quot; 。 bs.fix(1); // 将 idx = 1 处的值更新为 1 ，此时 bitset = &quot;01010&quot; 。 bs.flip(); // 翻转每一位上的值，此时 bitset = &quot;10101&quot; 。 bs.all(); // 返回 False ，bitset 中的值不全为 1 。 bs.unfix(0); // 将 idx = 0 处的值更新为 0 ，此时 bitset = &quot;00101&quot; 。 bs.flip(); // 翻转每一位上的值，此时 bitset = &quot;11010&quot; 。 bs.one(); // 返回 True ，至少存在一位的值为 1 。 bs.unfix(0); // 将 idx = 0 处的值更新为 0 ，此时 bitset = &quot;01010&quot; 。 bs.count(); // 返回 2 ，当前有 2 位的值为 1 。 bs.toString(); // 返回 &quot;01010&quot; ，即 bitset 的当前组成情况。 提示： 1 &lt;= size &lt;= 10^5 0 &lt;= idx &lt;= size - 1 至多调用 fix、unfix、flip、all、one、count 和 toString 方法 总共 105 次 至少调用 all、one、count 或 toString 方法一次 至多调用 toString 方法 5 次 分析：这几个操作里面时间复杂度比较高的是toString、flip、all、one、count toString最多5次可以不考虑 flip 可以用一个bool判断是否反转过 all 、 one 和 count 可以用一个变量记录1的数量来判断（记得要和flip交互） 代码：class Bitset { bitset&lt;100000&gt; bit; int s; bool b; int s0; int s1; public: Bitset(int size) { s = size; b = false; s0 = size; s1 = 0; } void fix(int idx) { if(b){ if(bit[idx] == 1){ s1++; s0--; } bit[idx] = 0; } else{ if(bit[idx] == 0){ s1++; s0--; } bit[idx] = 1; } cout &lt;&lt; s1 &lt;&lt; &quot; &quot;; } void unfix(int idx) { if(b){ if(bit[idx] == 0){ s1--; s0++; } bit[idx] = 1; } else{ if(bit[idx] == 1){ s1--; s0++; } bit[idx] = 0; } } void flip() { int a = s1; s1 = s0; s0 = a; if(b){ b = false; } else{ b = true; } } bool all() { if(s1 == s) return true; else return false; } bool one() { if(s1 &gt; 0) return true; else return false; } int count() { return s1; } string toString() { string str = &quot;&quot;; for(int i = 0; i &lt; s; i++){ if(b){ if(bit[i] == 1) str += &apos;0&apos;; else str += &apos;1&apos;; } else{ if(bit[i] == 1) str += &apos;1&apos;; else str += &apos;0&apos;; } } return str; } }; /** * Your Bitset object will be instantiated and called as such: * Bitset* obj = new Bitset(size); * obj-&gt;fix(idx); * obj-&gt;unfix(idx); * obj-&gt;flip(); * bool param_4 = obj-&gt;all(); * bool param_5 = obj-&gt;one(); * int param_6 = obj-&gt;count(); * string param_7 = obj-&gt;toString(); */ 题目地址:https://leetcode-cn.com/problems/design-bitset/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2165. 重排数字的最小值]]></title>
    <url>%2F2022%2F02%2F07%2Fleetcode%202165.%20%E9%87%8D%E6%8E%92%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 num 。重排 num 中的各位数字，使其值 最小化 且不含 任何 前导零。 返回不含前导零且值最小的重排数字。 注意，重排各位数字后，num 的符号不会改变。 示例：示例 1： 输入：num = 310 输出：103 解释：310 中各位数字的可行排列有：013、031、103、130、301、310 。 不含任何前导零且值最小的重排数字是 103 。 示例 2： 输入：num = -7605 输出：-7650 解释：-7605 中各位数字的部分可行排列为：-7650、-6705、-5076、-0567。 不含任何前导零且值最小的重排数字是 -7650 。 提示：-10^15 &lt;= num &lt;= 10^15 分析：根据是否是负数使用两种排法 将各个数字提取出来排序 正数时，将各个数字提取出来从小到大排序，要注意如果最小的是0，将第二小的放在第一个，之后再加入0 负数是，将各个数字提取出来从大到小排序，在组合回去 代码：bool dj(int a, int b){ return a &gt; b; } class Solution { public: long long smallestNumber(long long num) { long long ret = 0; if(num == 0){ return 0; } else if(num &gt; 0){ vector&lt;int&gt; v; long long n = num; while(n &gt; 0){ v.push_back(n%10); n /= 10; } sort(v.begin(), v.end()); int n0 = 0;; for(int i = 0; i &lt; v.size(); i++){ if(v[i] == 0){ n0++; } else{ ret *= 10; ret += v[i]; while(n0 &gt; 0){ ret *= 10; n0--; } } } } else{ vector&lt;int&gt; v; long long n = num; n *= -1; while(n &gt; 0){ v.push_back(n%10); n /= 10; } sort(v.begin(), v.end(), dj); for(int i = 0; i &lt; v.size(); i++){ ret *= 10; ret += v[i]; } ret *= -1; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/smallest-value-of-the-rearranged-number/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2164. 对奇偶下标分别排序]]></title>
    <url>%2F2022%2F02%2F07%2Fleetcode%202164.%20%E5%AF%B9%E5%A5%87%E5%81%B6%E4%B8%8B%E6%A0%87%E5%88%86%E5%88%AB%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的整数数组 nums 。根据下述规则重排 nums 中的值： 按 非递增 顺序排列 nums 奇数下标 上的所有值。 举个例子，如果排序前 nums = [4,1,2,3] ，对奇数下标的值排序后变为 [4,3,2,1] 。奇数下标 1 和 3 的值按照非递增顺序重排。 按 非递减 顺序排列 nums 偶数下标 上的所有值。 举个例子，如果排序前 nums = [4,1,2,3] ，对偶数下标的值排序后变为 [2,1,4,3] 。偶数下标 0 和 2 的值按照非递减顺序重排。 返回重排 nums 的值之后形成的数组。 示例：示例 1： 输入：nums = [4,1,2,3] 输出：[2,3,4,1] 解释： 首先，按非递增顺序重排奇数下标（1 和 3）的值。 所以，nums 从 [4,1,2,3] 变为 [4,3,2,1] 。 然后，按非递减顺序重排偶数下标（0 和 2）的值。 所以，nums 从 [4,1,2,3] 变为 [2,3,4,1] 。 因此，重排之后形成的数组是 [2,3,4,1] 。 示例 2： 输入：nums = [2,1] 输出：[2,1] 解释： 由于只有一个奇数下标和一个偶数下标，所以不会发生重排。 形成的结果数组是 [2,1] ，和初始数组一样。 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 分析：将数组分为奇数偶数两组，分别排序，再组合起来 代码：bool fdz(int a, int b){ return a &gt;= b; } class Solution { public: vector&lt;int&gt; sortEvenOdd(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; j; vector&lt;int&gt; o; vector&lt;int&gt; ret; for(int i = 0; i &lt; nums.size(); i++){ if(i % 2 == 1){ j.push_back(nums[i]); } else{ o.push_back(nums[i]); } } sort(j.begin(), j.end(), fdz); sort(o.begin(), o.end()); for(int i = 0; i &lt; o.size(); i++){ ret.push_back(o[i]); if(i &lt; j.size()){ ret.push_back(j[i]); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/sort-even-and-odd-indices-independently/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2157. 字符串分组]]></title>
    <url>%2F2022%2F02%2F07%2Fleetcode%202157.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的字符串数组 words 。每个字符串都只包含 小写英文字母 。words 中任意一个子串中，每个字母都至多只出现一次。 如果通过以下操作之一，我们可以从 s1 的字母集合得到 s2 的字母集合，那么我们称这两个字符串为 关联的 ： 往 s1 的字母集合中添加一个字母。 从 s1 的字母集合中删去一个字母。 将 s1 中的一个字母替换成另外任意一个字母（也可以替换为这个字母本身）。 数组 words 可以分为一个或者多个无交集的 组 。如果一个字符串与另一个字符串关联，那么它们应当属于同一个组。 注意，你需要确保分好组后，一个组内的任一字符串与其他组的字符串都不关联。可以证明在这个条件下，分组方案是唯一的。 请你返回一个长度为 2 的数组 ans ： ans[0] 是 words 分组后的 总组数 。 ans[1] 是字符串数目最多的组所包含的字符串数目。 示例：示例 1： 输入：words = [&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;,&quot;cde&quot;] 输出：[2,3] 解释： - words[0] 可以得到 words[1] （将 &apos;a&apos; 替换为 &apos;b&apos;）和 words[2] （添加 &apos;b&apos;）。所以 words[0] 与 words[1] 和 words[2] 关联。 - words[1] 可以得到 words[0] （将 &apos;b&apos; 替换为 &apos;a&apos;）和 words[2] （添加 &apos;a&apos;）。所以 words[1] 与 words[0] 和 words[2] 关联。 - words[2] 可以得到 words[0] （删去 &apos;b&apos;）和 words[1] （删去 &apos;a&apos;）。所以 words[2] 与 words[0] 和 words[1] 关联。 - words[3] 与 words 中其他字符串都不关联。 所以，words 可以分成 2 个组 [&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;] 和 [&quot;cde&quot;] 。最大的组大小为 3 。 示例 2： 输入：words = [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;] 输出：[1,3] 解释： - words[0] 与 words[1] 关联。 - words[1] 与 words[0] 和 words[2] 关联。 - words[2] 与 words[1] 关联。 由于所有字符串与其他字符串都关联，所以它们全部在同一个组内。 所以最大的组大小为 3 。 提示： 1 &lt;= words.length &lt;= 2 * 10^4 1 &lt;= words[i].length &lt;= 26 words[i] 只包含小写英文字母。 words[i] 中每个字母最多只出现一次。 分析：使用并查集可以将字符串分为各个组（使用一个数组记录各个组的字符串数量，同时记录组的数量和最大的组中数字符串数量） 因为字符串顺序不重要，可以用一串26位的二进制数来表示各个字符是否出现 遍历字符串数组，对每一个字符串进行三种操作，判断并查集中是否存在操作后的数，若存在，将原数组与操作后的数合并 代码：class Solution { map&lt;int, int&gt; pre; map&lt;int, int&gt; size; int groups; int max_size; int find_pre(int x) //查找结点x的根结点 { if(pre[x] == x){ //递归出口：x的上级为x本身，即x为根结点 return x; } return pre[x] = find_pre(pre[x]); //递归查找 此代码相当于 先找到根结点rootx，然后pre[x]=rootx } void Union(int i,int j) { if(pre.count(j) == 0) return; int i1=find_pre(i); int j1=find_pre(j); if(i1==j1) return; pre[i1]=j1; size[j1] = size[i1] + size[j1]; max_size = max(max_size, size[j1]); groups--; } public: vector&lt;int&gt; groupStrings(vector&lt;string&gt;&amp; words) { max_size = 1; groups = words.size(); for(int i = 0; i &lt; words.size(); i++){ int x = 0; for(int j = 0; j &lt; words[i].size(); j++){ x |= 1 &lt;&lt; (words[i][j]-&apos;a&apos;); } pre[x] = x; size[x]++; max_size = max(max_size, size[x]); if(size[x] &gt; 1) groups--; } for(auto a = pre.begin(); a != pre.end(); a++){ for(int j = 0; j &lt; 26; j++){ if((a-&gt;first &gt;&gt; j) &amp; 1){ Union(a-&gt;first, a-&gt;first ^ (1 &lt;&lt; j)); for(int k = 0; k &lt; 26; k++){ if(((a-&gt;first &gt;&gt; k) &amp; 1) == 0){ Union(a-&gt;first, a-&gt;first ^ (1 &lt;&lt; j) | (1 &lt;&lt; k)); } } } else{ Union(a-&gt;first, a-&gt;first | (1 &lt;&lt; j)); } } } return vector&lt;int&gt;{groups, max_size}; } }; 题目地址:https://leetcode-cn.com/problems/groups-of-strings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2156. 查找给定哈希值的子串]]></title>
    <url>%2F2022%2F02%2F07%2Fleetcode%202156.%20%E6%9F%A5%E6%89%BE%E7%BB%99%E5%AE%9A%E5%93%88%E5%B8%8C%E5%80%BC%E7%9A%84%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给定整数 p 和 m ，一个长度为 k 且下标从 0 开始的字符串 s 的哈希值按照如下函数计算： hash(s, p, m) = (val(s[0]) p0 + val(s[1]) p1 + … + val(s[k-1]) * pk-1) mod m. 其中 val(s[i]) 表示 s[i] 在字母表中的下标，从 val(‘a’) = 1 到 val(‘z’) = 26 。 给你一个字符串 s 和整数 power，modulo，k 和 hashValue 。请你返回 s 中 第一个 长度为 k 的 子串 sub ，满足 hash(sub, power, modulo) == hashValue 。 测试数据保证一定 存在 至少一个这样的子串。 子串 定义为一个字符串中连续非空字符组成的序列。 示例：示例 1： 输入：s = &quot;leetcode&quot;, power = 7, modulo = 20, k = 2, hashValue = 0 输出：&quot;ee&quot; 解释：&quot;ee&quot; 的哈希值为 hash(&quot;ee&quot;, 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0 。 &quot;ee&quot; 是长度为 2 的第一个哈希值为 0 的子串，所以我们返回 &quot;ee&quot; 。 示例 2： 输入：s = &quot;fbxzaad&quot;, power = 31, modulo = 100, k = 3, hashValue = 32 输出：&quot;fbx&quot; 解释：&quot;fbx&quot; 的哈希值为 hash(&quot;fbx&quot;, 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32 。 &quot;bxz&quot; 的哈希值为 hash(&quot;bxz&quot;, 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32 。 &quot;fbx&quot; 是长度为 3 的第一个哈希值为 32 的子串，所以我们返回 &quot;fbx&quot; 。 注意，&quot;bxz&quot; 的哈希值也为 32 ，但是它在字符串中比 &quot;fbx&quot; 更晚出现。 提示： 1 &lt;= k &lt;= s.length &lt;= 2 * 10^4 1 &lt;= power, modulo &lt;= 10^9 0 &lt;= hashValue &lt; modulo s 只包含小写英文字母。 测试数据保证一定 存在 满足条件的子串。 分析：可以使用滑动窗口进行计算 窗口每右移一位，相当于去除最左侧字符代表的值，将剩下的数除以p，再加上最右侧字符代表的值（计算过后的） 这里有一个问题，除法无法取模，可以将滑动窗口从右往左滑动，这样里面的除法计算就成了乘法 代码：class Solution { public: string subStrHash(string s, int power, int modulo, int k, int hashValue) { int l = s.size()-k; int r = s.size()-1; long long pm = 1; long long ckhx = 0; string ret = &quot;&quot;; for(int i = s.size()-k; i &lt; s.size(); i++){ ckhx = (ckhx + (s[i]-&apos;a&apos;+1) * pm) % modulo; if(i &lt; s.size()-1) pm = (pm * power) % modulo; } if(ckhx == hashValue) ret = s.substr(l, k); for(int i = s.size()-k-1; i &gt;= 0; i--){ ckhx = (ckhx + modulo - ((s[r]-&apos;a&apos;+1) * pm) % modulo) % modulo; ckhx = (ckhx * power) % modulo; ckhx = (ckhx + (s[i]-&apos;a&apos;+1)) % modulo; l--; r--; if(ckhx == hashValue){ ret = s.substr(l, k); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-substring-with-given-hash-value/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2155. 分组得分最高的所有下标]]></title>
    <url>%2F2022%2F02%2F07%2Fleetcode%202155.%20%E5%88%86%E7%BB%84%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E6%89%80%E6%9C%89%E4%B8%8B%E6%A0%87%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的二进制数组 nums ，数组长度为 n 。nums 可以按下标 i（ 0 &lt;= i &lt;= n ）拆分成两个数组（可能为空）：numsleft 和 numsright 。 numsleft 包含 nums 中从下标 0 到 i - 1 的所有元素（包括 0 和 i - 1 ），而 numsright 包含 nums 中从下标 i 到 n - 1 的所有元素（包括 i 和 n - 1 ）。 如果 i == 0 ，numsleft 为 空 ，而 numsright 将包含 nums 中的所有元素。 如果 i == n ，numsleft 将包含 nums 中的所有元素，而 numsright 为 空 。 下标 i 的 分组得分 为 numsleft 中 0 的个数和 numsright 中 1 的个数之 和 。 返回 分组得分 最高 的 所有不同下标 。你可以按 任意顺序 返回答案。 示例：示例 1： 输入：nums = [0,0,1,0] 输出：[2,4] 解释：按下标分组 - 0 ：numsleft 为 [] 。numsright 为 [0,0,1,0] 。得分为 0 + 1 = 1 。 - 1 ：numsleft 为 [0] 。numsright 为 [0,1,0] 。得分为 1 + 1 = 2 。 - 2 ：numsleft 为 [0,0] 。numsright 为 [1,0] 。得分为 2 + 1 = 3 。 - 3 ：numsleft 为 [0,0,1] 。numsright 为 [0] 。得分为 2 + 0 = 2 。 - 4 ：numsleft 为 [0,0,1,0] 。numsright 为 [] 。得分为 3 + 0 = 3 。 下标 2 和 4 都可以得到最高的分组得分 3 。 注意，答案 [4,2] 也被视为正确答案。 示例 2： 输入：nums = [0,0,0] 输出：[3] 解释：按下标分组 - 0 ：numsleft 为 [] 。numsright 为 [0,0,0] 。得分为 0 + 0 = 0 。 - 1 ：numsleft 为 [0] 。numsright 为 [0,0] 。得分为 1 + 0 = 1 。 - 2 ：numsleft 为 [0,0] 。numsright 为 [0] 。得分为 2 + 0 = 2 。 - 3 ：numsleft 为 [0,0,0] 。numsright 为 [] 。得分为 3 + 0 = 3 。 只有下标 3 可以得到最高的分组得分 3 。 示例 3： 输入：nums = [1,1] 输出：[0] 解释：按下标分组 - 0 ：numsleft 为 [] 。numsright 为 [1,1] 。得分为 0 + 2 = 2 。 - 1 ：numsleft 为 [1] 。numsright 为 [1] 。得分为 0 + 1 = 1 。 - 2 ：numsleft 为 [1,1] 。numsright 为 [] 。得分为 0 + 0 = 0 。 只有下标 0 可以得到最高的分组得分 2 。 提示： n == nums.length 1 &lt;= n &lt;= 10^5 nums[i] 为 0 或 1 分析：计算前后前缀和 遍历所有下标找到最高的得分 再度遍历一遍，找到最高得分的所有不同下标 代码：class Solution { public: vector&lt;int&gt; maxScoreIndices(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; l(nums.size(), 0); vector&lt;int&gt; r(nums.size(), 0); vector&lt;int&gt; ret; int m = 0; if(nums[0] == 0){ l[0] = 1; } for(int i = 1; i &lt; nums.size(); i++){ l[i] = l[i-1]; if(nums[i] == 0){ l[i]++; } } r[nums.size()-1] = nums[nums.size()-1]; for(int i = nums.size()-2; i &gt;= 0; i--){ r[i] = r[i+1]; if(nums[i] == 1){ r[i] += 1; } } for(int i = 1; i &lt; nums.size(); i++){ if(m &lt; l[i-1] + r[i]){ m = l[i-1] + r[i]; } } if(m &lt; l[l.size()-1]){ m = l[l.size()-1]; } if(m &lt; r[0]){ m = r[0]; } for(int i = 1; i &lt; nums.size(); i++){ if(m == l[i-1] + r[i]){ ret.push_back(i); } } if(m == l[l.size()-1]){ ret.push_back(l.size()); } if(m == r[0]){ ret.push_back(0); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/all-divisions-with-the-highest-score-of-a-binary-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2154. 将找到的值乘以 2]]></title>
    <url>%2F2022%2F02%2F07%2Fleetcode%202154.%20%E5%B0%86%E6%89%BE%E5%88%B0%E7%9A%84%E5%80%BC%E4%B9%98%E4%BB%A5%202%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums ，另给你一个整数 original ，这是需要在 nums 中搜索的第一个数字。 接下来，你需要按下述步骤操作： 如果在 nums 中找到 original ，将 original 乘以 2 ，得到新 original（即，令 original = 2 * original）。 否则，停止这一过程。 只要能在数组中找到新 original ，就对新 original 继续 重复 这一过程。 返回 original 的 最终 值。 示例：示例 1： 输入：nums = [5,3,6,1,12], original = 3 输出：24 解释： - 3 能在 nums 中找到。3 * 2 = 6 。 - 6 能在 nums 中找到。6 * 2 = 12 。 - 12 能在 nums 中找到。12 * 2 = 24 。 - 24 不能在 nums 中找到。因此，返回 24 。 示例 2： 输入：nums = [2,7,9], original = 4 输出：4 解释： - 4 不能在 nums 中找到。因此，返回 4 。 提示： 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i], original &lt;= 1000 分析：对nums排序 遍历nums，找到 original 可以得到的最大值 代码：class Solution { public: int findFinalValue(vector&lt;int&gt;&amp; nums, int original) { sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); i++){ if(original == nums[i]){ original *= 2; } else if(original &lt; nums[i]){ break; } } return original; } }; 题目地址:https://leetcode-cn.com/problems/keep-multiplying-found-values-by-two/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2151. 基于陈述统计最多好人数]]></title>
    <url>%2F2022%2F01%2F24%2Fleetcode%202151.%20%E5%9F%BA%E4%BA%8E%E9%99%88%E8%BF%B0%E7%BB%9F%E8%AE%A1%E6%9C%80%E5%A4%9A%E5%A5%BD%E4%BA%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：游戏中存在两种角色： 好人：该角色只说真话。 坏人：该角色可能说真话，也可能说假话。 给你一个下标从 0 开始的二维整数数组 statements ，大小为 n x n ，表示 n 个玩家对彼此角色的陈述。具体来说，statements[i][j] 可以是下述值之一： 0 表示 i 的陈述认为 j 是 坏人 。 1 表示 i 的陈述认为 j 是 好人 。 2 表示 i 没有对 j 作出陈述。 另外，玩家不会对自己进行陈述。形式上，对所有 0 &lt;= i &lt; n ，都有 statements[i][i] = 2 。 根据这 n 个玩家的陈述，返回可以认为是 好人 的 最大 数目。 示例：示例 1： 输入：statements = [[2,1,2],[1,2,2],[2,0,2]] 输出：2 解释：每个人都做一条陈述。 - 0 认为 1 是好人。 - 1 认为 0 是好人。 - 2 认为 1 是坏人。 以 2 为突破点。 - 假设 2 是一个好人： - 基于 2 的陈述，1 是坏人。 - 那么可以确认 1 是坏人，2 是好人。 - 基于 1 的陈述，由于 1 是坏人，那么他在陈述时可能： - 说真话。在这种情况下会出现矛盾，所以假设无效。 - 说假话。在这种情况下，0 也是坏人并且在陈述时说假话。 - 在认为 2 是好人的情况下，这组玩家中只有一个好人。 - 假设 2 是一个坏人： - 基于 2 的陈述，由于 2 是坏人，那么他在陈述时可能： - 说真话。在这种情况下，0 和 1 都是坏人。 - 在认为 2 是坏人但说真话的情况下，这组玩家中没有一个好人。 - 说假话。在这种情况下，1 是好人。 - 由于 1 是好人，0 也是好人。 - 在认为 2 是坏人且说假话的情况下，这组玩家中有两个好人。 在最佳情况下，至多有两个好人，所以返回 2 。 注意，能得到此结论的方法不止一种。 示例 2： 输入：statements = [[2,0],[0,2]] 输出：1 解释：每个人都做一条陈述。 - 0 认为 1 是坏人。 - 1 认为 0 是坏人。 以 0 为突破点。 - 假设 0 是一个好人： - 基于与 0 的陈述，1 是坏人并说假话。 - 在认为 0 是好人的情况下，这组玩家中只有一个好人。 - 假设 0 是一个坏人： - 基于 0 的陈述，由于 0 是坏人，那么他在陈述时可能： - 说真话。在这种情况下，0 和 1 都是坏人。 - 在认为 0 是坏人但说真话的情况下，这组玩家中没有一个好人。 - 说假话。在这种情况下，1 是好人。 - 在认为 0 是坏人且说假话的情况下，这组玩家中只有一个好人。 在最佳情况下，至多有一个好人，所以返回 1 。 注意，能得到此结论的方法不止一种。 提示： n == statements.length == statements[i].length 2 &lt;= n &lt;= 15 statements[i][j] 的值为 0、1 或 2 statements[i][i] == 2 分析：因为n小于等于15，所以可以使用dfs将所有可能遍历一遍 代码：class Solution { int n; int ret; public: void dfs(int z, vector&lt;vector&lt;int&gt;&gt;&amp; statements, vector&lt;int&gt;&amp; hao, vector&lt;int&gt;&amp; huai){ if(z == n){ int ans = 0; for(int i = 0; i &lt; n; i++){ ans += hao[i]; } ret = max(ans, ret); return; } if(huai[z] == 0){ vector&lt;int&gt; hao1 = hao; vector&lt;int&gt; huai1 = huai; bool b = true; for(int i = 0; i &lt; n; i++){ if(statements[z][i] == 0){ if(hao1[i] == 1){ b = false; break; } else{ huai1[i] = 1; } } if(statements[z][i] == 1){ if(huai1[i] == 1){ b = false; break; } else{ hao1[i] = 1; } } } if(b){ hao1[z] = 1; dfs(z+1, statements, hao1, huai1); } } if(hao[z] == 0){ vector&lt;int&gt; hao1 = hao; vector&lt;int&gt; huai1 = huai; huai1[z] = 1; dfs(z+1, statements, hao1, huai1); } } int maximumGood(vector&lt;vector&lt;int&gt;&gt;&amp; statements) { ret = 0; n = statements.size(); vector&lt;int&gt; hao(n, 0); vector&lt;int&gt; huai(n, 0); dfs(0, statements, hao, huai); return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5990. 找出数组中的所有孤独数字]]></title>
    <url>%2F2022%2F01%2F24%2Fleetcode%205990.%20%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%AD%A4%E7%8B%AC%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 。如果数字 x 在数组中仅出现 一次 ，且没有 相邻 数字（即，x + 1 和 x - 1）出现在数组中，则认为数字 x 是 孤独数字 。 返回 nums 中的 所有 孤独数字。你可以按 任何顺序 返回答案。 示例：示例 1： 输入：nums = [10,6,5,8] 输出：[10,8] 解释： - 10 是一个孤独数字，因为它只出现一次，并且 9 和 11 没有在 nums 中出现。 - 8 是一个孤独数字，因为它只出现一次，并且 7 和 9 没有在 nums 中出现。 - 5 不是一个孤独数字，因为 6 出现在 nums 中，反之亦然。 因此，nums 中的孤独数字是 [10, 8] 。 注意，也可以返回 [8, 10] 。 示例 2： 输入：nums = [1,3,5,3] 输出：[1,5] 解释： - 1 是一个孤独数字，因为它只出现一次，并且 0 和 2 没有在 nums 中出现。 - 5 是一个孤独数字，因为它只出现一次，并且 4 和 6 没有在 nums 中出现。 - 3 不是一个孤独数字，因为它出现两次。 因此，nums 中的孤独数字是 [1, 5] 。 注意，也可以返回 [5, 1] 。 提示： 1 &lt;= nums.length &lt;= 10^5 0 &lt;= nums[i] &lt;= 10^6 分析：先排序，遍历一遍判断左右是否有相差小于等于1的数 代码：class Solution { public: vector&lt;int&gt; findLonely(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); vector&lt;int&gt; ret; for(int i = 0; i &lt; nums.size(); i++){ if(i-1 &gt;= 0 &amp;&amp; nums[i] - nums[i-1] &lt;= 1){ } else if(i+1 &lt; nums.size() &amp;&amp; nums[i+1] - nums[i] &lt;= 1){ } else{ ret.push_back(nums[i]); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-all-lonely-numbers-in-the-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5991. 按符号重排数组]]></title>
    <url>%2F2022%2F01%2F24%2Fleetcode%205991.%20%E6%8C%89%E7%AC%A6%E5%8F%B7%E9%87%8D%E6%8E%92%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的整数数组 nums ，数组长度为 偶数 ，由数目相等的正整数和负整数组成。 你需要 重排 nums 中的元素，使修改后的数组满足下述条件： 任意 连续 的两个整数 符号相反 对于符号相同的所有整数，保留 它们在 nums 中的 顺序 。 重排后数组以正整数开头。 重排元素满足上述条件后，返回修改后的数组。 示例：示例 1： 输入：nums = [3,1,-2,-5,2,-4] 输出：[3,-2,1,-5,2,-4] 解释： nums 中的正整数是 [3,1,2] ，负整数是 [-2,-5,-4] 。 重排的唯一可行方案是 [3,-2,1,-5,2,-4]，能满足所有条件。 像 [1,-2,2,-5,3,-4]、[3,1,2,-2,-5,-4]、[-2,3,-5,1,-4,2] 这样的其他方案是不正确的，因为不满足一个或者多个条件。 示例 2： 输入：nums = [-1,1] 输出：[1,-1] 解释： 1 是 nums 中唯一一个正整数，-1 是 nums 中唯一一个负整数。 所以 nums 重排为 [1,-1] 。 提示： 2 &lt;= nums.length &lt;= 2 * 105 nums.length 是 偶数 1 &lt;= |nums[i]| &lt;= 105 nums 由 相等 数量的正整数和负整数组成 分析：遍历数组，将正数和负数各自存入数组a和b 以一个a一个b的顺序存入返回数组 代码：class Solution { public: vector&lt;int&gt; rearrangeArray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector&lt;int&gt; ret; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] &gt; 0){ v1.push_back(nums[i]); } else{ v2.push_back(nums[i]); } } for(int i = 0; i &lt; v1.size(); i++){ ret.push_back(v1[i]); ret.push_back(v2[i]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/rearrange-array-elements-by-sign/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5989. 元素计数]]></title>
    <url>%2F2022%2F01%2F24%2Fleetcode%205989.%20%E5%85%83%E7%B4%A0%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums ，统计并返回在 nums 中同时具有一个严格较小元素和一个严格较大元素的元素数目。 示例：示例 1： 输入：nums = [11,7,2,15] 输出：2 解释：元素 7 ：严格较小元素是元素 2 ，严格较大元素是元素 11 。 元素 11 ：严格较小元素是元素 7 ，严格较大元素是元素 15 。 总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。 示例 2： 输入：nums = [-3,3,3,90] 输出：2 解释：元素 3 ：严格较小元素是元素 -3 ，严格较大元素是元素 90 。 由于有两个元素的值为 3 ，总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。 提示： 1 &lt;= nums.length &lt;= 100 -10^5 &lt;= nums[i] &lt;= 10^5 分析：排序去除两边相同的数，中间的数就是同时具有一个严格较小元素和一个严格较大元素的元素 代码：class Solution { public: int countElements(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int n = 2; for(int i = 1; i &lt; nums.size(); i++){ if(nums[i] == nums[i-1]) n++; else{ break; } } for(int i = nums.size()-2; i &gt;= 0; i--){ if(nums[i] == nums[i+1]) n++; else{ break; } } if(n &lt; nums.size()){ return nums.size()-n; } else{ return 0; } } }; 题目地址:https://leetcode-cn.com/problems/count-elements-with-strictly-smaller-and-greater-elements/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2141. 同时运行 N 台电脑的最长时间]]></title>
    <url>%2F2022%2F01%2F17%2Fleetcode%202141.%20%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%20N%20%E5%8F%B0%E7%94%B5%E8%84%91%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries ，其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟。你想使用这些电池让 全部 n 台电脑 同时 运行。 一开始，你可以给每台电脑连接 至多一个电池 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。 注意，你不能给电池充电。 请你返回你可以让 n 台电脑同时运行的 最长 分钟数。 示例：示例 1： 输入：n = 2, batteries = [3,3,3] 输出：4 解释： 一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 1 连接。 2 分钟后，将第二台电脑与电池 1 断开连接，并连接电池 2 。注意，电池 0 还可以供电 1 分钟。 在第 3 分钟结尾，你需要将第一台电脑与电池 0 断开连接，然后连接电池 1 。 在第 4 分钟结尾，电池 1 也被耗尽，第一台电脑无法继续运行。 我们最多能同时让两台电脑同时运行 4 分钟，所以我们返回 4 。 示例 2： 输入：n = 2, batteries = [1,1,1,1] 输出：2 解释： 一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 2 连接。 一分钟后，电池 0 和电池 2 同时耗尽，所以你需要将它们断开连接，并将电池 1 和第一台电脑连接，电池 3 和第二台电脑连接。 1 分钟后，电池 1 和电池 3 也耗尽了，所以两台电脑都无法继续运行。 我们最多能让两台电脑同时运行 2 分钟，所以我们返回 2 。 提示： 1 &lt;= n &lt;= batteries.length &lt;= 10^5 1 &lt;= batteries[i] &lt;= 10^9 分析：有两种可能 有几个电池使用时间特别长，大于剩下电池使用时间之和 / 剩余电脑数量 平均分配电量，直到不够所有电脑同时运行一分钟为止 第二种直接计算即可 第一种可以从大到小排序，使用二分法找出哪几个电池使用时间特别长，大于剩下电池使用时间之和 / 剩余电脑数量。得出之后只需要将剩下电池按第二种可能分配，得出的结果，即为同时运行时长 代码：bool bj(int a, int b){ return a&gt;b; } class Solution { public: long long maxRunTime(int n, vector&lt;int&gt;&amp; batteries) { if(n == 1){ long long ret = 0; for(int i = 0; i &lt; batteries.size(); i++){ ret += batteries[i]; } return ret; } long long ret = 0; sort(batteries.begin(), batteries.end(), bj); vector&lt;long long&gt; v(batteries.size(), 0); v[batteries.size()-1] = batteries[batteries.size()-1]; for(int i = batteries.size()-2; i &gt;= 0; i--){ v[i] = batteries[i] + v[i+1]; } int l = 0; int r = n-1; if(batteries[0] &gt; v[1] / (n-1)){ while(l &lt; r){ int m = (l+r)/2; if(batteries[m] &gt;= v[m+1] / (n - m-1)){ l = m+1; } else{ r = m-1; } } } ret = v[l] / (n-l); return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-running-time-of-n-computers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2140. 解决智力问题]]></title>
    <url>%2F2022%2F01%2F17%2Fleetcode%202140.%20%E8%A7%A3%E5%86%B3%E6%99%BA%E5%8A%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的二维整数数组 questions ，其中 questions[i] = [pointsi, brainpoweri] 。 这个数组表示一场考试里的一系列题目，你需要 按顺序 （也就是从问题 0 开始依次解决），针对每个问题选择 解决 或者 跳过 操作。解决问题 i 将让你 获得 pointsi 的分数，但是你将 无法 解决接下来的 brainpoweri 个问题（即只能跳过接下来的 brainpoweri 个问题）。如果你跳过问题 i ，你可以对下一个问题决定使用哪种操作。 比方说，给你 questions = [[3, 2], [4, 3], [4, 4], [2, 5]] ： 如果问题 0 被解决了， 那么你可以获得 3 分，但你不能解决问题 1 和 2 。 如果你跳过问题 0 ，且解决问题 1 ，你将获得 4 分但是不能解决问题 2 和 3 。 请你返回这场考试里你能获得的 最高 分数。 示例：示例 1： 输入：questions = [[3,2],[4,3],[4,4],[2,5]] 输出：5 解释：解决问题 0 和 3 得到最高分。 - 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。 - 不能解决问题 1 和 2 - 解决问题 3 ：获得 2 分 总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。 示例 2： 输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]] 输出：7 解释：解决问题 1 和 4 得到最高分。 - 跳过问题 0 - 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。 - 不能解决问题 2 和 3 - 解决问题 4 ：获得 5 分 总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。 提示： 1 &lt;= questions.length &lt;= 10^5questions[i].length == 2 1 &lt;= pointsi, brainpoweri &lt;= 10^5 分析：使用动态规划 dp[i+questions[i][1]+1] = max(dp[i+questions[i][1]+1], m+questions[i][0] 这其中的m表示到i为止的最高分数，从dp[0]到dp[i]中取最大值 代码：class Solution { public: long long mostPoints(vector&lt;vector&lt;int&gt;&gt;&amp; questions) { vector&lt;long long&gt; dp(questions.size(), 0); long long ret = 0; long long m = 0; for(int i = 0; i &lt; questions.size(); i++){ m = max(m, dp[i]); if(i + questions[i][1] + 1 &lt; dp.size()) dp[i + questions[i][1] + 1] = max(dp[i + questions[i][1] + 1], m + questions[i][0]); ret = max(m + questions[i][0], ret); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/solving-questions-with-brainpower/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2139. 得到目标值的最少行动次数]]></title>
    <url>%2F2022%2F01%2F17%2Fleetcode%202139.%20%E5%BE%97%E5%88%B0%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%91%E8%A1%8C%E5%8A%A8%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：你正在玩一个整数游戏。从整数 1 开始，期望得到整数 target 。 在一次行动中，你可以做下述两种操作之一： 递增，将当前整数的值加 1（即， x = x + 1）。 加倍，使当前整数的值翻倍（即，x = 2 * x）。 在整个游戏过程中，你可以使用 递增 操作 任意 次数。但是只能使用 加倍 操作 至多 maxDoubles 次。 给你两个整数 target 和 maxDoubles ，返回从 1 开始得到 target 需要的最少行动次数。 示例：示例 1： 输入：target = 5, maxDoubles = 0 输出：4 解释：一直递增 1 直到得到 target 。 示例 2： 输入：target = 19, maxDoubles = 2 输出：7 解释：最初，x = 1 。 递增 3 次，x = 4 。 加倍 1 次，x = 8 。 递增 1 次，x = 9 。 加倍 1 次，x = 18 。 递增 1 次，x = 19 。 示例 3： 输入：target = 10, maxDoubles = 4 输出：4 解释： 最初，x = 1 。 递增 1 次，x = 2 。 加倍 1 次，x = 4 。 递增 1 次，x = 5 。 加倍 1 次，x = 10 。 提示： 1 &lt;= target &lt;= 10^9 0 &lt;= maxDoubles &lt;= 100 分析：逆向思维，贪心 为了让加倍效果更好，应该越靠后使用越好 倒着计算： 当前数为偶数，除以2，加倍次数-1，行动次数+1 当前数为奇数，减1，行动次数+1 当数到达1，或者当加倍次数为0时，结束循环。 注意要将剩余的递增次数加上 代码：class Solution { public: int minMoves(int target, int maxDoubles) { int ret = 0; while(target &gt; 1){ if(target % 2 == 1){ ret++; target--; } else if(maxDoubles &gt; 0){ target = (target + 1) / 2; maxDoubles--; ret++; } else{ ret += target-1; break; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2138. 将字符串拆分为若干长度为 k 的组]]></title>
    <url>%2F2022%2F01%2F17%2Fleetcode%202138.%20%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86%E4%B8%BA%E8%8B%A5%E5%B9%B2%E9%95%BF%E5%BA%A6%E4%B8%BA%20k%20%E7%9A%84%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：字符串 s 可以按下述步骤划分为若干长度为 k 的组： 第一组由字符串中的前 k 个字符组成，第二组由接下来的 k 个字符串组成，依此类推。每个字符都能够成为 某一个 组的一部分。 对于最后一组，如果字符串剩下的字符 不足 k 个，需使用字符 fill 来补全这一组字符。 注意，在去除最后一个组的填充字符 fill（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 s 。 给你一个字符串 s ，以及每组的长度 k 和一个用于填充的字符 fill ，按上述步骤处理之后，返回一个字符串数组，该数组表示 s 分组后 每个组的组成情况 。 示例：示例 1： 输入：s = &quot;abcdefghi&quot;, k = 3, fill = &quot;x&quot; 输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;] 解释： 前 3 个字符是 &quot;abc&quot; ，形成第一组。 接下来 3 个字符是 &quot;def&quot; ，形成第二组。 最后 3 个字符是 &quot;ghi&quot; ，形成第三组。 由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。 因此，形成 3 组，分别是 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。 示例 2： 输入：s = &quot;abcdefghij&quot;, k = 3, fill = &quot;x&quot; 输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jxx&quot;] 解释： 与前一个例子类似，形成前三组 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。 对于最后一组，字符串中仅剩下字符 &apos;j&apos; 可以用。为了补全这一组，使用填充字符 &apos;x&apos; 两次。 因此，形成 4 组，分别是 &quot;abc&quot;、&quot;def&quot;、&quot;ghi&quot; 和 &quot;jxx&quot; 。 提示： 1 &lt;= s.length &lt;= 100 s 仅由小写英文字母组成 1 &lt;= k &lt;= 100 fill 是一个小写英文字母 分析：按要求拆分并补足最后一个字符串 代码：class Solution { public: vector&lt;string&gt; divideString(string s, int k, char fill) { vector&lt;string&gt; ret; string str = &quot;&quot;; for(int i = 0; i &lt;s.size(); i++){ str += s[i]; if(str.size() == k){ ret.push_back(str); str = &quot;&quot;; } } if(str.size() &gt; 0){ while(str.size() &lt; k){ str += fill; } ret.push_back(str); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/divide-a-string-into-groups-of-size-k/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2136. 全部开花的最早一天]]></title>
    <url>%2F2022%2F01%2F10%2Fleetcode%202136.%20%E5%85%A8%E9%83%A8%E5%BC%80%E8%8A%B1%E7%9A%84%E6%9C%80%E6%97%A9%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[题目：你有 n 枚花的种子。每枚种子必须先种下，才能开始生长、开花。播种需要时间，种子的生长也是如此。给你两个下标从 0 开始的整数数组 plantTime 和 growTime ，每个数组的长度都是 n ： plantTime[i] 是 播种 第 i 枚种子所需的 完整天数 。每天，你只能为播种某一枚种子而劳作。无须 连续几天都在种同一枚种子，但是种子播种必须在你工作的天数达到 plantTime[i] 之后才算完成。 growTime[i] 是第 i 枚种子完全种下后生长所需的 完整天数 。在它生长的最后一天 之后 ，将会开花并且永远 绽放 。 从第 0 开始，你可以按 任意 顺序播种种子。 返回所有种子都开花的 最早 一天是第几天。 示例：示例 1： 输入：plantTime = [1,4,3], growTime = [2,3,1] 输出：9 解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 一种最优方案是： 第 0 天，播种第 0 枚种子，种子生长 2 整天。并在第 3 天开花。 第 1、2、3、4 天，播种第 1 枚种子。种子生长 3 整天，并在第 8 天开花。 第 5、6、7 天，播种第 2 枚种子。种子生长 1 整天，并在第 9 天开花。 因此，在第 9 天，所有种子都开花。 示例 2： 输入：plantTime = [1,2,3,2], growTime = [2,1,2,1] 输出：9 解释：灰色的花盆表示播种的日子，彩色的花盆表示生长的日子，花朵表示开花的日子。 一种最优方案是： 第 1 天，播种第 0 枚种子，种子生长 2 整天。并在第 4 天开花。 第 0、3 天，播种第 1 枚种子。种子生长 1 整天，并在第 5 天开花。 第 2、4、5 天，播种第 2 枚种子。种子生长 2 整天，并在第 8 天开花。 第 6、7 天，播种第 3 枚种子。种子生长 1 整天，并在第 9 天开花。 因此，在第 9 天，所有种子都开花。 示例 3： 输入：plantTime = [1], growTime = [1] 输出：2 解释：第 0 天，播种第 0 枚种子。种子需要生长 1 整天，然后在第 2 天开花。 因此，在第 2 天，所有种子都开花。 提示： n == plantTime.length == growTime.length 1 &lt;= n &lt;= 10^5 1 &lt;= plantTime[i], growTime[i] &lt;= 10^4 分析：可以使用贪心来做 因为不管怎么换顺序需要的播种时间永远相同，所以先种生长时间长的花即可 代码：bool bj(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ return a[1] &gt; b[1]; } class Solution { public: int earliestFullBloom(vector&lt;int&gt;&amp; plantTime, vector&lt;int&gt;&amp; growTime) { vector&lt;vector&lt;int&gt;&gt; v(plantTime.size(), vector&lt;int&gt;(2, 0)); for(int i = 0; i &lt; plantTime.size(); i++){ v[i][0] = plantTime[i]; v[i][1] = growTime[i]; } sort(v.begin(), v.end(), bj); int ret = 0; int zhongzhishijian = 0; for(int i = 0; i &lt; v.size(); i++){ zhongzhishijian += v[i][0]; ret = max(ret, zhongzhishijian + v[i][1]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/earliest-possible-day-of-full-bloom/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2135. 统计追加字母可以获得的单词数]]></title>
    <url>%2F2022%2F01%2F10%2Fleetcode%202135.%20%E7%BB%9F%E8%AE%A1%E8%BF%BD%E5%8A%A0%E5%AD%97%E6%AF%8D%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你两个下标从 0 开始的字符串数组 startWords 和 targetWords 。每个字符串都仅由 小写英文字母 组成。 对于 targetWords 中的每个字符串，检查是否能够从 startWords 中选出一个字符串，执行一次 转换操作 ，得到的结果与当前 targetWords 字符串相等。 转换操作 如下面两步所述： 追加 任何 不存在 于当前字符串的任一小写字母到当前字符串的末尾。例如，如果字符串为 “abc” ，那么字母 ‘d’、’e’ 或 ‘y’ 都可以加到该字符串末尾，但 ‘a’ 就不行。如果追加的是 ‘d’ ，那么结果字符串为 “abcd” 。重排 新字符串中的字母，可以按 任意 顺序重新排布字母。例如，”abcd” 可以重排为 “acbd”、”bacd”、”cbda”，以此类推。注意，它也可以重排为 “abcd” 自身。找出 targetWords 中有多少字符串能够由 startWords 中的 任一 字符串执行上述转换操作获得。返回 targetWords 中这类 字符串的数目 。 注意：你仅能验证 targetWords 中的字符串是否可以由 startWords 中的某个字符串经执行操作获得。startWords 中的字符串在这一过程中 不 发生实际变更。 示例：示例 1： 输入：startWords = [&quot;ant&quot;,&quot;act&quot;,&quot;tack&quot;], targetWords = [&quot;tack&quot;,&quot;act&quot;,&quot;acti&quot;] 输出：2 解释： - 为了形成 targetWords[0] = &quot;tack&quot; ，可以选用 startWords[1] = &quot;act&quot; ，追加字母 &apos;k&apos; ，并重排 &quot;actk&quot; 为 &quot;tack&quot; 。 - startWords 中不存在可以用于获得 targetWords[1] = &quot;act&quot; 的字符串。 注意 &quot;act&quot; 确实存在于 startWords ，但是 必须 在重排前给这个字符串追加一个字母。 - 为了形成 targetWords[2] = &quot;acti&quot; ，可以选用 startWords[1] = &quot;act&quot; ，追加字母 &apos;i&apos; ，并重排 &quot;acti&quot; 为 &quot;acti&quot; 自身。 示例 2： 输入：startWords = [&quot;ab&quot;,&quot;a&quot;], targetWords = [&quot;abc&quot;,&quot;abcd&quot;] 输出：1 解释： - 为了形成 targetWords[0] = &quot;abc&quot; ，可以选用 startWords[0] = &quot;ab&quot; ，追加字母 &apos;c&apos; ，并重排为 &quot;abc&quot; 。 - startWords 中不存在可以用于获得 targetWords[1] = &quot;abcd&quot; 的字符串。 提示： 1 &lt;= startWords.length, targetWords.length &lt;= 5 * 104 1 &lt;= startWords[i].length, targetWords[j].length &lt;= 26 startWords 和 targetWords 中的每个字符串都仅由小写英文字母组成 在 startWords 或 targetWords 的任一字符串中，每个字母至多出现一次 分析：根据题目要求，可以判断出如果符合条件，那么targetWords[i]中的字符串去除一个字母后需要和startWords中的某一个字符串字母相同。 我们可以将startWords和targetWords中的每个字符串使用sort排序。 将startWords中的字符串以map的方式保存 遍历targetWords，尝试将targetWords[i]中的各个字符去除后看看startWords中是否有相同的字符串。若有，返回值加1 代码：class Solution { public: int wordCount(vector&lt;string&gt;&amp; startWords, vector&lt;string&gt;&amp; targetWords) { map&lt;string, int&gt; m1; int ret = 0; vector&lt;string&gt; v = startWords; for(int i = 0; i &lt; v.size(); i++){ sort(v[i].begin(), v[i].end()); m1[v[i]]++; } for(int i = 0; i &lt; targetWords.size(); i++){ for(int j = 0; j &lt; targetWords[i].size(); j++){ string str = &quot;&quot;; str += targetWords[i].substr(0, j); str += targetWords[i].substr(j+1, targetWords[i].size()); sort(str.begin(), str.end()); if(m1.count(str)){ ret++; break; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-words-obtained-after-adding-a-letter/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2134. 最少交换次数来组合所有的 1 II]]></title>
    <url>%2F2022%2F01%2F10%2Fleetcode%202134.%20%E6%9C%80%E5%B0%91%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0%E6%9D%A5%E7%BB%84%E5%90%88%E6%89%80%E6%9C%89%E7%9A%84%201%20II%2F</url>
    <content type="text"><![CDATA[题目：交换 定义为选中一个数组中的两个 互不相同 的位置并交换二者的值。 环形 数组是一个数组，可以认为 第一个 元素和 最后一个 元素 相邻 。 给你一个 二进制环形 数组 nums ，返回在 任意位置 将数组中的所有 1 聚集在一起需要的最少交换次数。 示例：示例 1： 输入：nums = [0,1,0,1,1,0,0] 输出：1 解释：这里列出一些能够将所有 1 聚集在一起的方案： [0,0,1,1,1,0,0] 交换 1 次。 [0,1,1,1,0,0,0] 交换 1 次。 [1,1,0,0,0,0,1] 交换 2 次（利用数组的环形特性）。 无法在交换 0 次的情况下将数组中的所有 1 聚集在一起。 因此，需要的最少交换次数为 1 。 示例 2： 输入：nums = [0,1,1,1,0,0,1,1,0] 输出：2 解释：这里列出一些能够将所有 1 聚集在一起的方案： [1,1,1,0,0,0,0,1,1] 交换 2 次（利用数组的环形特性）。 [1,1,1,1,1,0,0,0,0] 交换 2 次。 无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。 因此，需要的最少交换次数为 2 。 示例 3： 输入：nums = [1,1,0,0,1] 输出：0 解释：得益于数组的环形特性，所有的 1 已经聚集在一起。 因此，需要的最少交换次数为 0 。 提示： 1 &lt;= nums.length &lt;= 10^5 nums[i] 为 0 或者 1 分析：先计算数组总所有的1的数量 将一个长度为1的数量的窗口在数组上滑动（需要注意这是一个循环数组）。计算让每一个窗口被1填满需要1的数量，得出其中最多的返回 代码：class Solution { public: int minSwaps(vector&lt;int&gt;&amp; nums) { int ret; int n = 0; int qujian = 0; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] == 1) n++; } for(int i = 0; i &lt; n; i++){ if(nums[i] == 1) qujian++; } ret = n - qujian; for(int i = 1; i &lt; nums.size(); i++){ qujian = qujian - nums[i-1] + nums[(i+n-1)%nums.size()]; ret = min(ret, n-qujian); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2133. 检查是否每一行每一列都包含全部整数]]></title>
    <url>%2F2022%2F01%2F10%2Fleetcode%202133.%20%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%AF%8F%E4%B8%80%E8%A1%8C%E6%AF%8F%E4%B8%80%E5%88%97%E9%83%BD%E5%8C%85%E5%90%AB%E5%85%A8%E9%83%A8%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：对一个大小为 n x n 的矩阵而言，如果其每一行和每一列都包含从 1 到 n 的 全部 整数（含 1 和 n），则认为该矩阵是一个 有效 矩阵。 给你一个大小为 n x n 的整数矩阵 matrix ，请你判断矩阵是否为一个有效矩阵：如果是，返回 true ；否则，返回 false 。 示例：示例 1： 输入：matrix = [[1,2,3],[3,1,2],[2,3,1]] 输出：true 解释：在此例中，n = 3 ，每一行和每一列都包含数字 1、2、3 。 因此，返回 true 。 示例 2： 输入：matrix = [[1,1,1],[1,2,3],[1,2,3]] 输出：false 解释：在此例中，n = 3 ，但第一行和第一列不包含数字 2 和 3 。 因此，返回 false 。 提示： n == matrix.length == matrix[i].length 1 &lt;= n &lt;= 100 1 &lt;= matrix[i][j] &lt;= n 分析：按行，按列各遍历一遍，使用map判断是否出现重复整数 代码：class Solution { public: bool checkValid(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int n = matrix.size(); for(int i = 0; i &lt; n; i++){ map&lt;int, int&gt; m; for(int j = 0; j &lt; n; j++){ m[matrix[i][j]] = 1; } if(m.size() &lt; n) return false; } for(int i = 0; i &lt; n; i++){ map&lt;int, int&gt; m; for(int j = 0; j &lt; n; j++){ m[matrix[j][i]] = 1; } if(m.size() &lt; n) return false; } return true; } }; 题目地址:https://leetcode-cn.com/problems/check-if-every-row-and-column-contains-all-numbers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2127. 参加会议的最多员工数]]></title>
    <url>%2F2022%2F01%2F04%2Fleetcode%202127.%20%E5%8F%82%E5%8A%A0%E4%BC%9A%E8%AE%AE%E7%9A%84%E6%9C%80%E5%A4%9A%E5%91%98%E5%B7%A5%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：一个公司准备组织一场会议，邀请名单上有 n 位员工。公司准备了一张 圆形 的桌子，可以坐下 任意数目 的员工。 员工编号为 0 到 n - 1 。每位员工都有一位 喜欢 的员工，每位员工 当且仅当 他被安排在喜欢员工的旁边，他才会参加会议。每位员工喜欢的员工 不会 是他自己。 给你一个下标从 0 开始的整数数组 favorite ，其中 favorite[i] 表示第 i 位员工喜欢的员工。请你返回参加会议的 最多员工数目 。 示例：示例 1： 输入：favorite = [2,2,1,2] 输出：3 解释： 上图展示了公司邀请员工 0，1 和 2 参加会议以及他们在圆桌上的座位。 没办法邀请所有员工参与会议，因为员工 2 没办法同时坐在 0，1 和 3 员工的旁边。 注意，公司也可以邀请员工 1，2 和 3 参加会议。 所以最多参加会议的员工数目为 3 。 示例 2： 输入：favorite = [1,2,0] 输出：3 解释： 每个员工都至少是另一个员工喜欢的员工。所以公司邀请他们所有人参加会议的前提是所有人都参加了会议。 座位安排同图 1 所示： - 员工 0 坐在员工 2 和 1 之间。 - 员工 1 坐在员工 0 和 2 之间。 - 员工 2 坐在员工 1 和 0 之间。 参与会议的最多员工数目为 3 。 示例 3： 输入：favorite = [3,0,1,4,1] 输出：4 解释： 上图展示了公司可以邀请员工 0，1，3 和 4 参加会议以及他们在圆桌上的座位。 员工 2 无法参加，因为他喜欢的员工 0 旁边的座位已经被占领了。 所以公司只能不邀请员工 2 。 参加会议的最多员工数目为 4 。 提示： n == favorite.length 2 &lt;= n &lt;= 105 0 &lt;= favorite[i] &lt;= n - 1 favorite[i] != i 分析：这题可以想象成一个圆，在圆上的一些结点是树的根（这样的结构不止一个） 要让每个员工边上都有一个喜欢的人，有两种可能： 两个员工互相喜欢，这样可以由两个员工和喜欢这两个员工的人组成一桌（只能选择树中的一条路径） 喜欢的员工刚刚组成一个圆，计算圆中的人数 如果是第一种可能，要将所有这种可能的人数相加，而第二种，要选择最大的那个圆 参考：https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/solution/fen-xi-tu-de-jie-gou-zai-jin-xing-fen-le-690o/ 代码：class Solution { int ret_max; vector&lt;vector&lt;int&gt;&gt; zsz; vector&lt;int&gt; m; int huan_2; public: int count(int z, int paichu){ m[z] = 1; int ma = 0; for(int i = 0; i &lt; zsz[z].size(); i++){ if(zsz[z][i] == paichu) continue; m[zsz[z][i]] = 1; ma = max(ma, count(zsz[z][i], z)); } return ma+1; } void dfs(vector&lt;int&gt;&amp; favorite, int z, unordered_map&lt;int, int&gt;&amp; l){ if(m[z] == 1) return; m[z] = 1; if(l[favorite[z]] == 0){ l[favorite[z]] = l[z]+1; dfs(favorite, favorite[z], l); } else{ if(l[z] - l[favorite[z]] == 1){ ret_max = max(ret_max, huan_2 += count(z, favorite[z]) + count(favorite[z], z)); } else{ ret_max = max(ret_max, l[z] - l[favorite[z]] + 1); } } } int maximumInvitations(vector&lt;int&gt;&amp; favorite) { huan_2 = 0; ret_max = 0; int n = favorite.size(); m = vector&lt;int&gt;(n, 0); zsz = vector&lt;vector&lt;int&gt;&gt;(n); for(int i = 0; i &lt; n; i++){ zsz[favorite[i]].push_back(i); } for(int i = 0; i &lt; n; i++){ unordered_map&lt;int, int&gt; l; l[i] = 1; dfs(favorite, i, l); } return ret_max; } }; 题目地址:https://leetcode-cn.com/problems/maximum-employees-to-be-invited-to-a-meeting/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2126. 摧毁小行星]]></title>
    <url>%2F2022%2F01%2F04%2Fleetcode%202126.%20%E6%91%A7%E6%AF%81%E5%B0%8F%E8%A1%8C%E6%98%9F%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 mass ，它表示一颗行星的初始质量。再给你一个整数数组 asteroids ，其中 asteroids[i] 是第 i 颗小行星的质量。 你可以按 任意顺序 重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量 大于等于 小行星的质量，那么小行星被 摧毁 ，并且行星会 获得 这颗小行星的质量。否则，行星将被摧毁。 如果所有小行星 都 能被摧毁，请返回 true ，否则返回 false 。 示例：示例 1： 输入：mass = 10, asteroids = [3,9,19,5,21] 输出：true 解释：一种安排小行星的方式为 [9,19,5,3,21] ： - 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 = 19 - 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 = 38 - 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 = 43 - 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 = 46 - 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 = 67 所有小行星都被摧毁。 示例 2： 输入：mass = 5, asteroids = [4,9,23,4] 输出：false 解释： 行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。 行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 = 22 。 它比 23 小，所以无法摧毁最后一颗小行星。 提示： 1 &lt;= mass &lt;= 10^5 1 &lt;= asteroids.length &lt;= 10^5 1 &lt;= asteroids[i] &lt;= 10^5 分析：将小行星从小到大排列，用行星按序碰撞即可 代码：class Solution { public: bool asteroidsDestroyed(int mass, vector&lt;int&gt;&amp; asteroids) { sort(asteroids.begin(), asteroids.end()); long long a = mass; for(int i = 0; i &lt; asteroids.size(); i++){ if(asteroids[i] &lt;= a){ a += asteroids[i]; } else{ return false; } } return true; } }; 题目地址:https://leetcode-cn.com/problems/destroying-asteroids/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2125. 银行中的激光束数量]]></title>
    <url>%2F2022%2F01%2F04%2Fleetcode%202125.%20%E9%93%B6%E8%A1%8C%E4%B8%AD%E7%9A%84%E6%BF%80%E5%85%89%E6%9D%9F%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：银行内部的防盗安全装置已经激活。给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n 的二维矩阵。 bank[i] 表示第 i 行的设备分布，由若干 ‘0’ 和若干 ‘1’ 组成。’0’ 表示单元格是空的，而 ‘1’ 表示单元格有一个安全设备。 对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束： 两个设备位于两个 不同行 ：r1 和 r2 ，其中 r1 &lt; r2 。 满足 r1 &lt; i &lt; r2 的 所有 行 i ，都 没有安全设备 。 激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。 返回银行中激光束的总数量。 示例：示例 1： 输入：bank = [&quot;011001&quot;,&quot;000000&quot;,&quot;010100&quot;,&quot;001000&quot;] 输出：8 解释：在下面每组设备对之间，存在一条激光束。总共是 8 条激光束： * bank[0][1] -- bank[2][1] * bank[0][1] -- bank[2][3] * bank[0][2] -- bank[2][1] * bank[0][2] -- bank[2][3] * bank[0][5] -- bank[2][1] * bank[0][5] -- bank[2][3] * bank[2][1] -- bank[3][2] * bank[2][3] -- bank[3][2] 注意，第 0 行和第 3 行上的设备之间不存在激光束。 这是因为第 2 行存在安全设备，这不满足第 2 个条件。 示例 2： 输入：bank = [&quot;000&quot;,&quot;111&quot;,&quot;000&quot;] 输出：0 解释：不存在两个位于不同行的设备 提示： m == bank.length n == bank[i].length 1 &lt;= m, n &lt;= 500 bank[i][j] 为 ‘0’ 或 ‘1’ 分析：记录每行的设备数量，空行忽略 相邻两行相乘，结果相加 代码：class Solution { public: int numberOfBeams(vector&lt;string&gt;&amp; bank) { vector&lt;int&gt; v; for(int i = 0; i &lt; bank.size(); i++){ int n = 0; for(int j = 0; j &lt; bank[i].size(); j++){ if(bank[i][j] == &apos;1&apos;) n++; } if(n != 0) v.push_back(n); } int ret = 0; for(int i = 1; i &lt; v.size(); i++){ ret += v[i]*v[i-1]; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2124. 检查是否所有 A 都在 B 之前]]></title>
    <url>%2F2022%2F01%2F04%2Fleetcode%202124.%20%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%89%80%E6%9C%89%20A%20%E9%83%BD%E5%9C%A8%20B%20%E4%B9%8B%E5%89%8D%2F</url>
    <content type="text"><![CDATA[题目：给你一个 仅 由字符 ‘a’ 和 ‘b’ 组成的字符串 s 。如果字符串中 每个 ‘a’ 都出现在 每个 ‘b’ 之前，返回 true ；否则，返回 false 。 示例：示例 1： 输入：s = &quot;aaabbb&quot; 输出：true 解释： &apos;a&apos; 位于下标 0、1 和 2 ；而 &apos;b&apos; 位于下标 3、4 和 5 。 因此，每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 true 。 示例 2： 输入：s = &quot;abab&quot; 输出：false 解释： 存在一个 &apos;a&apos; 位于下标 2 ，而一个 &apos;b&apos; 位于下标 1 。 因此，不能满足每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 false 。 示例 3： 输入：s = &quot;bbb&quot; 输出：true 解释： 不存在 &apos;a&apos; ，因此可以视作每个 &apos;a&apos; 都出现在每个 &apos;b&apos; 之前，所以返回 true 。 提示： 1 &lt;= s.length &lt;= 100 s[i] 为 ‘a’ 或 ‘b’ 分析：使用一个bool记录是否出现过b，如果出现过b之后再出现a，返回false 代码：class Solution { public: bool checkString(string s) { bool b = true; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == &apos;a&apos;){ if(!b){ return false; } } else{ b = false; } } return true; } }; 题目地址:https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5966. 还原原数组]]></title>
    <url>%2F2021%2F12%2F27%2Fleetcode%205966.%20%E8%BF%98%E5%8E%9F%E5%8E%9F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：Alice 有一个下标从 0 开始的数组 arr ，由 n 个正整数组成。她会选择一个任意的 正整数 k 并按下述方式创建两个下标从 0 开始的新整数数组 lower 和 higher ： 对每个满足 0 &lt;= i &lt; n 的下标 i ，lower[i] = arr[i] - k 对每个满足 0 &lt;= i &lt; n 的下标 i ，higher[i] = arr[i] + k 不幸地是，Alice 丢失了全部三个数组。但是，她记住了在数组 lower 和 higher 中出现的整数，但不知道每个整数属于哪个数组。请你帮助 Alice 还原原数组。 给你一个由 2n 个整数组成的整数数组 nums ，其中 恰好 n 个整数出现在 lower ，剩下的出现在 higher ，还原并返回 原数组 arr 。如果出现答案不唯一的情况，返回 任一 有效数组。 注意：生成的测试用例保证存在 至少一个 有效数组 arr 。 示例：示例 1： 输入：nums = [2,10,6,4,8,12] 输出：[3,7,11] 解释： 如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。 组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。 另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。 示例 2： 输入：nums = [1,1,3,3] 输出：[2,2] 解释： 如果 arr = [2,2] 且 k = 1 ，那么 lower = [1,1] 且 higher = [3,3] 。 组合 lower 和 higher 得到 [1,1,3,3] ，这是 nums 的一个排列。 注意，数组不能是 [1,3] ，因为在这种情况下，获得 [1,1,3,3] 唯一可行的方案是 k = 0 。 这种方案是无效的，k 必须是一个正整数。 示例 3： 输入：nums = [5,435] 输出：[220] 解释： 唯一可行的组合是 arr = [220] 且 k = 215 。在这种情况下，lower = [5] 且 higher = [435] 。 提示： 2 * n == nums.length 1 &lt;= n &lt;= 1000 1 &lt;= nums[i] &lt;= 10^9 生成的测试用例保证存在 至少一个 有效数组 arr 分析：排序arr，可以得到最小的数。遍历arr，和最小的数相减，可以得到k*2。再度遍历一遍，判断k是否合理（这一步可以用双指针优化，时间复杂度不变，空间复杂度缩小） 代码：class Solution { public: vector&lt;int&gt; recoverArray(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); for(int i = 1; i &lt; nums.size() / 2+1; i++){ int c = nums[i] - nums[0]; if(c == 0 || c % 2 == 1) continue; unordered_map&lt;int, int&gt; m; int n = 0; for(int j = 0; j &lt; nums.size(); j++){ if(m[nums[j]] &gt; 0){ m[nums[j]]--; n--; } else{ m[nums[j] + c]++; n++; } } if(n == 0){ vector&lt;int&gt; ret; for(int j = 0; j &lt; nums.size(); j++){ if(m[nums[j]] &gt; 0){ m[nums[j]]--; } else{ m[nums[j] + c]++; ret.push_back(nums[j]+c/2); } } return ret; } } return {}; } }; 题目地址:https://leetcode-cn.com/problems/recover-the-original-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5965. 相同元素的间隔之和]]></title>
    <url>%2F2021%2F12%2F27%2Fleetcode%205965.%20%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E7%9A%84%E9%97%B4%E9%9A%94%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始、由 n 个整数组成的数组 arr 。 arr 中两个元素的 间隔 定义为它们下标之间的 绝对差 。更正式地，arr[i] 和 arr[j] 之间的间隔是 |i - j| 。 返回一个长度为 n 的数组 intervals ，其中 intervals[i] 是 arr[i] 和 arr 中每个相同元素（与 arr[i] 的值相同）的 间隔之和 。 注意：|x| 是 x 的绝对值。 示例：示例 1： 输入：arr = [2,1,3,1,2,3,3] 输出：[4,2,7,2,4,4,5] 解释： - 下标 0 ：另一个 2 在下标 4 ，|0 - 4| = 4 - 下标 1 ：另一个 1 在下标 3 ，|1 - 3| = 2 - 下标 2 ：另两个 3 在下标 5 和 6 ，|2 - 5| + |2 - 6| = 7 - 下标 3 ：另一个 1 在下标 1 ，|3 - 1| = 2 - 下标 4 ：另一个 2 在下标 0 ，|4 - 0| = 4 - 下标 5 ：另两个 3 在下标 2 和 6 ，|5 - 2| + |5 - 6| = 4 - 下标 6 ：另两个 3 在下标 2 和 5 ，|6 - 2| + |6 - 5| = 5 示例 2： 输入：arr = [10,5,10,10] 输出：[5,0,3,4] 解释： - 下标 0 ：另两个 10 在下标 2 和 3 ，|0 - 2| + |0 - 3| = 5 - 下标 1 ：只有这一个 5 在数组中，所以到相同元素的间隔之和是 0 - 下标 2 ：另两个 10 在下标 0 和 3 ，|2 - 0| + |2 - 3| = 3 - 下标 3 ：另两个 10 在下标 0 和 2 ，|3 - 0| + |3 - 2| = 4 提示： n == arr.length 1 &lt;= n &lt;= 10^5 1 &lt;= arr[i] &lt;= 10^5 分析：当前下标为i，以i为中心的间隔之和分为两块： i * 左侧arr[i]的数量 - 左侧各个arr[i]的下标之和 右侧各个arr[i]的下标之和 - i * 右侧arr[i]的数量 下标之和可以用前缀和解决 代码：class Solution { public: vector&lt;long long&gt; getDistances(vector&lt;int&gt;&amp; arr) { map&lt;int, long long&gt; m; map&lt;int, int&gt; num; vector&lt;long long&gt; numl(arr.size(), 0); vector&lt;long long&gt; numr(arr.size(), 0); vector&lt;long long&gt; l(arr.size(), 0); vector&lt;long long&gt; r(arr.size(), 0); vector&lt;long long&gt; ret; for(int i = 0; i &lt; arr.size(); i++){ numl[i] = num[arr[i]]; num[arr[i]]++; l[i] = m[arr[i]]; m[arr[i]] += i; } m.clear(); num.clear(); for(int i = arr.size()-1; i &gt;= 0; i--){ numr[i] = num[arr[i]]; num[arr[i]]++; r[i] = m[arr[i]]; m[arr[i]] += i; } for(int i = 0; i &lt; arr.size(); i++){ ret.push_back(i * numl[i] - l[i] + r[i] - i * numr[i]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/intervals-between-identical-elements/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5964. 执行所有后缀指令]]></title>
    <url>%2F2021%2F12%2F27%2Fleetcode%205964.%20%E6%89%A7%E8%A1%8C%E6%89%80%E6%9C%89%E5%90%8E%E7%BC%80%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[题目：现有一个 n x n 大小的网格，左上角单元格坐标 (0, 0) ，右下角单元格坐标 (n - 1, n - 1) 。给你整数 n 和一个整数数组 startPos ，其中 startPos = [startrow, startcol] 表示机器人最开始在坐标为 (startrow, startcol) 的单元格上。 另给你一个长度为 m 、下标从 0 开始的字符串 s ，其中 s[i] 是对机器人的第 i 条指令：’L’（向左移动），’R’（向右移动），’U’（向上移动）和 ‘D’（向下移动）。 机器人可以从 s 中的任一第 i 条指令开始执行。它将会逐条执行指令直到 s 的末尾，但在满足下述条件之一时，机器人将会停止： 下一条指令将会导致机器人移动到网格外。 没有指令可以执行。 返回一个长度为 m 的数组 answer ，其中 answer[i] 是机器人从第 i 条指令 开始 ，可以执行的 指令数目 。 示例：示例 1： 输入：n = 3, startPos = [0,1], s = &quot;RRDDLU&quot; 输出：[1,5,4,3,1,0] 解释：机器人从 startPos 出发，并从第 i 条指令开始执行： - 0: &quot;RRDDLU&quot; 在移动到网格外之前，只能执行一条 &quot;R&quot; 指令。 - 1: &quot;RDDLU&quot; 可以执行全部五条指令，机器人仍在网格内，最终到达 (0, 0) 。 - 2: &quot;DDLU&quot; 可以执行全部四条指令，机器人仍在网格内，最终到达 (0, 0) 。 - 3: &quot;DLU&quot; 可以执行全部三条指令，机器人仍在网格内，最终到达 (0, 0) 。 - 4: &quot;LU&quot; 在移动到网格外之前，只能执行一条 &quot;L&quot; 指令。 - 5: &quot;U&quot; 如果向上移动，将会移动到网格外。 示例 2： 输入：n = 2, startPos = [1,1], s = &quot;LURD&quot; 输出：[4,1,0,0] 解释： - 0: &quot;LURD&quot; - 1: &quot;URD&quot; - 2: &quot;RD&quot; - 3: &quot;D&quot; 示例 3： 输入：n = 1, startPos = [0,0], s = &quot;LRUD&quot; 输出：[0,0,0,0] 解释：无论机器人从哪条指令开始执行，都会移动到网格外。 提示： m == s.length 1 &lt;= n, m &lt;= 500 startPos.length == 2 0 &lt;= startrow, startcol &lt; n s 由 ‘L’、’R’、’U’ 和 ‘D’ 组成 分析：直接模拟 代码：class Solution { map&lt;char, int&gt; m1; map&lt;char, int&gt; m2; public: int zl(int n, vector&lt;int&gt; startPos, string s, int z){ for(int i = z; i &lt; s.size(); i++){ if(startPos[0]+m1[s[i]] &lt; n &amp;&amp; startPos[0]+m1[s[i]] &gt;= 0 &amp;&amp; startPos[1]+m2[s[i]] &lt; n &amp;&amp; startPos[1]+m2[s[i]] &gt;= 0){ startPos[0] += m1[s[i]]; startPos[1] += m2[s[i]]; } else{ return i-z; } } return s.size()-z; } vector&lt;int&gt; executeInstructions(int n, vector&lt;int&gt;&amp; startPos, string s) { m1[&apos;L&apos;] = 0; m2[&apos;L&apos;] = -1; m1[&apos;R&apos;] = 0; m2[&apos;R&apos;] = 1; m1[&apos;U&apos;] = -1; m2[&apos;U&apos;] = 0; m1[&apos;D&apos;] = 1; m2[&apos;D&apos;] = 0; vector&lt;int&gt; ret; for(int i = 0; i &lt; s.size(); i++){ ret.push_back(zl(n, startPos, s, i)); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5963. 反转两次的数字]]></title>
    <url>%2F2021%2F12%2F27%2Fleetcode%205963.%20%E5%8F%8D%E8%BD%AC%E4%B8%A4%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目：反转 一个整数意味着倒置它的所有位。 例如，反转 2021 得到 1202 。反转 12300 得到 321 ，不保留前导零 。 给你一个整数 num ，反转 num 得到 reversed1 ，接着反转 reversed1 得到 reversed2 。如果 reversed2 等于 num ，返回 true ；否则，返回 false 。 示例：示例 1： 输入：num = 526 输出：true 解释：反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。 示例 2： 输入：num = 1800 输出：false 解释：反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。 示例 3： 输入：num = 0 输出：true 解释：反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。 提示： 0 &lt;= num &lt;= 10^6 分析：判断个位数是否为0，当数字为0时除外 代码：class Solution { public: bool isSameAfterReversals(int num) { if(num == 0) return true; if(num % 10 == 0){ return false; } else{ return true; } } }; 题目地址:https://leetcode-cn.com/problems/a-number-after-a-double-reversal/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5959. 使数组 K 递增的最少操作次数]]></title>
    <url>%2F2021%2F12%2F20%2Fleetcode%205959.%20%E4%BD%BF%E6%95%B0%E7%BB%84%20K%20%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始包含 n 个正整数的数组 arr ，和一个正整数 k 。 如果对于每个满足 k &lt;= i &lt;= n-1 的下标 i ，都有 arr[i-k] &lt;= arr[i] ，那么我们称 arr 是 K 递增 的。 比方说，arr = [4, 1, 5, 2, 6, 2] 对于 k = 2 是 K 递增的，因为： arr[0] &lt;= arr[2] (4 &lt;= 5) arr[1] &lt;= arr[3] (1 &lt;= 2) arr[2] &lt;= arr[4] (5 &lt;= 6) arr[3] &lt;= arr[5] (2 &lt;= 2) 但是，相同的数组 arr 对于 k = 1 不是 K 递增的（因为 arr[0] &gt; arr[1]），对于 k = 3 也不是 K 递增的（因为 arr[0] &gt; arr[3] ）。 每一次 操作 中，你可以选择一个下标 i 并将 arr[i] 改成任意 正整数。 请你返回对于给定的 k ，使数组变成 K 递增的 最少操作次数 。 示例：示例 1： 输入：arr = [5,4,3,2,1], k = 1 输出：4 解释： 对于 k = 1 ，数组最终必须变成非递减的。 可行的 K 递增结果数组为 [5,6,7,8,9]，[1,1,1,1,1]，[2,2,3,4,4] 。它们都需要 4 次操作。 次优解是将数组变成比方说 [6,7,8,9,10] ，因为需要 5 次操作。 显然我们无法使用少于 4 次操作将数组变成 K 递增的。 示例 2： 输入：arr = [4,1,5,2,6,2], k = 2 输出：0 解释： 这是题目描述中的例子。 对于每个满足 2 &lt;= i &lt;= 5 的下标 i ，有 arr[i-2] &lt;= arr[i] 。 由于给定数组已经是 K 递增的，我们不需要进行任何操作。 示例 3： 输入：arr = [4,1,5,2,6,2], k = 3 输出：2 解释： 下标 3 和 5 是仅有的 3 &lt;= i &lt;= 5 且不满足 arr[i-3] &lt;= arr[i] 的下标。 将数组变成 K 递增的方法之一是将 arr[3] 变为 4 ，且将 arr[5] 变成 5 。 数组变为 [4,1,5,4,6,5] 。 可能有其他方法将数组变为 K 递增的，但没有任何一种方法需要的操作次数小于 2 次。 提示： 1 &lt;= arr.length &lt;= 10^5 1 &lt;= arr[i], k &lt;= arr.length 分析：将数组按间隔k分成k份，题目就变成了将k个数组变成非递减的最少操作次数 求递增数组可以用参考这种方法：https://blog.csdn.net/weixin_50547586/article/details/112062713 代码：class Solution { public: int cz(vector&lt;int&gt;&amp; v, int z){ int l = 0; int r = v.size()-1; if(z &gt;= v[v.size()-1]) return v.size(); while(l &lt; r){ int m = (l+r)/2; if(v[m] &lt;= z){ l = m+1; } else{ r = m; } } return r; } int kIncreasing(vector&lt;int&gt;&amp; arr, int k) { int ret = 0; for(int i = 0; i &lt; k; i++){ vector&lt;int&gt; s; int n = 0; for(int j = i; j &lt; arr.size(); j += k){ if(j &lt; k){ s.push_back(arr[j]); } else{ int z = cz(s, arr[j]); if(z == s.size()){ s.push_back(arr[j]); } else{ n++; s[z] = arr[j]; } } } ret += n; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5958. 股票平滑下跌阶段的数目]]></title>
    <url>%2F2021%2F12%2F20%2Fleetcode%205958.%20%E8%82%A1%E7%A5%A8%E5%B9%B3%E6%BB%91%E4%B8%8B%E8%B7%8C%E9%98%B6%E6%AE%B5%E7%9A%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 prices ，表示一支股票的历史每日股价，其中 prices[i] 是这支股票第 i 天的价格。 一个 平滑下降的阶段 定义为：对于 连续一天或者多天 ，每日股价都比 前一日股价恰好少 1 ，这个阶段第一天的股价没有限制。 请你返回 平滑下降阶段 的数目。 示例：示例 1： 输入：prices = [3,2,1,4] 输出：7 解释：总共有 7 个平滑下降阶段： [3], [2], [1], [4], [3,2], [2,1] 和 [3,2,1] 注意，仅一天按照定义也是平滑下降阶段。 示例 2： 输入：prices = [8,6,7,7] 输出：4 解释：总共有 4 个连续平滑下降阶段：[8], [6], [7] 和 [7] 由于 8 - 6 ≠ 1 ，所以 [8,6] 不是平滑下降阶段。 示例 3： 输入：prices = [1] 输出：1 解释：总共有 1 个平滑下降阶段：[1] 提示： 1 &lt;= prices.length &lt;= 10^5 1 &lt;= prices[i] &lt;= 10^5 分析：遍历数组prices，记录连续的平滑下降的天数（并且将每天的数据加入返回值），当结束平滑下降时重置为1 代码：class Solution { public: long long getDescentPeriods(vector&lt;int&gt;&amp; prices) { int d = 1; long long ret = 1; for(int i = 1; i &lt; prices.size(); i++){ if(prices[i] == prices[i-1]-1){ d++; ret += d; } else{ d = 1; ret += d; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-smooth-descent-periods-of-a-stock/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5957. 向字符串添加空格]]></title>
    <url>%2F2021%2F12%2F20%2Fleetcode%205957.%20%E5%90%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的字符串 s ，以及一个下标从 0 开始的整数数组 spaces 。 数组 spaces 描述原字符串中需要添加空格的下标。每个空格都应该插入到给定索引处的字符值 之前 。 例如，s = “EnjoyYourCoffee” 且 spaces = [5, 9] ，那么我们需要在 ‘Y’ 和 ‘C’ 之前添加空格，这两个字符分别位于下标 5 和下标 9 。因此，最终得到 “Enjoy Your Coffee” 。 请你添加空格，并返回修改后的字符串。 示例：示例 1： 输入：s = &quot;LeetcodeHelpsMeLearn&quot;, spaces = [8,13,15] 输出：&quot;Leetcode Helps Me Learn&quot; 解释： 下标 8、13 和 15 对应 &quot;LeetcodeHelpsMeLearn&quot; 中加粗斜体字符。 接着在这些字符前添加空格。 示例 2： 输入：s = &quot;icodeinpython&quot;, spaces = [1,5,7,9] 输出：&quot;i code in py thon&quot; 解释： 下标 1、5、7 和 9 对应 &quot;icodeinpython&quot; 中加粗斜体字符。 接着在这些字符前添加空格。 示例 3： 输入：s = &quot;spacing&quot;, spaces = [0,1,2,3,4,5,6] 输出：&quot; s p a c i n g&quot; 解释： 字符串的第一个字符前可以添加空格。 提示： 1 &lt;= s.length &lt;= 3 * 10^5 s 仅由大小写英文字母组成 1 &lt;= spaces.length &lt;= 3 * 10^5 0 &lt;= spaces[i] &lt;= s.length - 1 spaces 中的所有值 严格递增 分析：使用两个指针，一个用来遍历字符串，一个用来遍历空格坐标数组 当字符串遍历到需要添加空格的时候，先添加空格再添加字符，同时空格坐标数组指针后移 代码：class Solution { public: string addSpaces(string s, vector&lt;int&gt;&amp; spaces) { string ret = &quot;&quot;; for(int i = 0, j = 0; i &lt; s.size(); i++){ if(j &lt; spaces.size() &amp;&amp; spaces[j] == i){ ret += &apos; &apos;; j++; } ret += s[i]; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/adding-spaces-to-a-string/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5956. 找出数组中的第一个回文字符串]]></title>
    <url>%2F2021%2F12%2F20%2Fleetcode%205956.%20%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串数组 words ，找出并返回数组中的 第一个回文字符串 。如果不存在满足要求的字符串，返回一个 空字符串 “” 。 回文字符串 的定义为：如果一个字符串正着读和反着读一样，那么该字符串就是一个 回文字符串 。 示例：示例 1： 输入：words = [&quot;abc&quot;,&quot;car&quot;,&quot;ada&quot;,&quot;racecar&quot;,&quot;cool&quot;] 输出：&quot;ada&quot; 解释：第一个回文字符串是 &quot;ada&quot; 。 注意，&quot;racecar&quot; 也是回文字符串，但它不是第一个。 示例 2： 输入：words = [&quot;notapalindrome&quot;,&quot;racecar&quot;] 输出：&quot;racecar&quot; 解释：第一个也是唯一一个回文字符串是 &quot;racecar&quot; 。 示例 3： 输入：words = [&quot;def&quot;,&quot;ghi&quot;] 输出：&quot;&quot; 解释：不存在回文字符串，所以返回一个空字符串。 提示： 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 100 words[i] 仅由小写英文字母组成 分析：双指针，遍历 代码：class Solution { public: string firstPalindrome(vector&lt;string&gt;&amp; words) { for(int i = 0; i &lt; words.size(); i++){ bool b = true; for(int j = 0; j &lt; words[i].size()/2; j++){ if(words[i][j] != words[i][words[i].size()-1-j]){ b = false; break; } } if(b){ return words[i]; } } return &quot;&quot;; } }; 题目地址:https://leetcode-cn.com/problems/find-first-palindromic-string-in-the-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5955. 摘水果]]></title>
    <url>%2F2021%2F12%2F13%2Fleetcode%205955.%20%E6%91%98%E6%B0%B4%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[题目：在一个无限的 x 坐标轴上，有许多水果分布在其中某些位置。给你一个二维整数数组 fruits ，其中 fruits[i] = [positioni, amounti] 表示共有 amounti 个水果放置在 positioni 上。fruits 已经按 positioni 升序排列 ，每个 positioni 互不相同 。 另给你两个整数 startPos 和 k 。最初，你位于 startPos 。从任何位置，你可以选择 向左或者向右 走。在 x 轴上每移动 一个单位 ，就记作 一步 。你总共可以走 最多 k 步。你每达到一个位置，都会摘掉全部的水果，水果也将从该位置消失（不会再生）。 返回你可以摘到水果的 最大总数 。 示例：示例 1： 输入：fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4 输出：9 解释： 最佳路线为： - 向右移动到位置 6 ，摘到 3 个水果 - 向右移动到位置 8 ，摘到 6 个水果 移动 3 步，共摘到 3 + 6 = 9 个水果 示例 2： 输入：fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4 输出：14 解释： 可以移动最多 k = 4 步，所以无法到达位置 0 和位置 10 。 最佳路线为： - 在初始位置 5 ，摘到 7 个水果 - 向左移动到位置 4 ，摘到 1 个水果 - 向右移动到位置 6 ，摘到 2 个水果 - 向右移动到位置 7 ，摘到 4 个水果 移动 1 + 3 = 4 步，共摘到 7 + 1 + 2 + 4 = 14 个水果 示例 3： 输入：fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2 输出：0 解释： 最多可以移动 k = 2 步，无法到达任一有水果的地方 提示： 1 &lt;= fruits.length &lt;= 10^5 fruits[i].length == 2 0 &lt;= startPos, positioni &lt;= 2 * 10^5 对于任意 i &gt; 0 ，positioni-1 &lt; positioni 均成立（下标从 0 开始计数） 1 &lt;= amounti &lt;= 10^4 0 &lt;= k &lt;= 2 * 10^5 分析：有四种可能： 只往左走 先往左再往右 只往右走 先往右再往左 只往左和只往右简单 先往左再往右可以通过往左走到最大距离，再往右。这时往左减少一步就可以多往右两步，直到成为只往右走的状态 先往右再往左同理 代码：class Solution { public: int maxTotalFruits(vector&lt;vector&lt;int&gt;&gt;&amp; fruits, int startPos, int k) { int ret = 0; vector&lt;int&gt; v(400005, 0); for(int i = 0; i &lt; fruits.size(); i++){ v[fruits[i][0]] = fruits[i][1]; } int l = startPos - k; int r = l; int sg = 0; // 只往左 if(l &lt; 0){ for(int i = 0; i &lt;= startPos; i++){ sg += v[i]; } } else{ for(int i = l; i &lt;= startPos; i++){ sg += v[i]; } } ret = sg; if(l &gt;= 0){ sg -= v[l]; } // 先往左再往右 for(l++, r+=2; l &lt;= startPos &amp;&amp; r &lt; int(v.size()); l++, r+=2){ if(r &gt; startPos){ if(r == startPos+1) sg += v[r]; else sg += v[r] + v[r-1]; } ret = max(ret, sg); if(l &gt;= 0){ sg -= v[l]; } } l = startPos + k; r = startPos + k; sg = 0; // 只往右 for(int i = startPos; i &lt;= r; i++){ sg += v[i]; } ret = max(sg, ret); sg -= v[r]; // 先往右再往左 for(l-=2, r--; l &gt;= 0 &amp;&amp; r &gt;= startPos; l-=2, r--){ if(l &lt; startPos){ if(l == startPos-1){ sg += v[l]; } else sg += v[l] + v[l+1]; } ret = max(ret, sg); sg -= v[r]; } if(l == -1 &amp;&amp; r &gt;= startPos){ l = 0; if(l &lt; startPos){ sg += v[l]; } ret = max(ret, sg); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-fruits-harvested-after-at-most-k-steps/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 2105. 给植物浇水 II]]></title>
    <url>%2F2021%2F12%2F13%2Fleetcode%202105.%20%E7%BB%99%E6%A4%8D%E7%89%A9%E6%B5%87%E6%B0%B4%20II%2F</url>
    <content type="text"><![CDATA[题目：Alice 和 Bob 打算给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。 每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，最初是满的 。他们按下面描述的方式完成浇水： Alice 按 从左到右 的顺序给植物浇水，从植物 0 开始。Bob 按 从右到左 的顺序给植物浇水，从植物 n - 1 开始。他们 同时 给植物浇水。 如果没有足够的水 完全 浇灌下一株植物，他 / 她会立即重新灌满浇水罐。 不管植物需要多少水，浇水所耗费的时间都是一样的。 不能 提前重新灌满水罐。 每株植物都可以由 Alice 或者 Bob 来浇水。 如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水更多的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。 给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有两个整数 capacityA 和 capacityB 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 次数 。 示例：示例 1： 输入：plants = [2,2,3,3], capacityA = 5, capacityB = 5 输出：1 解释： - 最初，Alice 和 Bob 的水罐中各有 5 单元水。 - Alice 给植物 0 浇水，Bob 给植物 3 浇水。 - Alice 和 Bob 现在分别剩下 3 单元和 2 单元水。 - Alice 有足够的水给植物 1 ，所以她直接浇水。Bob 的水不够给植物 2 ，所以他先重新装满水，再浇水。 所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 0 + 1 + 0 = 1 。 示例 2： 输入：plants = [2,2,3,3], capacityA = 3, capacityB = 4 输出：2 解释： - 最初，Alice 的水罐中有 3 单元水，Bob 的水罐中有 4 单元水。 - Alice 给植物 0 浇水，Bob 给植物 3 浇水。 - Alice 和 Bob 现在都只有 1 单元水，并分别需要给植物 1 和植物 2 浇水。 - 由于他们的水量均不足以浇水，所以他们重新灌满水罐再进行浇水。 所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 1 + 1 + 0 = 2 。 示例 3： 输入：plants = [5], capacityA = 10, capacityB = 8 输出：0 解释： - 只有一株植物 - Alice 的水罐有 10 单元水，Bob 的水罐有 8 单元水。因此 Alice 的水罐中水更多，她会给这株植物浇水。 所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 。 示例 4： 输入：plants = [1,2,4,4,5], capacityA = 6, capacityB = 5 输出：2 解释： - 最初，Alice 的水罐中有 6 单元水，Bob 的水罐中有 5 单元水。 - Alice 给植物 0 浇水，Bob 给植物 4 浇水。 - Alice 和 Bob 现在分别剩下 5 单元和 0 单元水。 - Alice 有足够的水给植物 1 ，所以她直接浇水。Bob 的水不够给植物 3 ，所以他先重新装满水，再浇水。 - Alice 和 Bob 现在分别剩下 3 单元和 1 单元水。 - 由于 Alice 的水更多，所以由她给植物 2 浇水。然而，她水罐里的水不够给植物 2 ，所以她先重新装满水，再浇水。 所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 0 + 0 + 1 + 1 + 0 = 2 。 示例 5： 输入：plants = [2,2,5,2,2], capacityA = 5, capacityB = 5 输出：1 解释： Alice 和 Bob 都会到达中间的植物，并且此时他俩剩下的水量相同，所以 Alice 会给这株植物浇水。 由于她到达时只剩下 1 单元水，所以需要重新灌满水罐。 这是唯一一次需要重新灌满水罐的情况。所以，两人浇灌所有植物过程中重新灌满水罐的次数 = 1 。 提示： n == plants.length 1 &lt;= n &lt;= 10^5 1 &lt;= plants[i] &lt;= 10^6 max(plants[i]) &lt;= capacityA, capacityB &lt;= 10^9 分析：双指针模拟 Alice 和 Bob给植物浇水 代码：class Solution { public: int minimumRefill(vector&lt;int&gt;&amp; plants, int capacityA, int capacityB) { int ret = 0; for(int l = 0, lc = capacityA, r = plants.size()-1, rc = capacityB; l &lt;= r; l++, r--){ if(l == r){ if(lc &gt;= rc){ if(lc &gt;= plants[l]) lc -= plants[l]; else ret++; } else{ if(rc &gt;= plants[r]) rc -= plants[r]; else ret++; } break; } if(lc &gt;= plants[l]) lc -= plants[l]; else{ lc = capacityA; lc -= plants[l]; ret++; } if(rc &gt;= plants[r]) rc -= plants[r]; else{ rc = capacityB; rc -= plants[r]; ret++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/watering-plants-ii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5953. 子数组范围和]]></title>
    <url>%2F2021%2F12%2F13%2Fleetcode%205953.%20%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。 返回 nums 中 所有 子数组范围的 和 。 子数组是数组中一个连续 非空 的元素序列。 示例：示例 1： 输入：nums = [1,2,3] 输出：4 解释：nums 的 6 个子数组如下所示： [1]，范围 = 最大 - 最小 = 1 - 1 = 0 [2]，范围 = 2 - 2 = 0 [3]，范围 = 3 - 3 = 0 [1,2]，范围 = 2 - 1 = 1 [2,3]，范围 = 3 - 2 = 1 [1,2,3]，范围 = 3 - 1 = 2 所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4 示例 2： 输入：nums = [1,3,3] 输出：4 解释：nums 的 6 个子数组如下所示： [1]，范围 = 最大 - 最小 = 1 - 1 = 0 [3]，范围 = 3 - 3 = 0 [3]，范围 = 3 - 3 = 0 [1,3]，范围 = 3 - 1 = 2 [3,3]，范围 = 3 - 3 = 0 [1,3,3]，范围 = 3 - 1 = 2 所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4 示例 3： 输入：nums = [4,-2,-3,4,1] 输出：59 解释：nums 中所有子数组范围的和是 59 提示： 1 &lt;= nums.length &lt;= 1000 -10^9 &lt;= nums[i] &lt;= 10^9 分析：二重循环遍历，暴力枚举俩个边界，记录其中最大值减最小值的差值的和 代码：class Solution { public: long long subArrayRanges(vector&lt;int&gt;&amp; nums) { long long ret = 0; for(int i = 0; i &lt; nums.size(); i++){ int n_max = INT_MIN; int n_min = INT_MAX; for(int j = i; j &lt; nums.size(); j++){ n_max = max(n_max, nums[j]); n_min = min(n_min, nums[j]); ret += n_max-n_min; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/sum-of-subarray-ranges/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5952. 环和杆]]></title>
    <url>%2F2021%2F12%2F13%2Fleetcode%205952.%20%E7%8E%AF%E5%92%8C%E6%9D%86%2F</url>
    <content type="text"><![CDATA[题目：总计有 n 个环，环的颜色可以是红、绿、蓝中的一种。这些环分布穿在 10 根编号为 0 到 9 的杆上。 给你一个长度为 2n 的字符串 rings ，表示这 n 个环在杆上的分布。rings 中每两个字符形成一个 颜色位置对 ，用于描述每个环： 第 i 对中的 第一个 字符表示第 i 个环的 颜色（’R’、’G’、’B’）。 第 i 对中的 第二个 字符表示第 i 个环的 位置，也就是位于哪根杆上（’0’ 到 ‘9’）。 例如，”R3G2B1” 表示：共有 n == 3 个环，红色的环在编号为 3 的杆上，绿色的环在编号为 2 的杆上，蓝色的环在编号为 1 的杆上。 找出所有集齐 全部三种颜色 环的杆，并返回这种杆的数量。 示例：示例 1： 输入：rings = &quot;B0B6G0R6R0R6G9&quot; 输出：1 解释： - 编号 0 的杆上有 3 个环，集齐全部颜色：红、绿、蓝。 - 编号 6 的杆上有 3 个环，但只有红、蓝两种颜色。 - 编号 9 的杆上只有 1 个绿色环。 因此，集齐全部三种颜色环的杆的数目为 1 。 示例 2： 输入：rings = &quot;B0R0G0R9R0B0G0&quot; 输出：1 解释： - 编号 0 的杆上有 6 个环，集齐全部颜色：红、绿、蓝。 - 编号 9 的杆上只有 1 个红色环。 因此，集齐全部三种颜色环的杆的数目为 1 。 示例 3： 输入：rings = &quot;G4&quot; 输出：0 解释： 只给了一个环，因此，不存在集齐全部三种颜色环的杆。 提示： rings.length == 2 * n 1 &lt;= n &lt;= 100 如 i 是 偶数 ，则 rings[i] 的值可以取 ‘R’、’G’ 或 ‘B’（下标从 0 开始计数） 如 i 是 奇数 ，则 rings[i] 的值可以取 ‘0’ 到 ‘9’ 中的一个数字（下标从 0 开始计数） 分析：遍历字符串，模拟套环 最后遍历一遍杆子，获得拥有三种颜色的环的杆子数量 代码：class Solution { public: int countPoints(string rings) { vector&lt;vector&lt;int&gt;&gt; v(10, vector&lt;int&gt;(3, 0)); int ret = 0; for(int i = 0; i &lt; rings.size(); i+=2){ if(rings[i] == &apos;R&apos;){ v[rings[i+1] - &apos;0&apos;][0]++; } else if(rings[i] == &apos;G&apos;){ v[rings[i+1] - &apos;0&apos;][1]++; } else if(rings[i] == &apos;B&apos;){ v[rings[i+1] - &apos;0&apos;][2]++; } } for(int i = 0; i &lt; 10; i++){ if(v[i][0] &gt; 0 &amp;&amp; v[i][1] &gt; 0 &amp;&amp; v[i][2] &gt; 0){ ret++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/rings-and-rods/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5932. 合法重新排列数对]]></title>
    <url>%2F2021%2F12%2F06%2Fleetcode%205932.%20%E5%90%88%E6%B3%95%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的二维整数数组 pairs ，其中 pairs[i] = [starti, endi] 。如果 pairs 的一个重新排列，满足对每一个下标 i （ 1 &lt;= i &lt; pairs.length ）都有 endi-1 == starti ，那么我们就认为这个重新排列是 pairs 的一个 合法重新排列 。 请你返回 任意一个 pairs 的合法重新排列。 注意：数据保证至少存在一个 pairs 的合法重新排列。 示例：示例 1： 输入：pairs = [[5,1],[4,5],[11,9],[9,4]] 输出：[[11,9],[9,4],[4,5],[5,1]] 解释： 输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。 end0 = 9 == 9 = start1 end1 = 4 == 4 = start2 end2 = 5 == 5 = start3 示例 2： 输入：pairs = [[1,3],[3,2],[2,1]] 输出：[[1,3],[3,2],[2,1]] 解释： 输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。 end0 = 3 == 3 = start1 end1 = 2 == 2 = start2 重新排列后的数组 [[2,1],[1,3],[3,2]] 和 [[3,2],[2,1],[1,3]] 都是合法的。 示例 3： 输入：pairs = [[1,2],[1,3],[2,1]] 输出：[[1,2],[2,1],[1,3]] 解释： 输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。 end0 = 2 == 2 = start1 end1 = 1 == 1 = start2 提示： 1 &lt;= pairs.length &lt;= 10^5 pairs[i].length == 2 0 &lt;= starti, endi &lt;= 10^9 starti != endi pairs 中不存在一模一样的数对。 至少 存在 一个合法的 pairs 重新排列。 分析：欧拉路径 因为题目保证存在合法排列，所以有两种可能： 可以形成环 从随意一个点出发遍历 不能形成环 找到出度大于入度的结点遍历 使用dfs遍历，当一个结点找不到非重复性的路径时，就加入目的数组 参考：https://leetcode-cn.com/problems/valid-arrangement-of-pairs/solution/zhuan-hua-wei-ou-la-lu-jing-wen-ti-tu-ji-aqmu/ 代码：class Solution { struct ListNode { int val; ListNode *next; }; map&lt;int, ListNode*&gt; m; map&lt;int, int&gt; mr; map&lt;int, int&gt; mc; vector&lt;int&gt; v; public: void dfs(int n){ while(m[n] != NULL){ ListNode* next = m[n]; m[n] = m[n]-&gt;next; dfs(next-&gt;val); delete next; } v.push_back(n); } vector&lt;vector&lt;int&gt;&gt; validArrangement(vector&lt;vector&lt;int&gt;&gt;&amp; pairs) { for(int i = 0; i&lt; pairs.size(); i++){ ListNode* l = new ListNode; l-&gt;val = pairs[i][1]; l-&gt;next = m[pairs[i][0]]; m[pairs[i][0]] = l; mr[pairs[i][1]]++; mc[pairs[i][0]]++; } bool b = true; int qishi = pairs[0][0]; for(auto a : mc){ if(a.second &gt; mr[a.first]){ qishi = a.first; b = false; break; } } dfs(qishi); vector&lt;vector&lt;int&gt;&gt; ret; for(int i = v.size()-1; i &gt; 0; i--){ ret.push_back({v[i], v[i-1]}); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/valid-arrangement-of-pairs/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5944. 从二叉树一个节点到另一个节点每一步的方向]]></title>
    <url>%2F2021%2F12%2F06%2Fleetcode%205944.%20%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E6%AF%8F%E4%B8%80%E6%AD%A5%E7%9A%84%E6%96%B9%E5%90%91%2F</url>
    <content type="text"><![CDATA[题目：给你一棵 二叉树 的根节点 root ，这棵二叉树总共有 n 个节点。每个节点的值为 1 到 n 中的一个整数，且互不相同。给你一个整数 startValue ，表示起点节点 s 的值，和另一个不同的整数 destValue ，表示终点节点 t 的值。 请找到从节点 s 到节点 t 的 最短路径 ，并以字符串的形式返回每一步的方向。每一步用 大写 字母 ‘L’ ，’R’ 和 ‘U’ 分别表示一种方向： ‘L’ 表示从一个节点前往它的 左孩子 节点。 ‘R’ 表示从一个节点前往它的 右孩子 节点。 ‘U’ 表示从一个节点前往它的 父 节点。 请你返回从 s 到 t 最短路径 每一步的方向。 示例：示例 1： 输入：root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6 输出：&quot;UURL&quot; 解释：最短路径为：3 → 1 → 5 → 2 → 6 。 示例 2： 输入：root = [2,1], startValue = 2, destValue = 1 输出：&quot;L&quot; 解释：最短路径为：2 → 1 。 提示： 树中节点数目为 n 。 2 &lt;= n &lt;= 10^5 1 &lt;= Node.val &lt;= n 树中所有节点的值 互不相同 。 1 &lt;= startValue, destValue &lt;= n startValue != destValue 分析：将二叉树转换成图，使用dfs从开始结点遍历，中途记录路径，直到找到目标结点，因为是从二叉树转换来的图，所以只要找到了就是最短路径 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { vector&lt;vector&lt;int&gt;&gt; v; unordered_map&lt;int, bool&gt; m; vector&lt;char&gt; fx; string ret; int si; public: void dfs(TreeNode* root){ if(root == NULL){ return; } si++; dfs(root-&gt;left); dfs(root-&gt;right); } void dfs_jl(TreeNode* root){ if(root == NULL){ return; } if(root-&gt;left != NULL){ v[root-&gt;left-&gt;val][0] = root-&gt;val; v[root-&gt;val][1] = root-&gt;left-&gt;val; dfs_jl(root-&gt;left); } if(root-&gt;right != NULL ){ v[root-&gt;right-&gt;val][0] = root-&gt;val; v[root-&gt;val][2] = root-&gt;right-&gt;val; dfs_jl(root-&gt;right); } } bool dfs_cz(int n, int d){ m[n] = true; if(n == d){ return true; } for(int i = 0; i &lt; 3; i++){ if(v[n][i] != -1 &amp;&amp; m[v[n][i]] != true){ ret += fx[i]; if(dfs_cz(v[n][i], d)) return true;; ret.erase(ret.size()-1); } } return false; } string getDirections(TreeNode* root, int startValue, int destValue) { si = 0; dfs(root); fx.push_back(&apos;U&apos;); fx.push_back(&apos;L&apos;); fx.push_back(&apos;R&apos;); v = vector&lt;vector&lt;int&gt;&gt;(si+1, vector&lt;int&gt;(3, -1)); ret = &quot;&quot;; dfs_jl(root); dfs_cz(startValue, destValue); v.clear(); m.clear(); return ret; } }; 题目地址:https://leetcode-cn.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5943. 删除链表的中间节点]]></title>
    <url>%2F2021%2F12%2F06%2Fleetcode%205943.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：给你一个链表的头节点 head 。删除 链表的 中间节点 ，并返回修改后的链表的头节点 head 。 长度为 n 链表的中间节点是从头数起第 ⌊n / 2⌋ 个节点（下标从 0 开始），其中 ⌊x⌋ 表示小于或等于 x 的最大整数。 对于 n = 1、2、3、4 和 5 的情况，中间节点的下标分别是 0、1、1、2 和 2 。 示例：示例 1： 输入：head = [1,3,4,7,1,2,6] 输出：[1,3,4,1,2,6] 解释： 上图表示给出的链表。节点的下标分别标注在每个节点的下方。 由于 n = 7 ，值为 7 的节点 3 是中间节点，用红色标注。 返回结果为移除节点后的新链表。 示例 2： 输入：head = [1,2,3,4] 输出：[1,2,4] 解释： 上图表示给出的链表。 对于 n = 4 ，值为 3 的节点 2 是中间节点，用红色标注。 示例 3： 输入：head = [2,1] 输出：[2] 解释： 上图表示给出的链表。 对于 n = 2 ，值为 1 的节点 1 是中间节点，用红色标注。 值为 2 的节点 0 是移除节点 1 后剩下的唯一一个节点。 提示： 链表中节点的数目在范围 [1, 10^5] 内 1 &lt;= Node.val &lt;= 10^5 分析：先遍历一遍，得到链表结点数量，根据得到的数量去除对应结点 代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteMiddle(ListNode* head) { int n = 0; for(auto a = head; a != NULL; a = a-&gt;next){ n++; } if(n == 1) return NULL; auto a = head; for(int i = 0; i &lt; n/2-1; i++){ a = a-&gt;next; } a-&gt;next = a-&gt;next-&gt;next; return head; } }; 题目地址:https://leetcode-cn.com/problems/delete-the-middle-node-of-a-linked-list/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5942. 找出 3 位偶数]]></title>
    <url>%2F2021%2F12%2F06%2Fleetcode%205942.%20%E6%89%BE%E5%87%BA%203%20%E4%BD%8D%E5%81%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 digits ，其中每个元素是一个数字（0 - 9）。数组中可能存在重复元素。 你需要找出 所有 满足下述条件且 互不相同 的整数： 该整数由 digits 中的三个元素按 任意 顺序 依次连接 组成。 该整数不含 前导零 该整数是一个 偶数 例如，给定的 digits 是 [1, 2, 3] ，整数 132 和 312 满足上面列出的全部条件。 将找出的所有互不相同的整数按 递增顺序 排列，并以数组形式返回。 示例：示例 1： 输入：digits = [2,1,3,0] 输出：[102,120,130,132,210,230,302,310,312,320] 解释： 所有满足题目条件的整数都在输出数组中列出。 注意，答案数组中不含有 奇数 或带 前导零 的整数。 示例 2： 输入：digits = [2,2,8,8,2] 输出：[222,228,282,288,822,828,882] 解释： 同样的数字（0 - 9）在构造整数时可以重复多次，重复次数最多与其在 digits 中出现的次数一样。 在这个例子中，数字 8 在构造 288、828 和 882 时都重复了两次。 示例 3： 输入：digits = [3,7,5] 输出：[] 解释： 使用给定的 digits 无法构造偶数。 示例 4： 输入：digits = [0,2,0,0] 输出：[200] 解释： 唯一一个不含 前导零 且满足全部条件的整数是 200 。 示例 5： 输入：digits = [0,0,0] 输出：[] 解释： 构造的所有整数都会有 前导零 。因此，不存在满足题目条件的整数。 提示： 3 &lt;= digits.length &lt;= 100 0 &lt;= digits[i] &lt;= 9 分析：三重循环遍历，将遍历出的组合放入set去重 代码：class Solution { public: vector&lt;int&gt; findEvenNumbers(vector&lt;int&gt;&amp; digits) { set&lt;int&gt; s; for(int i = 0; i &lt; digits.size(); i++){ for(int j = 0; j &lt; digits.size(); j++){ for(int k = 0; k &lt; digits.size(); k++){ if(i != j &amp;&amp; i != k &amp;&amp; j != k &amp;&amp; digits[i] != 0 &amp;&amp; digits[k] % 2 == 0){ s.insert(digits[i]*100 + digits[j]*10 + digits[k]); } } } } vector&lt;int&gt; ret(s.begin(), s.end()); return ret; } }; 题目地址:https://leetcode-cn.com/problems/finding-3-digit-even-numbers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5941. 找出知晓秘密的所有专家]]></title>
    <url>%2F2021%2F11%2F29%2Fleetcode%205941.%20%E6%89%BE%E5%87%BA%E7%9F%A5%E6%99%93%E7%A7%98%E5%AF%86%E7%9A%84%E6%89%80%E6%9C%89%E4%B8%93%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n ，表示有 n 个专家从 0 到 n - 1 编号。另外给你一个下标从 0 开始的二维整数数组 meetings ，其中 meetings[i] = [xi, yi, timei] 表示专家 xi 和专家 yi 在时间 timei 要开一场会。一个专家可以同时参加 多场会议 。最后，给你一个整数 firstPerson 。 专家 0 有一个 秘密 ，最初，他在时间 0 将这个秘密分享给了专家 firstPerson 。接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播。更正式的表达是，每次会议，如果专家 xi 在时间 timei 时知晓这个秘密，那么他将会与专家 yi 分享这个秘密，反之亦然。 秘密共享是 瞬时发生 的。也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享。 在所有会议都结束之后，返回所有知晓这个秘密的专家列表。你可以按 任何顺序 返回答案。 示例：示例 1： 输入：n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1 输出：[0,1,2,3,5] 解释： 时间 0 ，专家 0 将秘密与专家 1 共享。 时间 5 ，专家 1 将秘密与专家 2 共享。 时间 8 ，专家 2 将秘密与专家 3 共享。 时间 10 ，专家 1 将秘密与专家 5 共享。 因此，在所有会议结束后，专家 0、1、2、3 和 5 都将知晓这个秘密。 示例 2： 输入：n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3 输出：[0,1,3] 解释： 时间 0 ，专家 0 将秘密与专家 3 共享。 时间 2 ，专家 1 与专家 2 都不知晓这个秘密。 时间 3 ，专家 3 将秘密与专家 0 和专家 1 共享。 因此，在所有会议结束后，专家 0、1 和 3 都将知晓这个秘密。 示例 3： 输入：n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1 输出：[0,1,2,3,4] 解释： 时间 0 ，专家 0 将秘密与专家 1 共享。 时间 1 ，专家 1 将秘密与专家 2 共享，专家 2 将秘密与专家 3 共享。 注意，专家 2 可以在收到秘密的同一时间分享此秘密。 时间 2 ，专家 3 将秘密与专家 4 共享。 因此，在所有会议结束后，专家 0、1、2、3 和 4 都将知晓这个秘密。 示例 4： 输入：n = 6, meetings = [[0,2,1],[1,3,1],[4,5,1]], firstPerson = 1 输出：[0,1,2,3] 解释： 时间 0 ，专家 0 将秘密与专家 1 共享。 时间 1 ，专家 0 将秘密与专家 2 共享，专家 1 将秘密与专家 3 共享。 因此，在所有会议结束后，专家 0、1、2 和 3 都将知晓这个秘密。 提示： 2 &lt;= n &lt;= 10^5 1 &lt;= meetings.length &lt;= 10^5 meetings[i].length == 3 0 &lt;= xi, yi &lt;= n - 1 xi != yi 1 &lt;= timei &lt;= 10^5 1 &lt;= firstPerson &lt;= n - 1 分析：使用map将专家按时间存储会议 对同一时间内的会议使用并查集处理 在每次并查集处理前将所有知情的人和0连接在一起 当并查集处理完后所有和0相连接的人就是知情人 不同时间的会议单独处理，只保留知情人的关系，不保留非知情人的关系 代码：class Solution { vector&lt;int&gt; pre; vector&lt;int&gt; pre1; public: int Find_pre(int i) //查找父节点 { if(pre[i]==i) return pre[i]; return pre[i] = Find_pre(pre[i]); } void join(int x,int y) // 组合 { int fx=Find_pre(x), fy=Find_pre(y); if(fx != fy) pre[fx]=fy; } int Find_pre1(int i) //查找父节点 { if(pre1[i]==i) return pre1[i]; return pre1[i] = Find_pre1(pre1[i]); } void join1(int x,int y) // 组合 { int fx=Find_pre1(x), fy=Find_pre1(y); if(fx != fy) pre1[fx]=fy; } vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) { for(int i = 0; i &lt; n; i++){ pre1.push_back(i); } map&lt;int, vector&lt;int&gt;&gt; m; unordered_map&lt;int, int&gt; zd; zd[0] = 1; zd[firstPerson] = 1; join1(firstPerson, 0); for(int i = 0; i &lt; meetings.size(); i++){ m[meetings[i][2]].push_back(meetings[i][0]); m[meetings[i][2]].push_back(meetings[i][1]); } for(auto t = m.begin(); t != m.end(); t++){ pre = pre1; set&lt;int&gt; s; for(int i = 1; i &lt; t-&gt;second.size(); i+=2){ join(t-&gt;second[i-1], t-&gt;second[i]); s.insert(t-&gt;second[i-1]); s.insert(t-&gt;second[i]); } for(auto a : s){ if(Find_pre(a) == Find_pre(0)){ zd[a] = 1; join1(a, 0); } } } vector&lt;int&gt; ret; for(auto a : zd){ ret.push_back(a.first); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-all-people-with-secret/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5940. 从数组中移除最大值和最小值]]></title>
    <url>%2F2021%2F11%2F29%2Fleetcode%205940.%20%E4%BB%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的数组 nums ，数组由若干 互不相同 的整数组成。 nums 中有一个值最小的元素和一个值最大的元素。分别称为 最小值 和 最大值 。你的目标是从数组中移除这两个元素。 一次 删除 操作定义为从数组的 前面 移除一个元素或从数组的 后面 移除一个元素。 返回将数组中最小值和最大值 都 移除需要的最小删除次数。 示例：示例 1： 输入：nums = [2,10,7,5,4,1,8,6] 输出：5 解释： 数组中的最小元素是 nums[5] ，值为 1 。 数组中的最大元素是 nums[1] ，值为 10 。 将最大值和最小值都移除需要从数组前面移除 2 个元素，从数组后面移除 3 个元素。 结果是 2 + 3 = 5 ，这是所有可能情况中的最小删除次数。 示例 2： 输入：nums = [0,-4,19,1,8,-2,-3,5] 输出：3 解释： 数组中的最小元素是 nums[1] ，值为 -4 。 数组中的最大元素是 nums[2] ，值为 19 。 将最大值和最小值都移除需要从数组前面移除 3 个元素。 结果是 3 ，这是所有可能情况中的最小删除次数。 示例 3： 输入：nums = [101] 输出：1 解释： 数组中只有这一个元素，那么它既是数组中的最小值又是数组中的最大值。 移除它只需要 1 次删除操作。 提示： 1 &lt;= nums.length &lt;= 10^5 -10^5 &lt;= nums[i] &lt;= 10^5 nums 中的整数 互不相同 分析：先找出最大值和最小值，根据在左侧和在右侧分为l和r 有三种移除法 从左侧移除到r 从右侧移除到l 从左侧移除到l，从右侧移除到r 代码：class Solution { public: int minimumDeletions(vector&lt;int&gt;&amp; nums) { int nsize = nums.size(); int mx = -1000000; int mxi = 0; int mn = INT_MAX; int mni = 0; for(int i = 0; i &lt; nums.size(); i++){ if(mx &lt; nums[i]){ mx = nums[i]; mxi = i; } if(mn &gt; nums[i]){ mn = nums[i]; mni = i; } } int l = min(mxi, mni); int r = max(mxi, mni); int ret = INT_MAX; ret = min(ret, r+1); ret = min(ret, nsize-l); ret = min(ret, l+1+nsize-r); return ret; } }; 题目地址:https://leetcode-cn.com/problems/removing-minimum-and-maximum-from-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5939. 半径为 k 的子数组平均值]]></title>
    <url>%2F2021%2F11%2F29%2Fleetcode%205939.%20%E5%8D%8A%E5%BE%84%E4%B8%BA%20k%20%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%B9%B3%E5%9D%87%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的数组 nums ，数组中有 n 个整数，另给你一个整数 k 。 半径为 k 的子数组平均值 是指：nums 中一个以下标 i 为 中心 且 半径 为 k 的子数组中所有元素的平均值，即下标在 i - k 和 i + k 范围（含 i - k 和 i + k）内所有元素的平均值。如果在下标 i 前或后不足 k 个元素，那么 半径为 k 的子数组平均值 是 -1 。 构建并返回一个长度为 n 的数组 avgs ，其中 avgs[i] 是以下标 i 为中心的子数组的 半径为 k 的子数组平均值 。 x 个元素的 平均值 是 x 个元素相加之和除以 x ，此时使用截断式 整数除法 ，即需要去掉结果的小数部分。 例如，四个元素 2、3、1 和 5 的平均值是 (2 + 3 + 1 + 5) / 4 = 11 / 4 = 3.75，截断后得到 3 。 示例：示例 1： 输入：nums = [7,4,3,9,1,8,5,2,6], k = 3 输出：[-1,-1,-1,5,4,4,-1,-1,-1] 解释： - avg[0]、avg[1] 和 avg[2] 是 -1 ，因为在这几个下标前的元素数量都不足 k 个。 - 中心为下标 3 且半径为 3 的子数组的元素总和是：7 + 4 + 3 + 9 + 1 + 8 + 5 = 37 。 使用截断式 整数除法，avg[3] = 37 / 7 = 5 。 - 中心为下标 4 的子数组，avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4 。 - 中心为下标 5 的子数组，avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4 。 - avg[6]、avg[7] 和 avg[8] 是 -1 ，因为在这几个下标后的元素数量都不足 k 个。 示例 2： 输入：nums = [100000], k = 0 输出：[100000] 解释： - 中心为下标 0 且半径 0 的子数组的元素总和是：100000 。 avg[0] = 100000 / 1 = 100000 。 示例 3： 输入：nums = [8], k = 100000 输出：[-1] 解释： - avg[0] 是 -1 ，因为在下标 0 前后的元素数量均不足 k 。 提示： n == nums.length 1 &lt;= n &lt;= 10^5 0 &lt;= nums[i], k &lt;= 10^5 分析：先计算长度为2k+1的字数组的值的和，这就是下标i为k+1时的字数组的值，之后下标没加1，就减去i-k的值，加上i+k+1的值，这样的时间复杂度为O(n) 要记得题目要求取平均值 代码：class Solution { public: vector&lt;int&gt; getAverages(vector&lt;int&gt;&amp; nums, int k) { long long num = 0; vector&lt;int&gt; ret(nums.size(), -1); if(nums.size() &lt; 2*k+1) return ret; for(int i = 0; i &lt; k*2+1; i++){ num += nums[i]; } ret[k] = num/(k*2+1); for(int i = k+1; i &lt; nums.size()-k; i++){ num = num - nums[i-k-1] + nums[i+k]; ret[i] = num/(k*2+1); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/k-radius-subarray-averages/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5938. 找出数组排序后的目标下标]]></title>
    <url>%2F2021%2F11%2F29%2Fleetcode%205938.%20%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E7%9B%AE%E6%A0%87%E4%B8%8B%E6%A0%87%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的整数数组 nums 以及一个目标元素 target 。 目标下标 是一个满足 nums[i] == target 的下标 i 。 将 nums 按 非递减 顺序排序后，返回由 nums 中目标下标组成的列表。如果不存在目标下标，返回一个 空 列表。返回的列表必须按 递增 顺序排列。 示例：示例 1： 输入：nums = [1,2,5,2,3], target = 2 输出：[1,2] 解释：排序后，nums 变为 [1,2,2,3,5] 。 满足 nums[i] == 2 的下标是 1 和 2 。 示例 2： 输入：nums = [1,2,5,2,3], target = 3 输出：[3] 解释：排序后，nums 变为 [1,2,2,3,5] 。 满足 nums[i] == 3 的下标是 3 。 示例 3： 输入：nums = [1,2,5,2,3], target = 5 输出：[4] 解释：排序后，nums 变为 [1,2,2,3,5] 。 满足 nums[i] == 5 的下标是 4 。 示例 4： 输入：nums = [1,2,5,2,3], target = 4 输出：[] 解释：nums 中不含值为 4 的元素。 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i], target &lt;= 100 分析：先排序，遍历一遍找出值为target的下标 代码：class Solution { public: vector&lt;int&gt; targetIndices(vector&lt;int&gt;&amp; nums, int target) { sort(nums.begin(), nums.end()); vector&lt;int&gt; ret; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] == target){ ret.push_back(i); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-target-indices-after-sorting-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5929. 处理含限制条件的好友请求]]></title>
    <url>%2F2021%2F11%2F15%2Fleetcode%205929.%20%E5%A4%84%E7%90%86%E5%90%AB%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%A5%BD%E5%8F%8B%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n ，表示网络上的用户数目。每个用户按从 0 到 n - 1 进行编号。 给你一个下标从 0 开始的二维整数数组 restrictions ，其中 restrictions[i] = [xi, yi] 意味着用户 xi 和用户 yi 不能 成为 朋友 ，不管是 直接 还是通过其他用户 间接 。 最初，用户里没有人是其他用户的朋友。给你一个下标从 0 开始的二维整数数组 requests 表示好友请求的列表，其中 requests[j] = [uj, vj] 是用户 uj 和用户 vj 之间的一条好友请求。 如果 uj 和 vj 可以成为 朋友 ，那么好友请求将会 成功 。每个好友请求都会按列表中给出的顺序进行处理（即，requests[j] 会在 requests[j + 1] 前）。一旦请求成功，那么对所有未来的好友请求而言， uj 和 vj 将会 成为直接朋友 。 返回一个 布尔数组 result ，其中元素遵循此规则：如果第 j 个好友请求 成功 ，那么 result[j] 就是 true ；否则，为 false 。 注意：如果 uj 和 vj 已经是直接朋友，那么他们之间的请求将仍然 成功 。 示例：示例 1： 输入：n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]] 输出：[true,false] 解释： 请求 0 ：用户 0 和 用户 2 可以成为朋友，所以他们成为直接朋友。 请求 1 ：用户 2 和 用户 1 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (1--2--0) 。 示例 2： 输入：n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]] 输出：[true,false] 解释： 请求 0 ：用户 1 和 用户 2 可以成为朋友，所以他们成为直接朋友。 请求 1 ：用户 0 和 用户 2 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--2--1) 。 示例 3： 输入：n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]] 输出：[true,false,true,false] 解释： 请求 0 ：用户 0 和 用户 4 可以成为朋友，所以他们成为直接朋友。 请求 1 ：用户 1 和 用户 2 不能成为朋友，因为他们之间存在限制。 请求 2 ：用户 3 和 用户 1 可以成为朋友，所以他们成为直接朋友。 请求 3 ：用户 3 和 用户 4 不能成为朋友，因为这会使 用户 0 和 用户 1 成为间接朋友 (0--4--3--1) 。 提示： 2 &lt;= n &lt;= 1000 0 &lt;= restrictions.length &lt;= 1000 restrictions[i].length == 2 0 &lt;= xi, yi &lt;= n - 1 xi != yi 1 &lt;= requests.length &lt;= 1000 requests[j].length == 2 0 &lt;= uj, vj &lt;= n - 1 uj != vj 分析：使用并查集记录所有的好友关系，对每一个新的关系都遍历一遍无法成为好友的列表，若不在列表中，表示可以成为好友，反之则不能。 代码：class Solution { vector&lt;int&gt; pre; vector&lt;vector&lt;int&gt;&gt; restrictions; public: int Find_pre(int i) { if(pre[i]==i) return pre[i]; return Find_pre(pre[i]); } void join(int x,int y) { int fx=Find_pre(x), fy=Find_pre(y); if(fx != fy) pre[fx]=fy; } bool py(int l, int r){ for(int i = 0; i &lt; restrictions.size(); i++){ if((Find_pre(restrictions[i][0]) == Find_pre(l) &amp;&amp; Find_pre(restrictions[i][1]) == Find_pre(r)) || (Find_pre(restrictions[i][0]) == Find_pre(r) &amp;&amp; Find_pre(restrictions[i][1]) == Find_pre(l))){ return false; } } return true; } vector&lt;bool&gt; friendRequests(int n, vector&lt;vector&lt;int&gt;&gt;&amp; restrictions, vector&lt;vector&lt;int&gt;&gt;&amp; requests) { this-&gt;restrictions = restrictions; for(int i = 0; i &lt; n; i++){ pre.push_back(i); } vector&lt;bool&gt; ret; for(int i = 0; i &lt; requests.size(); i++){ int l = Find_pre(requests[i][0]); int r = Find_pre(requests[i][1]); if(py(l, r)){ ret.push_back(true); join(requests[i][0], requests[i][1]); } else{ ret.push_back(false); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/process-restricted-friend-requests/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5928. 解码斜向换位密码]]></title>
    <url>%2F2021%2F11%2F15%2Fleetcode%205928.%20%E8%A7%A3%E7%A0%81%E6%96%9C%E5%90%91%E6%8D%A2%E4%BD%8D%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[题目：字符串 originalText 使用 斜向换位密码 ，经由 行数固定 为 rows 的矩阵辅助，加密得到一个字符串 encodedText 。 originalText 先按从左上到右下的方式放置到矩阵中。 先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 originalText 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 ‘ ‘ 进行填充。矩阵的列数需满足：用 originalText 填充之后，最右侧列 不为空 。 接着按行将字符附加到矩阵中，构造 encodedText 。 先把蓝色单元格中的字符附加到 encodedText 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。 例如，如果 originalText = “cipher” 且 rows = 3 ，那么我们可以按下述方法将其编码：(具体图片见网页) 蓝色箭头标识 originalText 是如何放入矩阵中的，红色箭头标识形成 encodedText 的顺序。在上述例子中，encodedText = “ch ie pr” 。 给你编码后的字符串 encodedText 和矩阵的行数 rows ，返回源字符串 originalText 。 注意：originalText 不 含任何尾随空格 ‘ ‘ 。生成的测试用例满足 仅存在一个 可能的 originalText 。 示例：示例 1： 输入：encodedText = &quot;ch ie pr&quot;, rows = 3 输出：&quot;cipher&quot; 解释：此示例与问题描述中的例子相同。 示例 2： 输入：encodedText = &quot;iveo eed l te olc&quot;, rows = 4 输出：&quot;i love leetcode&quot; 解释：上图标识用于编码 originalText 的矩阵。 蓝色箭头展示如何从 encodedText 找到 originalText 。 示例 3： 输入：encodedText = &quot;coding&quot;, rows = 1 输出：&quot;coding&quot; 解释：由于只有 1 行，所以 originalText 和 encodedText 是相同的。 示例 4： 输入：encodedText = &quot; b ac&quot;, rows = 2 输出：&quot; abc&quot; 解释：originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。 提示： 0 &lt;= encodedText.length &lt;= 10^6 encodedText 仅由小写英文字母和 ‘ ‘ 组成 encodedText 是对某个 不含 尾随空格的 * originalText 的一个有效编码 1 &lt;= rows &lt;= 1000 生成的测试用例满足 仅存在一个 可能的 originalText 分析：将加密后字符串装入行数为rows的矩阵中，按照解密顺序遍历一遍，删除最后的空格。 代码：class Solution { public: string decodeCiphertext(string encodedText, int rows) { string ret = &quot;&quot;; vector&lt;vector&lt;int&gt;&gt; v; int s = encodedText.size(); int hs = s/rows; for(int i = 0, h = 0; i &lt; s; i++){ if(h == 0){ v.push_back(vector&lt;int&gt;{}); } v.back().push_back(encodedText[i]); h++; if(h == hs){ h = 0; } } for(int i = 0; i &lt; hs; i++){ for(int x = 0, y = i; x &lt; rows &amp;&amp; y &lt; hs; x++, y++){ ret += v[x][y]; } } for(int i = ret.size()-1; i &gt;= 0 &amp;&amp; ret[i] == &apos; &apos;; i--){ ret.erase(i, 1); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/decode-the-slanted-ciphertext/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5927. 反转偶数长度组的节点]]></title>
    <url>%2F2021%2F11%2F15%2Fleetcode%205927.%20%E5%8F%8D%E8%BD%AC%E5%81%B6%E6%95%B0%E9%95%BF%E5%BA%A6%E7%BB%84%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：给你一个链表的头节点 head 。 链表中的节点 按顺序 划分成若干 非空 组，这些非空组的长度构成一个自然数序列（1, 2, 3, 4, …）。一个组的 长度 就是组中分配到的节点数目。换句话说： 节点 1 分配给第一组 节点 2 和 3 分配给第二组 节点 4、5 和 6 分配给第三组，以此类推 注意，最后一组的长度可能小于或者等于 1 + 倒数第二组的长度 。 反转 每个 偶数 长度组中的节点，并返回修改后链表的头节点 head 。 示例：示例 1： 输入：head = [5,2,6,3,9,1,7,3,8,4] 输出：[5,6,2,3,9,1,4,8,3,7] 解释： - 第一组长度为 1 ，奇数，没有发生反转。 - 第二组长度为 2 ，偶数，节点反转。 - 第三组长度为 3 ，奇数，没有发生反转。 - 最后一组长度为 4 ，偶数，节点反转。 示例 2： 输入：head = [1,1,0,6] 输出：[1,0,1,6] 解释： - 第一组长度为 1 ，没有发生反转。 - 第二组长度为 2 ，节点反转。 - 最后一组长度为 1 ，没有发生反转。 示例 3： 输入：head = [2,1] 输出：[2,1] 解释： - 第一组长度为 1 ，没有发生反转。 - 最后一组长度为 1 ，没有发生反转。 示例 4： 输入：head = [8] 输出：[8] 解释：只有一个长度为 1 的组，没有发生反转。 提示： 链表中节点数目范围是 [1, 10^5] 0 &lt;= Node.val &lt;= 10^5 分析：将链表转换成二维数组模式，再重新转换成链表模式时，将偶数位长度组反转 代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseEvenLengthGroups(ListNode* head) { vector&lt;vector&lt;int&gt;&gt; v; vector&lt;int&gt; vi; ListNode* ret = head; int n = 0; int l = 1; for(ListNode* ln = head; ln != NULL;){ n++; vi.push_back(ln-&gt;val); if(n == l){ v.push_back(vi); vi.clear(); n = 0; l++; } ln = ln-&gt;next; } if(vi.size() != 0){ v.push_back(vi); } for(int i = 0; i &lt; v.size(); i++){ if(v[i].size() % 2 == 0){ for(int j = v[i].size()-1; j &gt;= 0; j--){ ret-&gt;val = v[i][j]; ret = ret-&gt;next; } } else{ for(int j = 0; j &lt; v[i].size(); j++){ ret = ret-&gt;next; } } } return head; } }; 题目地址:https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5926. 买票需要的时间]]></title>
    <url>%2F2021%2F11%2F15%2Fleetcode%205926.%20%E4%B9%B0%E7%A5%A8%E9%9C%80%E8%A6%81%E7%9A%84%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：有 n 个人前来排队买票，其中第 0 人站在队伍 最前方 ，第 (n - 1) 人站在队伍 最后方 。 给你一个下标从 0 开始的整数数组 tickets ，数组长度为 n ，其中第 i 人想要购买的票数为 tickets[i] 。 每个人买票都需要用掉 恰好 1 秒 。一个人 一次只能买一张票 ，如果需要购买更多票，他必须走到 队尾 重新排队（瞬间 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 离开 队伍。 返回位于位置 k（下标从 0 开始）的人完成买票需要的时间（以秒为单位）。 示例：示例 1： 输入：tickets = [2,3,2], k = 2 输出：6 解释： - 第一轮，队伍中的每个人都买到一张票，队伍变为 [1, 2, 1] 。 - 第二轮，队伍中的每个都又都买到一张票，队伍变为 [0, 1, 0] 。 位置 2 的人成功买到 2 张票，用掉 3 + 3 = 6 秒。 示例 2： 输入：tickets = [5,1,1,1], k = 0 输出：8 解释： - 第一轮，队伍中的每个人都买到一张票，队伍变为 [4, 0, 0, 0] 。 - 接下来的 4 轮，只有位置 0 的人在买票。 位置 0 的人成功买到 5 张票，用掉 4 + 1 + 1 + 1 + 1 = 8 秒。 提示： n == tickets.length 1 &lt;= n &lt;= 100 1 &lt;= tickets[i] &lt;= 100 0 &lt;= k &lt; n 分析：循环模拟，直到tickets[k] == 0 代码：class Solution { public: int timeRequiredToBuy(vector&lt;int&gt;&amp; tickets, int k) { int ret = 0; int i = 0; while(tickets[k] &gt; 0){ if(tickets[i] &gt; 0){ tickets[i]--; ret++; } i = (i+1) % tickets.size(); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/time-needed-to-buy-tickets/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5921. 最大化一张图中的路径价值]]></title>
    <url>%2F2021%2F11%2F08%2Fleetcode%205921.%20%E6%9C%80%E5%A4%A7%E5%8C%96%E4%B8%80%E5%BC%A0%E5%9B%BE%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E4%BB%B7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一张 无向 图，图中有 n 个节点，节点编号从 0 到 n - 1 （都包括）。同时给你一个下标从 0 开始的整数数组 values ，其中 values[i] 是第 i 个节点的 价值 。同时给你一个下标从 0 开始的二维整数数组 edges ，其中 edges[j] = [uj, vj, timej] 表示节点 uj 和 vj 之间有一条需要 timej 秒才能通过的无向边。最后，给你一个整数 maxTime 。 合法路径 指的是图中任意一条从节点 0 开始，最终回到节点 0 ，且花费的总时间 不超过 maxTime 秒的一条路径。你可以访问一个节点任意次。一条合法路径的 价值 定义为路径中 不同节点 的价值 之和 （每个节点的价值 至多 算入价值总和中一次）。 请你返回一条合法路径的 最大 价值。 注意：每个节点 至多 有 四条 边与之相连。 示例：示例 1： 输入：values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49 输出：75 解释： 一条可能的路径为：0 -&gt; 1 -&gt; 0 -&gt; 3 -&gt; 0 。总花费时间为 10 + 10 + 10 + 10 = 40 &lt;= 49 。 访问过的节点为 0 ，1 和 3 ，最大路径价值为 0 + 32 + 43 = 75 。 示例 2： 输入：values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30 输出：25 解释： 一条可能的路径为：0 -&gt; 3 -&gt; 0 。总花费时间为 10 + 10 = 20 &lt;= 30 。 访问过的节点为 0 和 3 ，最大路径价值为 5 + 20 = 25 。 示例 3： 输入：values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50 输出：7 解释： 一条可能的路径为：0 -&gt; 1 -&gt; 3 -&gt; 1 -&gt; 0 。总花费时间为 10 + 13 + 13 + 10 = 46 &lt;= 50 。 访问过的节点为 0 ，1 和 3 ，最大路径价值为 1 + 2 + 4 = 7 。 示例 4： 输入：values = [0,1,2], edges = [[1,2,10]], maxTime = 10 输出：0 解释： 唯一一条路径为 0 。总花费时间为 0 。 唯一访问过的节点为 0 ，最大路径价值为 0 。 提示： n == values.length 1 &lt;= n &lt;= 1000 0 &lt;= values[i] &lt;= 10^8 0 &lt;= edges.length &lt;= 2000 edges[j].length == 3 0 &lt;= uj &lt; vj &lt;= n - 1 10 &lt;= timej, maxTime &lt;= 100 [uj, vj] 所有节点对 互不相同 。 每个节点 至多有四条 边。 图可能不连通。 分析：根据这条提示10 &lt;= timej, maxTime &lt;= 100，可以使用dfs，时间复杂度最高为 O(4^10) 代码：class Solution { map&lt;int, vector&lt;int&gt;&gt; m; map&lt;int, map&lt;int, int&gt;&gt; t; int ret; public: void dfs(int maxTime, int val, int node, vector&lt;int&gt;&amp; vals){ if(maxTime &lt; 0) return; if(node == 0){ ret = max(ret, val); } for(auto a : m[node]){ int v = vals[a]; vals[a] = 0; dfs(maxTime - t[node][a], val + v, a, vals); vals[a] = v; } } int maximalPathQuality(vector&lt;int&gt;&amp; values, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int maxTime) { ret = values[0]; values[0] = 0; for(int i = 0; i &lt; edges.size(); i++){ m[edges[i][0]].push_back(edges[i][1]); m[edges[i][1]].push_back(edges[i][0]); t[edges[i][0]][edges[i][1]] = edges[i][2]; t[edges[i][1]][edges[i][0]] = edges[i][2]; } dfs(maxTime, ret, 0, values); return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-path-quality-of-a-graph/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5920. 分配给商店的最多商品的最小值]]></title>
    <url>%2F2021%2F11%2F08%2Fleetcode%205920.%20%E5%88%86%E9%85%8D%E7%BB%99%E5%95%86%E5%BA%97%E7%9A%84%E6%9C%80%E5%A4%9A%E5%95%86%E5%93%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n ，表示有 n 间零售商店。总共有 m 种产品，每种产品的数目用一个下标从 0 开始的整数数组 quantities 表示，其中 quantities[i] 表示第 i 种商品的数目。 你需要将 所有商品 分配到零售商店，并遵守这些规则： 一间商店 至多 只能有 一种商品 ，但一间商店拥有的商品数目可以为 任意 件。 分配后，每间商店都会被分配一定数目的商品（可能为 0 件）。用 x 表示所有商店中分配商品数目的最大值，你希望 x 越小越好。也就是说，你想 最小化 分配给任意商店商品数目的 最大值 。 请你返回最小的可能的 x 。 示例：示例 1： 输入：n = 6, quantities = [11,6] 输出：3 解释： 一种最优方案为： - 11 件种类为 0 的商品被分配到前 4 间商店，分配数目分别为：2，3，3，3 。 - 6 件种类为 1 的商品被分配到另外 2 间商店，分配数目分别为：3，3 。 分配给所有商店的最大商品数目为 max(2, 3, 3, 3, 3, 3) = 3 。 示例 2： 输入：n = 7, quantities = [15,10,10] 输出：5 解释：一种最优方案为： - 15 件种类为 0 的商品被分配到前 3 间商店，分配数目为：5，5，5 。 - 10 件种类为 1 的商品被分配到接下来 2 间商店，数目为：5，5 。 - 10 件种类为 2 的商品被分配到最后 2 间商店，数目为：5，5 。 分配给所有商店的最大商品数目为 max(5, 5, 5, 5, 5, 5, 5) = 5 。 示例 3： 输入：n = 1, quantities = [100000] 输出：100000 解释：唯一一种最优方案为： - 所有 100000 件商品 0 都分配到唯一的商店中。 分配给所有商店的最大商品数目为 max(100000) = 100000 。 提示： m == quantities.length 1 &lt;= m &lt;= n &lt;= 10^5 1 &lt;= quantities[i] &lt;= 10^5 分析：使用二分查找 二分标准模板 最大xx的最小值 代码：class Solution { public: int minimizedMaximum(int n, vector&lt;int&gt;&amp; quantities) { int mx = 0; for(int i = 0; i &lt; quantities.size(); i++){ mx = max(quantities[i], mx); } int l = 1; int r = mx; while(l &lt; r){ int m = (l+r) / 2; int a = 0; for(int i = 0; i &lt; quantities.size(); i++){ a += (quantities[i] + m - 1) / m; } if(a &gt; n){ l = m+1; } else{ r = m; } } return l; } }; 题目地址:https://leetcode-cn.com/problems/minimized-maximum-of-products-distributed-to-any-store/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5919. 所有子字符串中的元音]]></title>
    <url>%2F2021%2F11%2F08%2Fleetcode%205919.%20%E6%89%80%E6%9C%89%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 word ，返回 word 的所有子字符串中 元音的总数 ，元音是指 ‘a’、’e’、’i’、’o’ 和 ‘u’ 。 子字符串 是字符串中一个连续（非空）的字符序列。 注意：由于对 word 长度的限制比较宽松，答案可能超过有符号 32 位整数的范围。计算时需当心。 示例：示例 1： 输入：word = &quot;aba&quot; 输出：6 解释： 所有子字符串是：&quot;a&quot;、&quot;ab&quot;、&quot;aba&quot;、&quot;b&quot;、&quot;ba&quot; 和 &quot;a&quot; 。 - &quot;b&quot; 中有 0 个元音 - &quot;a&quot;、&quot;ab&quot;、&quot;ba&quot; 和 &quot;a&quot; 每个都有 1 个元音 - &quot;aba&quot; 中有 2 个元音 因此，元音总数 = 0 + 1 + 1 + 1 + 1 + 2 = 6 。 示例 2： 输入：word = &quot;abc&quot; 输出：3 解释： 所有子字符串是：&quot;a&quot;、&quot;ab&quot;、&quot;abc&quot;、&quot;b&quot;、&quot;bc&quot; 和 &quot;c&quot; 。 - &quot;a&quot;、&quot;ab&quot; 和 &quot;abc&quot; 每个都有 1 个元音 - &quot;b&quot;、&quot;bc&quot; 和 &quot;c&quot; 每个都有 0 个元音 因此，元音总数 = 1 + 1 + 1 + 0 + 0 + 0 = 3 。 示例 3： 输入：word = &quot;ltcd&quot; 输出：0 解释：&quot;ltcd&quot; 的子字符串均不含元音。 示例 4： 输入：word = &quot;noosabasboosa&quot; 输出：237 解释：所有子字符串中共有 237 个元音。 提示： 1 &lt;= word.length &lt;= 10^5 word 由小写英文字母组成 分析：统计每个元音出现的次数 先倒序遍历一遍字符串，可以得到每个元音在一次遍历过程中出现的次数 正序遍历一遍字符串，对每一个下标i有两种可能： 元音，从i+1为头组成的子字符串和从i为头的组成的子字符串的区别为少了一组以元音为头的子字符串，也就是少了word.size()-i个元音 非元音，没有减少元音数量 代码：class Solution { public: long long countVowels(string word) { long long ret = 0; vector&lt;int&gt; v(word.size(), 0); long long n = 0; vector&lt;char&gt; vc{&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;}; for(int i = 0; i &lt; word.size(); i++){ bool b = false; for(int j = 0; j &lt; 5; j++){ if(word[i] == vc[j]){ b = true; break; } } if(b){ v[i] = word.size() - i; n += v[i]; } } ret += n; for(int i = 0; i &lt; word.size(); i++){ int b = false; if(v[i] &gt; 0){ n -= v[i]; } ret += n; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/vowels-of-all-substrings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[5918. 统计字符串中的元音子字符串]]></title>
    <url>%2F2021%2F11%2F08%2Fleetcode%205918.%20%E7%BB%9F%E8%AE%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：子字符串 是字符串中的一个连续（非空）的字符序列。 元音子字符串 是 仅 由元音（’a’、’e’、’i’、’o’ 和 ‘u’）组成的一个子字符串，且必须包含 全部五种 元音。 给你一个字符串 word ，统计并返回 word 中 元音子字符串的数目 。 示例：示例 1： 输入：word = &quot;aeiouu&quot; 输出：2 解释：下面列出 word 中的元音子字符串（斜体加粗部分）： - &quot;aeiouu&quot; - &quot;aeiouu&quot; 示例 2： 输入：word = &quot;unicornarihan&quot; 输出：0 解释：word 中不含 5 种元音，所以也不会存在元音子字符串。 示例 3： 输入：word = &quot;cuaieuouac&quot; 输出：7 解释：下面列出 word 中的元音子字符串（斜体加粗部分）： - &quot;cuaieuouac&quot; - &quot;cuaieuouac&quot; - &quot;cuaieuouac&quot; - &quot;cuaieuouac&quot; - &quot;cuaieuouac&quot; - &quot;cuaieuouac&quot; - &quot;cuaieuouac&quot; 示例 4： 输入：word = &quot;bbaeixoubb&quot; 输出：0 解释：所有包含全部五种元音的子字符串都含有辅音，所以不存在元音子字符串。 提示： 1 &lt;= word.length &lt;= 100 word 仅由小写英文字母组成 分析：双重循环遍历，枚举所有子串 代码：class Solution { public: int countVowelSubstrings(string word) { vector&lt;char&gt; vc{&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;}; int ret = 0; for(int i = 0; i &lt; word.size(); i++){ map&lt;char, int&gt; m; bool b = true; for(int j = i; j &lt; word.size(); j++){ b = true; for(int k = 0; k &lt; 5; k++){ if(word[j] == vc[k]){ m[word[j]] = 1; b = false; if(m.size() == 5) ret++; break; } } if(b){ break; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-vowel-substrings-of-a-string/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5917. 同源字符串检测]]></title>
    <url>%2F2021%2F11%2F01%2Fleetcode%205917.%20%E5%90%8C%E6%BA%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[题目：原字符串由小写字母组成，可以按下述步骤编码： 任意将其 分割 为由若干 非空 子字符串组成的一个 序列 。 任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。 重新 顺次连接 序列，得到编码后的字符串。 例如，编码 “abcdefghijklmnop” 的一种方法可以描述为： 将原字符串分割得到一个序列：[“ab”, “cdefghijklmn”, “o”, “p”] 。 选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 [“ab”, “12”, “1”, “p”] 。 重新顺次连接序列中的元素，得到编码后的字符串：”ab121p” 。 给你两个编码后的字符串 s1 和 s2 ，由小写英文字母和数字 1-9 组成。如果存在能够同时编码得到 s1 和 s2 原字符串，返回 true ；否则，返回 false。 注意：生成的测试用例满足 s1 和 s2 中连续数字数不超过 3 。 示例：示例 1： 输入：s1 = &quot;internationalization&quot;, s2 = &quot;i18n&quot; 输出：true 解释：&quot;internationalization&quot; 可以作为原字符串 - &quot;internationalization&quot; -&gt; 分割： [&quot;internationalization&quot;] -&gt; 不替换任何元素 -&gt; 连接： &quot;internationalization&quot;，得到 s1 - &quot;internationalization&quot; -&gt; 分割： [&quot;i&quot;, &quot;nternationalizatio&quot;, &quot;n&quot;] -&gt; 替换： [&quot;i&quot;, &quot;18&quot;, &quot;n&quot;] -&gt; 连接： &quot;i18n&quot;，得到 s2 示例 2： 输入：s1 = &quot;l123e&quot;, s2 = &quot;44&quot; 输出：true 解释：&quot;leetcode&quot; 可以作为原字符串 - &quot;leetcode&quot; -&gt; 分割： [&quot;l&quot;, &quot;e&quot;, &quot;et&quot;, &quot;cod&quot;, &quot;e&quot;] -&gt; 替换： [&quot;l&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;e&quot;] -&gt; 连接： &quot;l123e&quot;，得到 s1 - &quot;leetcode&quot; -&gt; 分割： [&quot;leet&quot;, &quot;code&quot;] -&gt; 替换： [&quot;4&quot;, &quot;4&quot;] -&gt; 连接： &quot;44&quot;，得到 s2 示例 3： 输入：s1 = &quot;a5b&quot;, s2 = &quot;c5b&quot; 输出：false 解释：不存在这样的原字符串 - 编码为 s1 的字符串必须以字母 &apos;a&apos; 开头 - 编码为 s2 的字符串必须以字母 &apos;c&apos; 开头 示例 4： 输入：s1 = &quot;112s&quot;, s2 = &quot;g841&quot; 输出：true 解释：&quot;gaaaaaaaaaaaas&quot; 可以作为原字符串 - &quot;gaaaaaaaaaaaas&quot; -&gt; 分割： [&quot;g&quot;, &quot;aaaaaaaaaaaa&quot;, &quot;s&quot;] -&gt; 替换： [&quot;1&quot;, &quot;12&quot;, &quot;s&quot;] -&gt; 连接： &quot;112s&quot;，得到 s1 - &quot;gaaaaaaaaaaaas&quot; -&gt; 分割： [&quot;g&quot;, &quot;aaaaaaaa&quot;, &quot;aaaa&quot;, &quot;s&quot;] -&gt; 替换： [&quot;g&quot;, &quot;8&quot;, &quot;4&quot;, &quot;1&quot;] -&gt; 连接 &quot;g841&quot;，得到 s2 示例 5： 输入：s1 = &quot;ab&quot;, s2 = &quot;a2&quot; 输出：false 解释：不存在这样的原字符串 - 编码为 s1 的字符串由两个字母组成 - 编码为 s2 的字符串由三个字母组成 提示： 1 &lt;= s1.length, s2.length &lt;= 40 s1 和 s2 仅由数字 1-9 和小写英文字母组成 s1 和 s2 中连续数字数不超过 3 分析：使用dfs进行搜索 具体见代码 代码：class Solution { private: set&lt;vector&lt;int&gt;&gt; sv; string s1; string s2; public: // a1 表示当前比对到s1字符串的第a1位， a2 表示当前比对到s2字符串的第a2位 // b1 表示拆开的数字还有b1个字符没有比对， b2 表示拆开的数字还有b2个字符没有比对 bool dfs(int a1, int a2, int b1, int b2){ // 如果两个都还有数字转换的字符没有比对 if(b1 &amp;&amp; b2){ int m = min(b1, b2); b1 -= m; b2 -= m; } // 两个中有一个还有数字转换的字符没有比对 while(b1 || b2){ if(b1 &gt; 0 &amp;&amp; a2 &lt; s2.size() &amp;&amp; !isdigit(s2[a2])){ b1--; a2++; } else if(b2 &gt; 0 &amp;&amp; a1 &lt; s1.size() &amp;&amp; !isdigit(s1[a1])){ b2--; a1++; } else break; } // 两个字符串需要比对的均为字母 while(a1 &lt; s1.size() &amp;&amp; a2 &lt; s2.size() &amp;&amp; b1 == 0 &amp;&amp; b2 == 0 &amp;&amp; !isdigit(s1[a1]) &amp;&amp; !isdigit(s2[a2]) &amp;&amp; s1[a1] == s2[a2]){ a1++; a2++; } // 防止重复计算 if(sv.count(vector&lt;int&gt;{a1, a2, b1, b2})) return false; sv.insert(vector&lt;int&gt;{a1, a2, b1, b2}); // 退出条件 if(a1 == s1.size() &amp;&amp; a2 == s2.size() &amp;&amp; b1 == 0 &amp;&amp; b2 == 0) return true; // 将s1中当前遍历到的数字拆开 if(a1 &lt; s1.size() &amp;&amp; isdigit(s1[a1])){ int n = 0; for(int i = 0; a1+i &lt; s1.size() &amp;&amp; isdigit(s1[a1+i]); i++){ n = n*10 + (s1[a1+i] - &apos;0&apos;); if(dfs(a1+i+1, a2, n+b1, b2)) return true; } } // 将s2中当前遍历到的数字拆开 if(a2 &lt; s2.size() &amp;&amp; isdigit(s2[a2])){ int n = 0; for(int i = 0; a2+i &lt; s2.size() &amp;&amp; isdigit(s2[a2+i]); i++){ n = n*10 + (s2[a2+i] - &apos;0&apos;); if(dfs(a1, a2+i+1, b1, n+b2)) return true; } } return false; } bool possiblyEquals(string s1, string s2) { this-&gt;s1 = s1; this-&gt;s2 = s2; return dfs(0,0,0,0); } }; 题目地址:https://leetcode-cn.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5916. 转化数字的最小运算数]]></title>
    <url>%2F2021%2F11%2F01%2Fleetcode%205916.%20%E8%BD%AC%E5%8C%96%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%B0%8F%E8%BF%90%E7%AE%97%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的整数数组 nums ，该数组由 互不相同 的数字组成。另给你两个整数 start 和 goal 。 整数 x 的值最开始设为 start ，你打算执行一些运算使 x 转化为 goal 。你可以对数字 x 重复执行下述运算： 如果 0 &lt;= x &lt;= 1000 ，那么，对于数组中的任一下标 i（0 &lt;= i &lt; nums.length），可以将 x 设为下述任一值： x + nums[i] x - nums[i] x ^ nums[i]（按位异或 XOR） 注意，你可以按任意顺序使用每个 nums[i] 任意次。使 x 越过 0 &lt;= x &lt;= 1000 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。 返回将 x = start 转化为 goal 的最小操作数；如果无法完成转化，则返回 -1 。 示例：示例 1： 输入：nums = [1,3], start = 6, goal = 4 输出：2 解释： 可以按 6 → 7 → 4 的转化路径进行，只需执行下述 2 次运算： - 6 ^ 1 = 7 - 7 ^ 3 = 4 示例 2： 输入：nums = [2,4,12], start = 2, goal = 12 输出：2 解释： 可以按 2 → 14 → 12 的转化路径进行，只需执行下述 2 次运算： - 2 + 12 = 14 - 14 - 2 = 12 示例 3： 输入：nums = [3,5,7], start = 0, goal = -4 输出：2 解释： 可以按 0 → 3 → -4 的转化路径进行，只需执行下述 2 次运算： - 0 + 3 = 3 - 3 - 7 = -4 注意，最后一步运算使 x 超过范围 0 &lt;= x &lt;= 1000 ，但该运算仍然可以生效。 示例 4： 输入：nums = [2,8,16], start = 0, goal = 1 输出：-1 解释： 无法将 0 转化为 1 示例 5： 输入：nums = [1], start = 0, goal = 3 输出：3 解释： 可以按 0 → 1 → 2 → 3 的转化路径进行，只需执行下述 3 次运算： - 0 + 1 = 1 - 1 + 1 = 2 - 2 + 1 = 3 提示： 1 &lt;= nums.length &lt;= 1000 -109 &lt;= nums[i], goal &lt;= 10^9 0 &lt;= start &lt;= 1000 start != goal nums 中的所有整数互不相同 分析：使用BFS 将start加入队列 对队列中的数字进行运算，将运算后的数字用另一组数组保存，等队列清空后放入队列（目的是为了记录操作数） 使用一个map来保证每个数字只进行一次运算（没必要重复运算） 代码：class Solution { public: int minimumOperations(vector&lt;int&gt;&amp; nums, int start, int goal) { unordered_map&lt;int, int&gt; m; m[start] = 1; int ret = 0; bool b = true; while(b){ b = false; ret++; vector&lt;int&gt; v; for(auto a = m.begin(); a != m.end(); a++){ int f = a-&gt;first; if(a-&gt;second == 0) continue; a-&gt;second = 0; for(int j = 0; j &lt; nums.size(); j++){ if(f + nums[j] == goal) return ret; if(f + nums[j] &lt;= 1000 &amp;&amp; f + nums[j] &gt;= 0 &amp;&amp; m.count(f + nums[j]) == 0) v.push_back(f + nums[j]); if(f - nums[j] == goal) return ret; if(f - nums[j] &lt;= 1000 &amp;&amp; f - nums[j] &gt;= 0 &amp;&amp; m.count(f - nums[j]) == 0) v.push_back(f - nums[j]); if((f ^ nums[j]) == goal) return ret; if((f ^ nums[j]) &gt;= 0 &amp;&amp; (f ^ nums[j]) &lt;= 1000 &amp;&amp; m.count(f ^ nums[j]) == 0) v.push_back(f ^ nums[j]); } } for(int i = 0; i &lt; v.size(); i++){ m[v[i]] = 1; } if(v.size() &gt; 0){ b = true; } } return -1; } }; 题目地址:https://leetcode-cn.com/problems/minimum-operations-to-convert-number/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5915. 找出临界点之间的最小和最大距离]]></title>
    <url>%2F2021%2F11%2F01%2Fleetcode%205915.%20%E6%89%BE%E5%87%BA%E4%B8%B4%E7%95%8C%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%B0%8F%E5%92%8C%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题目：链表中的 临界点 定义为一个 局部极大值点 或 局部极小值点 。 如果当前节点的值 严格大于 前一个节点和后一个节点，那么这个节点就是一个 局部极大值点 。 如果当前节点的值 严格小于 前一个节点和后一个节点，那么这个节点就是一个 局部极小值点 。 注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 局部极大值点 / 极小值点 。 给你一个链表 head ，返回一个长度为 2 的数组 [minDistance, maxDistance] ，其中 minDistance 是任意两个不同临界点之间的最小距离，maxDistance 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 [-1，-1] 。 示例：示例 1： 输入：head = [3,1] 输出：[-1,-1] 解释：链表 [3,1] 中不存在临界点。 示例 2： 输入：head = [5,3,1,2,5,1,2] 输出：[1,3] 解释：存在三个临界点： - [5,3,1,2,5,1,2]：第三个节点是一个局部极小值点，因为 1 比 3 和 2 小。 - [5,3,1,2,5,1,2]：第五个节点是一个局部极大值点，因为 5 比 2 和 1 大。 - [5,3,1,2,5,1,2]：第六个节点是一个局部极小值点，因为 1 比 5 和 2 小。 第五个节点和第六个节点之间距离最小。minDistance = 6 - 5 = 1 。 第三个节点和第六个节点之间距离最大。maxDistance = 6 - 3 = 3 。 示例 3： 输入：head = [1,3,2,2,3,2,2,2,7] 输出：[3,3] 解释：存在两个临界点： - [1,3,2,2,3,2,2,2,7]：第二个节点是一个局部极大值点，因为 3 比 1 和 2 大。 - [1,3,2,2,3,2,2,2,7]：第五个节点是一个局部极大值点，因为 3 比 2 和 2 大。 最小和最大距离都存在于第二个节点和第五个节点之间。 因此，minDistance 和 maxDistance 是 5 - 2 = 3 。 注意，最后一个节点不算一个局部极大值点，因为它之后就没有节点了。 示例 4： 输入：head = [2,3,3,2] 输出：[-1,-1] 解释：链表 [2,3,3,2] 中不存在临界点。 提示： 链表中节点的数量在范围 [2, 105] 内 1 &lt;= Node.val &lt;= 10^5 分析：转换成数组形式，按规则找出临界点。 遍历一遍临界点，找出最大距离和最小距离 代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: vector&lt;int&gt; nodesBetweenCriticalPoints(ListNode* head) { ListNode* h = head; vector&lt;int&gt; v; vector&lt;int&gt; v1; while(h != NULL){ v.push_back(h-&gt;val); h = h-&gt;next; } for(int i = 1; i &lt; v.size()-1; i++){ if(v[i] &gt; v[i-1] &amp;&amp; v[i] &gt; v[i+1]){ v1.push_back(i); } if(v[i] &lt; v[i-1] &amp;&amp; v[i] &lt; v[i+1]){ v1.push_back(i); } } if(v1.size() &lt; 2) return vector&lt;int&gt;{-1, -1}; int mi = INT_MAX; for(int i = 1; i &lt; v1.size(); i++){ if(mi &gt; v1[i] - v1[i-1]){ mi = v1[i] - v1[i-1]; } } vector&lt;int&gt; ret{mi, v1[v1.size()-1] - v1[0]}; return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5914. 值相等的最小索引]]></title>
    <url>%2F2021%2F11%2F01%2Fleetcode%205914.%20%E5%80%BC%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的整数数组 nums ，返回 nums 中满足 i mod 10 == nums[i] 的最小下标 i ；如果不存在这样的下标，返回 -1 。 x mod y 表示 x 除以 y 的 余数 。 示例：示例 1： 输入：nums = [0,1,2] 输出：0 解释： i=0: 0 mod 10 = 0 == nums[0]. i=1: 1 mod 10 = 1 == nums[1]. i=2: 2 mod 10 = 2 == nums[2]. 所有下标都满足 i mod 10 == nums[i] ，所以返回最小下标 0 示例 2： 输入：nums = [4,3,2,1] 输出：2 解释： i=0: 0 mod 10 = 0 != nums[0]. i=1: 1 mod 10 = 1 != nums[1]. i=2: 2 mod 10 = 2 == nums[2]. i=3: 3 mod 10 = 3 != nums[3]. 2 唯一一个满足 i mod 10 == nums[i] 的下标 示例 3： 输入：nums = [1,2,3,4,5,6,7,8,9,0] 输出：-1 解释：不存在满足 i mod 10 == nums[i] 的下标 示例 4： 输入：nums = [2,1,3,5,2] 输出：1 解释：1 是唯一一个满足 i mod 10 == nums[i] 的下标 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 9 分析：按题目要求遍历一遍 代码：class Solution { public: int smallestEqual(vector&lt;int&gt;&amp; nums) { for(int i = 0; i &lt; nums.size(); i++){ if(i % 10 == nums[i]){ return i; } } return -1; } }; 题目地址:https://leetcode-cn.com/problems/smallest-index-with-equal-value/solution/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5909. 并行课程 III]]></title>
    <url>%2F2021%2F10%2F25%2Fleetcode%205909.%20%E5%B9%B6%E8%A1%8C%E8%AF%BE%E7%A8%8B%20III%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n 。同时给你一个二维整数数组 relations ，其中 relations[j] = [prevCoursej, nextCoursej] ，表示课程 prevCoursej 必须在课程 nextCoursej 之前 完成（先修课的关系）。同时给你一个下标从 0 开始的整数数组 time ，其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数。 请你根据以下规则算出完成所有课程所需要的 最少 月份数： 如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。 你可以 同时 上 任意门课程 。 请你返回完成所有课程所需要的 最少 月份数。 注意：测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。 示例：示例 1: 输入：n = 3, relations = [[1,3],[2,3]], time = [3,2,5] 输出：8 解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。 你可以在月份 0 同时开始课程 1 和 2 。 课程 1 花费 3 个月，课程 2 花费 2 个月。 所以，最早开始课程 3 的时间是月份 3 ，完成所有课程所需时间为 3 + 5 = 8 个月。 示例 2： 输入：n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5] 输出：12 解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。 你可以在月份 0 同时开始课程 1 ，2 和 3 。 在月份 1，2 和 3 分别完成这三门课程。 课程 4 需在课程 3 之后开始，也就是 3 个月后。课程 4 在 3 + 4 = 7 月完成。 课程 5 需在课程 1，2，3 和 4 之后开始，也就是在 max(1,2,3,7) = 7 月开始。 所以完成所有课程所需的最少时间为 7 + 5 = 12 个月。 提示： 1 &lt;= n &lt;= 5 * 10^4 0 &lt;= relations.length &lt;= min(n (n - 1) / 2, 5 104) relations[j].length == 2 1 &lt;= prevCoursej, nextCoursej &lt;= n prevCoursej != nextCoursej 所有的先修课程对 [prevCoursej, nextCoursej] 都是 互不相同 的。 time.length == n 1 &lt;= time[i] &lt;= 10^4 先修课程图是一个有向无环图。 分析：使用拓扑排序，对每一个结点记录结束时间，返回最后一个结束的结点时间。 代码：class Solution { public: int minimumTime(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relations, vector&lt;int&gt;&amp; time) { int ret = 0; map&lt;int, int&gt; m; map&lt;int, vector&lt;int&gt;&gt; mnext; queue&lt;int&gt; q; map&lt;int, int&gt; mtime; for(int i = 0; i &lt; relations.size(); i++){ m[relations[i][1]]++; mnext[relations[i][0]].push_back(relations[i][1]); } for(int i = 1; i &lt;= n; i++){ if(m[i] == 0){ q.push(i); } } while(q.size()){ int f = q.front(); q.pop(); for(int i = 0; i &lt; mnext[f].size(); i++){ mtime[mnext[f][i]] = max(mtime[mnext[f][i]], mtime[f] + time[f-1]); m[mnext[f][i]]--; if(m[mnext[f][i]] == 0) q.push(mnext[f][i]); } ret = max(ret, mtime[f] + time[f-1]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/parallel-courses-iii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5908. 统计最高分的节点数目]]></title>
    <url>%2F2021%2F10%2F25%2Fleetcode%205908.%20%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。 一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。 请你返回有 最高得分 节点的 数目 。 示例：示例 1: 输入：parents = [-1,2,0,2,0] 输出：3 解释： - 节点 0 的分数为：3 * 1 = 3 - 节点 1 的分数为：4 = 4 - 节点 2 的分数为：1 * 1 * 2 = 2 - 节点 3 的分数为：4 = 4 - 节点 4 的分数为：4 = 4 最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。 示例 2： 输入：parents = [-1,2,0] 输出：2 解释： - 节点 0 的分数为：2 = 2 - 节点 1 的分数为：2 = 2 - 节点 2 的分数为：1 * 1 = 1 最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。 提示： n == parents.length 2 &lt;= n &lt;= 10^5 parents[0] == -1 对于 i != 0 ，有 0 &lt;= parents[i] &lt;= n - 1 parents 表示一棵二叉树。 分析：使用dfs遍历整棵树，对每个节点进行左子树 * 右子树 *（总节点数-左子树-右子树-1） 统计出最高得分的结点数目 代码：class Solution { private: long long ma; int ret; int s; public: int dfs(map&lt;int, vector&lt;int&gt;&gt;&amp; m, int n){ int a[2] = {0, 0}; for(int i = 0; i &lt; m[n].size(); i++){ a[i] = dfs(m, m[n][i]); } int l = a[0]; int r = a[1]; int p = s-1-a[0]-a[1]; if(l == 0) l = 1; if(r == 0) r = 1; if(p == 0) p = 1; long long j = (long long)(l) * r * p; if(j == ma){ ret++; } if(j &gt; ma){ ret = 1; ma = j; } return a[0]+a[1]+1; } int countHighestScoreNodes(vector&lt;int&gt;&amp; parents) { s = parents.size(); ma = 0; ret = 0; map&lt;int, vector&lt;int&gt;&gt; m; for(int i = 1; i &lt; parents.size(); i++){ m[parents[i]].push_back(i); } dfs(m, 0); return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5907. 下一个更大的数值平衡数]]></title>
    <url>%2F2021%2F10%2F25%2Fleetcode%205907.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%95%B0%E5%80%BC%E5%B9%B3%E8%A1%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：如果整数 x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。 给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。 示例：示例 1： 输入：n = 1 输出：22 解释： 22 是一个数值平衡数，因为： - 数字 2 出现 2 次 这也是严格大于 1 的最小数值平衡数。 示例 2： 输入：n = 1000 输出：1333 解释： 1333 是一个数值平衡数，因为： - 数字 1 出现 1 次。 - 数字 3 出现 3 次。 这也是严格大于 1000 的最小数值平衡数。 注意，1022 不能作为本输入的答案，因为数字 0 的出现次数超过了 0 。 示例 3： 输入：n = 3000 输出：3133 解释： 3133 是一个数值平衡数，因为： - 数字 1 出现 1 次。 - 数字 3 出现 3 次。 这也是严格大于 3000 的最小数值平衡数。 提示： 0 &lt;= n &lt;= 10^6 分析：暴力遍历找出合适的数 代码：class Solution { public: int nextBeautifulNumber(int n) { for(int i = n+1; 1; i++){ string str = to_string(i); vector&lt;int&gt; m(10, 0); bool b = true;; for(int j = 0; j &lt; str.size(); j++){ m[str[j]-&apos;0&apos;]++; } for(int j = 0; j &lt; str.size(); j++){ if(m[str[j]-&apos;0&apos;] != str[j]-&apos;0&apos;){ b = false; break; } } if(b) return i; } return 0; } }; 题目地址:https://leetcode-cn.com/problems/next-greater-numerically-balanced-number/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5906. 句子中的有效单词数]]></title>
    <url>%2F2021%2F10%2F25%2Fleetcode%205906.%20%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：句子仅由小写字母（’a’ 到 ‘z’）、数字（’0’ 到 ‘9’）、连字符（’-‘）、标点符号（’!’、’.’ 和 ‘,’）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。 如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词： 仅由小写字母、连字符和/或标点（不含数字）。 至多一个 连字符 ‘-‘ 。如果存在，连字符两侧应当都存在小写字母（”a-b” 是一个有效单词，但 “-ab” 和 “ab-“ 不是有效单词）。 至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。 这里给出几个有效单词的例子：”a-b.”、”afad”、”ba-c”、”a!” 和 “!” 。 给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。 示例：示例 1： 输入：sentence = &quot;cat and dog&quot; 输出：3 解释：句子中的有效单词是 &quot;cat&quot;、&quot;and&quot; 和 &quot;dog&quot; 示例 2： 输入：sentence = &quot;!this 1-s b8d!&quot; 输出：0 解释：句子中没有有效单词 &quot;!this&quot; 不是有效单词，因为它以一个标点开头 &quot;1-s&quot; 和 &quot;b8d&quot; 也不是有效单词，因为它们都包含数字 示例 3： 输入：sentence = &quot;alice and bob are playing stone-game10&quot; 输出：5 解释：句子中的有效单词是 &quot;alice&quot;、&quot;and&quot;、&quot;bob&quot;、&quot;are&quot; 和 &quot;playing&quot; &quot;stone-game10&quot; 不是有效单词，因为它含有数字 示例 4： 输入：sentence = &quot;he bought 2 pencils, 3 erasers, and 1 pencil-sharpener.&quot; 输出：6 解释：句子中的有效单词是 &quot;he&quot;、&quot;bought&quot;、&quot;pencils,&quot;、&quot;erasers,&quot;、&quot;and&quot; 和 &quot;pencil-sharpener.&quot; 提示： 1 &lt;= sentence.length &lt;= 1000 sentence 由小写英文字母、数字（0-9）、以及字符（’ ‘、’-‘、’!’、’.’ 和 ‘,’）组成 句子中至少有 1 个 token 分析：按照规则编写 代码：class Solution { public: int countValidWords(string sentence) { vector&lt;string&gt; v; string str; int ret = 0; for(int i = 0; i &lt; sentence.size(); i++){ if(sentence[i] == &apos; &apos;){ if(str.size() != 0){ v.push_back(str); str = &quot;&quot;; } } else{ str += sentence[i]; } } if(str.size() != 0) v.push_back(str); for(int i = 0; i &lt; v.size(); i++){ bool b = true; int a1 = 0; int a2 = 0; for(int j = 0; j &lt; v[i].size(); j++){ if(v[i][j] &gt;= &apos;0&apos; &amp;&amp; v[i][j] &lt;= &apos;9&apos;){ b = false; break; } else if(v[i][j] == &apos;-&apos;){ a1++; if(j == 0 || j == v[i].size()-1 || a1&gt;1 || v[i][j-1] &lt; &apos;a&apos; || v[i][j-1] &gt; &apos;z&apos; || v[i][j+1] &lt; &apos;a&apos; || v[i][j+1] &gt; &apos;z&apos;){ b = false; break; } } else if(v[i][j] == &apos;!&apos; || v[i][j] == &apos;,&apos; || v[i][j] == &apos;.&apos;){ a2++; if(j != v[i].size()-1 || a2&gt;1){ b = false; break; } } } if(b) ret++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5866. 数组的最大公因数排序]]></title>
    <url>%2F2021%2F09%2F06%2Fleetcode%205866.%20%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums ，你可以在 nums 上执行下述操作 任意次 ： 如果 gcd(nums[i], nums[j]) &gt; 1 ，交换 nums[i] 和 nums[j] 的位置。其中 gcd(nums[i], nums[j]) 是 nums[i] 和 nums[j] 的最大公因数。如果能使用上述交换方式将 nums 按 非递减顺序 排列，返回 true ；否则，返回 false 。 示例：示例 1： 输入：nums = [7,21,3] 输出：true 解释：可以执行下述操作完成对 [7,21,3] 的排序： - 交换 7 和 21 因为 gcd(7,21) = 7 。nums = [21,7,3] - 交换 21 和 3 因为 gcd(21,3) = 3 。nums = [3,7,21] 示例 2： 输入：nums = [5,2,6,2] 输出：false 解释：无法完成排序，因为 5 不能与其他元素交换。 示例 3： 输入：nums = [10,5,9,3,15] 输出：true 解释： 可以执行下述操作完成对 [10,5,9,3,15] 的排序： - 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [15,5,9,3,10] - 交换 15 和 3 因为 gcd(15,3) = 3 。nums = [3,5,9,15,10] - 交换 10 和 15 因为 gcd(10,15) = 5 。nums = [3,5,9,10,15] 提示： 1 &lt;= nums.length &lt;= 3 * 10^4 2 &lt;= nums[i] &lt;= 10^5 分析：使用并查集就可以得知哪些数可以交换 当想要添加一个数进并查集时，将这个数的质因数和自身一起加入并查集，这样就可以不用O（n^2）的时间去比对两数最大公因数是否大于1 代码：class Solution { unordered_map&lt;int, int&gt; fa; public: vector&lt;int&gt; isPrime(int n){ vector&lt;int&gt; v; while (n &gt; 1){ bool b = false; for (int i = 2; i*i &lt;= n; i++){ if (n % i == 0){ n = n / i; v.push_back(i); b = true; break; } } if(!b){ v.push_back(n); break; } } return v; } int find(int x){ if(x == fa[x]) return x; else{ fa[x] = find(fa[x]); //父节点设为根节点 return fa[x]; //返回父节点 } } inline void merge(int i, int j){ fa[find(i)] = find(j); } bool gcdSort(vector&lt;int&gt;&amp; nums) { for(int i = 0; i &lt; nums.size(); i++){ fa[nums[i]] = nums[i]; } for(int i = 0; i &lt; nums.size(); i++){ vector&lt;int&gt; v = isPrime(nums[i]); for(auto a : v){ if(fa.count(a) == 0){ fa[a] = a; } merge(a, nums[i]); } } vector&lt;int&gt; nums1 = nums; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); i++){ if(find(nums[i]) != find(nums1[i])) return false; } return true; } }; 题目地址:https://leetcode-cn.com/problems/gcd-sort-of-an-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5865. 访问完所有房间的第一天]]></title>
    <url>%2F2021%2F09%2F06%2Fleetcode%205865.%20%E8%AE%BF%E9%97%AE%E5%AE%8C%E6%89%80%E6%9C%89%E6%88%BF%E9%97%B4%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[题目：你需要访问 n 个房间，房间从 0 到 n - 1 编号。同时，每一天都有一个日期编号，从 0 开始，依天数递增。你每天都会访问一个房间。 最开始的第 0 天，你访问 0 号房间。给你一个长度为 n 且 下标从 0 开始 的数组 nextVisit 。在接下来的几天中，你访问房间的 次序 将根据下面的 规则 决定： 假设某一天，你访问 i 号房间。 如果算上本次访问，访问 i 号房间的次数为 奇数 ，那么 第二天 需要访问 nextVisit[i] 所指定的房间，其中 0 &lt;= nextVisit[i] &lt;= i 。 如果算上本次访问，访问 i 号房间的次数为 偶数 ，那么 第二天 需要访问 (i + 1) mod n 号房间。 请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。由于答案可能很大，返回对 109 + 7 取余后的结果。 示例：示例 1： 输入：nextVisit = [0,0] 输出：2 解释： - 第 0 天，你访问房间 0 。访问 0 号房间的总次数为 1 ，次数为奇数。 下一天你需要访问房间的编号是 nextVisit[0] = 0 - 第 1 天，你访问房间 0 。访问 0 号房间的总次数为 2 ，次数为偶数。 下一天你需要访问房间的编号是 (0 + 1) mod 2 = 1 - 第 2 天，你访问房间 1 。这是你第一次完成访问所有房间的那天。 示例 2： 输入：nextVisit = [0,0,2] 输出：6 解释： 你每天访问房间的次序是 [0,0,1,0,0,1,2,...] 。 第 6 天是你访问完所有房间的第一天。 示例 3： 输入：nextVisit = [0,1,2,0] 输出：6 解释： 你每天访问房间的次序是 [0,0,1,1,2,2,3,...] 。 第 6 天是你访问完所有房间的第一天。 提示： n == nextVisit.length 2 &lt;= n &lt;= 10^5 0 &lt;= nextVisit[i] &lt;= i 分析：动态规划 dp[i]，表示到第i个房间需要天数 每个房间只有偶数次才可以前进，所以走过的房间都是偶数次 每次从当前房间（i-1）到下一个房间需要折返回之前的房间（j），从j房间回到房间i-1需要，dp[i-1]-dp[j]天，那么从房间i-1到房间i需要： 到达房间i-1的天数 + 折返到房间j需要1天 + 回到房间i-1需要的天数 + 到房间i需要1天 dp[i] = dp[i-1] + 1 + (dp[i-1]-dp[nextVisit[i-1]]) + 1 代码：class Solution { public: int firstDayBeenInAllRooms(vector&lt;int&gt;&amp; nextVisit) { vector&lt;long long&gt; dp(nextVisit.size(), 0); for(int i = 1; i &lt; nextVisit.size(); i++){ dp[i] = (dp[i-1] + 2 + (dp[i-1] - dp[nextVisit[i-1]])) % 1000000007; if(dp[i] &lt; 0) dp[i] += 1000000007; } return dp[nextVisit.size()-1]; } }; 题目地址:https://leetcode-cn.com/problems/first-day-where-you-have-been-in-all-the-rooms/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5864. 游戏中弱角色的数量]]></title>
    <url>%2F2021%2F09%2F06%2Fleetcode%205864.%20%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attacki, defensei] 表示游戏中第 i 个角色的属性。 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackj &gt; attacki 且 defensej &gt; defensei 。 返回 弱角色 的数量。 示例：示例 1： 输入：properties = [[5,5],[6,3],[3,6]] 输出：0 解释：不存在攻击和防御都严格高于其他角色的角色。 示例 2： 输入：properties = [[2,2],[3,3]] 输出：1 解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 示例 3： 输入：properties = [[1,5],[10,4],[4,3]] 输出：1 解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。 提示： 2 &lt;= properties.length &lt;= 10^5 properties[i].length == 2 1 &lt;= attacki, defensei &lt;= 10^5 分析：使用multiset存储所有防御属性 原数组按照攻击属性排序 遍历原数组，每次从multiset数组中删除攻击等于当前数值的角色的防御，删除后如果还有防御大于当前角色，则当前角色是弱角色 更好的方法，一次遍历：https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/solution/jian-ji-xie-fa-pai-xu-yi-ci-bian-li-by-e-unnb/ 代码：bool bj(vector&lt;int&gt;&amp; a1, vector&lt;int&gt;&amp; a2){ return a1[0] &lt; a2[0]; } class Solution { public: int numberOfWeakCharacters(vector&lt;vector&lt;int&gt;&gt;&amp; properties) { multiset&lt;int&gt; s; int ret = 0; sort(properties.begin(), properties.end(), bj); for(int i = 0; i &lt; properties.size(); i++){ s.insert(properties[i][1]); } for(int i = 0; i &lt; properties.size(); i++){ if(i == 0 || properties[i][0] != properties[i-1][0]){ for(int j = i; j == i || (j &lt; properties.size() &amp;&amp; properties[j][0] == properties[j-1][0]); j++){ s.erase(s.find(properties[j][1])); } } auto a = s.equal_range(properties[i][1]+1); if(a.first != s.end() || a.second != s.end()) ret++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5863. 统计特殊四元组]]></title>
    <url>%2F2021%2F09%2F06%2Fleetcode%205863.%20%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E5%9B%9B%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ： nums[a] + nums[b] + nums[c] == nums[d] ，且 a &lt; b &lt; c &lt; d 示例：示例 1： 输入：nums = [1,2,3,6] 输出：1 解释：满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。 示例 2： 输入：nums = [3,3,6,4,5] 输出：0 解释：[3,3,6,4,5] 中不存在满足要求的四元组。 示例 3： 输入：nums = [1,1,1,3,5] 输出：4 解释：满足要求的 4 个四元组如下： - (0, 1, 2, 3): 1 + 1 + 1 == 3 - (0, 1, 3, 4): 1 + 1 + 3 == 5 - (0, 2, 3, 4): 1 + 1 + 3 == 5 - (1, 2, 3, 4): 1 + 1 + 3 == 5 提示： 4 &lt;= nums.length &lt;= 50 1 &lt;= nums[i] &lt;= 100 分析：四重循环暴力解决 代码：class Solution { public: int countQuadruplets(vector&lt;int&gt;&amp; nums) { int ret = 0; for(int i = 0; i &lt; nums.size(); i++){ for(int j = i+1; j &lt; nums.size(); j++){ for(int k = j+1; k &lt; nums.size(); k++){ for(int l = k+1; l &lt; nums.size(); l++){ if(nums[i] + nums[j] + nums[k] == nums[l]){ ret++; } } } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-special-quadruplets/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5857. 不同的好子序列数目]]></title>
    <url>%2F2021%2F08%2F30%2Fleetcode%205857.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E5%A5%BD%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个二进制字符串 binary 。 binary 的一个 子序列 如果是 非空 的且没有 前导 0 （除非数字是 “0” 本身），那么它就是一个 好 的子序列。 请你找到 binary 不同好子序列 的数目。 比方说，如果 binary = “001” ，那么所有 好 子序列为 [“0”, “0”, “1”] ，所以 不同 的好子序列为 “0” 和 “1” 。 注意，子序列 “00” ，”01” 和 “001” 不是好的，因为它们有前导 0 。 请你返回 binary 中 不同好子序列 的数目。由于答案可能很大，请将它对 109 + 7 取余 后返回。 一个 子序列 指的是从原数组中删除若干个（可以一个也不删除）元素后，不改变剩余元素顺序得到的序列。 示例：示例 1： 输入：binary = &quot;001&quot; 输出：2 解释：好的二进制子序列为 [&quot;0&quot;, &quot;0&quot;, &quot;1&quot;] 。 不同的好子序列为 &quot;0&quot; 和 &quot;1&quot; 。 示例 2： 输入：binary = &quot;11&quot; 输出：2 解释：好的二进制子序列为 [&quot;1&quot;, &quot;1&quot;, &quot;11&quot;] 。 不同的好子序列为 &quot;1&quot; 和 &quot;11&quot; 。 示例 3： 输入：binary = &quot;101&quot; 输出：5 解释：好的二进制子序列为 [&quot;1&quot;, &quot;0&quot;, &quot;1&quot;, &quot;10&quot;, &quot;11&quot;, &quot;101&quot;] 。 不同的好子序列为 &quot;0&quot; ，&quot;1&quot; ，&quot;10&quot; ，&quot;11&quot; 和 &quot;101&quot; 。 提示： 1 &lt;= binary.length &lt;= 10^5 binary 只含有 ‘0’ 和 ‘1’ 。 分析：动态规划 j有两种状态，0表示以0结尾子序列数量，1表示以1结尾子序列数量 dp[i][j]，表示到第i个字符为止，结尾为j的子序列数量 当遇到一个新的字符0时： 原先的1结尾的数字添上一个0有两种可能： 一部分加上0后会变成原先以0结尾的子序列中的相同的子序列 一部分加上0后会成为新的以0结尾的子序列 原先的0结尾的数字添上一个0会形成新的以0结尾的子序列，并且会将末尾只有一个0的子序列空出来，让给前面1结尾的第一部分子序列 这样遇到一个新的字符0时的状态转移为： dp[i][0] = dp[i-1][0] + dp[i-1][1] dp[i][1] = dp[i-1][1]; 当遇到一个新的字符1时同理，只不过需要加1，因为当添加完字符1后，原先只有一个字符1的子序列空了出来，需要填上 这样遇到一个新的字符1时的状态转移为： dp[i][1] = dp[i-1][0] + dp[i-1][1] + 1 dp[i][0] = dp[i-1][0]; 在这个算法中没有考虑一个0的状态，所以如果字符串中出现过0，就需要在最终答案加上一个1 代码：class Solution { public: int numberOfUniqueGoodSubsequences(string binary) { int n = binary.size(); vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(2, 0)); bool flag = false; for(auto a : binary){ if(a == &apos;0&apos;){ flag = true; break; } } for(int i = 1; i &lt;= n; i++){ if(binary[i-1] == &apos;0&apos;){ dp[i][0] = (dp[i-1][0] + dp[i-1][1]) % 1000000007; dp[i][1] = dp[i-1][1]; } else{ dp[i][1] = (dp[i-1][0] + dp[i-1][1] + 1) % 1000000007; dp[i][0] = dp[i-1][0]; } } if(flag) return (dp[n][0] + dp[n][1] + 1) % 1000000007; else return dp[n][1]; } }; 题目地址:https://leetcode-cn.com/problems/number-of-unique-good-subsequences/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5856. 完成任务的最少工作时间段]]></title>
    <url>%2F2021%2F08%2F30%2Fleetcode%205856.%20%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%B7%A5%E4%BD%9C%E6%97%B6%E9%97%B4%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[题目：你被安排了 n 个任务。任务需要花费的时间用长度为 n 的整数数组 tasks 表示，第 i 个任务需要花费 tasks[i] 小时完成。一个 工作时间段 中，你可以 至多 连续工作 sessionTime 个小时，然后休息一会儿。 你需要按照如下条件完成给定任务： 如果你在某一个时间段开始一个任务，你需要在 同一个 时间段完成它。 完成一个任务后，你可以 立马 开始一个新的任务。 你可以按 任意顺序 完成任务。 给你 tasks 和 sessionTime ，请你按照上述要求，返回完成所有任务所需要的 最少 数目的 工作时间段 。 测试数据保证 sessionTime 大于等于 tasks[i] 中的 最大值 。 示例：示例 1： 输入：tasks = [1,2,3], sessionTime = 3 输出：2 解释：你可以在两个工作时间段内完成所有任务。 - 第一个工作时间段：完成第一和第二个任务，花费 1 + 2 = 3 小时。 - 第二个工作时间段：完成第三个任务，花费 3 小时。 示例 2： 输入：tasks = [3,1,3,1,1], sessionTime = 8 输出：2 解释：你可以在两个工作时间段内完成所有任务。 - 第一个工作时间段：完成除了最后一个任务以外的所有任务，花费 3 + 1 + 3 + 1 = 8 小时。 - 第二个工作时间段，完成最后一个任务，花费 1 小时。 示例 3： 输入：tasks = [1,2,3,4,5], sessionTime = 15 输出：1 解释：你可以在一个工作时间段以内完成所有任务。 提示： n == tasks.length 1 &lt;= n &lt;= 14 1 &lt;= tasks[i] &lt;= 10 max(tasks[i]) &lt;= sessionTime &lt;= 15 分析：状态压缩dp dp[i]，表示二进制下的任务完成状态，0表示没完成，1表示完成 dp[i] = min(dp[j]+1, dp[i])，j为比i完成的任务少的状态 可以预处理各种任务完成需要时间 代码：class Solution { public: int minSessions(vector&lt;int&gt;&amp; tasks, int sessionTime) { vector&lt;int&gt; dp(1 &lt;&lt; tasks.size(), INT_MAX); vector&lt;int&gt; m(1 &lt;&lt; tasks.size(), 0); dp[0] = 0; for(int i = 0; i &lt; (1 &lt;&lt; tasks.size()); i++){ int z = 0; for(int j = 0; j &lt; tasks.size(); j++){ if((i &amp; (1 &lt;&lt; j)) &gt; 0) z += tasks[j]; } m[i] = z; } for(int i = 0; i &lt; (1 &lt;&lt; tasks.size()); i++){ if(m[i] &lt;= sessionTime){ dp[i] = min(dp[0]+1, dp[i]); } for(int j = (i-1) &amp; i; j &gt; 0; j = (j-1) &amp; i){ if(m[i - j] &lt;= sessionTime){ dp[i] = min(dp[j]+1, dp[i]); } } } return dp[(1&lt;&lt;tasks.size())-1]; } }; 题目地址:https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5855. 找出数组中的第 K 大整数]]></title>
    <url>%2F2021%2F08%2F30%2Fleetcode%205855.%20%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%AC%20K%20%E5%A4%A7%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串数组 nums 和一个整数 k 。nums 中的每个字符串都表示一个不含前导零的整数。 返回 nums 中表示第 k 大整数的字符串。 注意：重复的数字在统计时会视为不同元素考虑。例如，如果 nums 是 [“1”,”2”,”2”]，那么 “2” 是最大的整数，”2” 是第二大的整数，”1” 是第三大的整数。 示例：示例 1： 输入：nums = [&quot;3&quot;,&quot;6&quot;,&quot;7&quot;,&quot;10&quot;], k = 4 输出：&quot;3&quot; 解释： nums 中的数字按非递减顺序排列为 [&quot;3&quot;,&quot;6&quot;,&quot;7&quot;,&quot;10&quot;] 其中第 4 大整数是 &quot;3&quot; 示例 2： 输入：nums = [&quot;2&quot;,&quot;21&quot;,&quot;12&quot;,&quot;1&quot;], k = 3 输出：&quot;2&quot; 解释： nums 中的数字按非递减顺序排列为 [&quot;1&quot;,&quot;2&quot;,&quot;12&quot;,&quot;21&quot;] 其中第 3 大整数是 &quot;2&quot; 示例 3： 输入：nums = [&quot;0&quot;,&quot;0&quot;], k = 2 输出：&quot;0&quot; 解释： nums 中的数字按非递减顺序排列为 [&quot;0&quot;,&quot;0&quot;] 其中第 2 大整数是 &quot;0&quot; 提示： 1 &lt;= k &lt;= nums.length &lt;= 10^4 1 &lt;= nums[i].length &lt;= 100 nums[i] 仅由数字组成 nums[i] 不含任何前导零 分析：自定义排序，长度不同长的数字大，长度相同string自带的运算来比较 代码：bool bj(string&amp; s1, string&amp; s2) { if(s1.size() &gt; s2.size()) return 1; else if(s1.size() &lt; s2.size()) return 0; else{ if(s1 &gt; s2) return 1; else return 0; } } class Solution { public: string kthLargestNumber(vector&lt;string&gt;&amp; nums, int k) { sort(nums.begin(), nums.end(), bj); return nums[k-1]; } }; 题目地址:https://leetcode-cn.com/problems/find-the-kth-largest-integer-in-the-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5854. 学生分数的最小差值]]></title>
    <url>%2F2021%2F08%2F30%2Fleetcode%205854.%20%E5%AD%A6%E7%94%9F%E5%88%86%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。 从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。 返回可能的 最小差值 。 示例：示例 1： 输入：nums = [90], k = 1 输出：0 解释：选出 1 名学生的分数，仅有 1 种方法： - [90] 最高分和最低分之间的差值是 90 - 90 = 0 可能的最小差值是 0 示例 2： 输入：nums = [9,4,1,7], k = 2 输出：2 解释：选出 2 名学生的分数，有 6 种方法： - [9,4,1,7] 最高分和最低分之间的差值是 9 - 4 = 5 - [9,4,1,7] 最高分和最低分之间的差值是 9 - 1 = 8 - [9,4,1,7] 最高分和最低分之间的差值是 9 - 7 = 2 - [9,4,1,7] 最高分和最低分之间的差值是 4 - 1 = 3 - [9,4,1,7] 最高分和最低分之间的差值是 7 - 4 = 3 - [9,4,1,7] 最高分和最低分之间的差值是 7 - 1 = 6 可能的最小差值是 2 提示： 1 &lt;= k &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt;= 10^5 分析：排序，双指针过一遍，找出最小成绩差 代码：class Solution { public: int minimumDifference(vector&lt;int&gt;&amp; nums, int k) { sort(nums.begin(), nums.end()); int mi = INT_MAX; for(int l = 0, r = k-1; r &lt; nums.size(); l++, r++){ if(nums[r] - nums[l] &lt; mi){ mi = nums[r] - nums[l]; } } return mi; } }; 题目地址:https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5853. 从子集的和还原数组]]></title>
    <url>%2F2021%2F08%2F23%2Fleetcode%205853.%20%E4%BB%8E%E5%AD%90%E9%9B%86%E7%9A%84%E5%92%8C%E8%BF%98%E5%8E%9F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：存在一个未知数组需要你进行还原，给你一个整数 n 表示该数组的长度。另给你一个数组 sums ，由未知数组中全部 2n 个 子集的和 组成（子集中的元素没有特定的顺序）。 返回一个长度为 n 的数组 ans 表示还原得到的未知数组。如果存在 多种 答案，只需返回其中 任意一个 。 如果可以由数组 arr 删除部分元素（也可能不删除或全删除）得到数组 sub ，那么数组 sub 就是数组 arr 的一个 子集 。sub 的元素之和就是 arr 的一个 子集的和 。一个空数组的元素之和为 0 。 注意：生成的测试用例将保证至少存在一个正确答案。 示例：示例 1： 输入：n = 3, sums = [-3,-2,-1,0,0,1,2,3] 输出：[1,2,-3] 解释：[1,2,-3] 能够满足给出的子集的和： - []：和是 0 - [1]：和是 1 - [2]：和是 2 - [1,2]：和是 3 - [-3]：和是 -3 - [1,-3]：和是 -2 - [2,-3]：和是 -1 - [1,2,-3]：和是 0 注意，[1,2,-3] 的任何排列和 [-1,-2,3] 的任何排列都会被视作正确答案。 示例 2： 输入：n = 2, sums = [0,0,0,0] 输出：[0,0] 解释：唯一的正确答案是 [0,0] 。 示例 3： 输入：n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8] 输出：[0,-1,4,5] 解释：[0,-1,4,5] 能够满足给出的子集的和。 提示： 1 &lt;= n &lt;= 15 sums.length == 2^n -104 &lt;= sums[i] &lt;= 10^4 分析：可以通过最小的两个数的差得出原始数组中其中一个数字的绝对值原理：最小的数是所有负数之和。第二小的数要么是最小的数加上最小的正数，要么是最小的数减去最大的负数 这样得出一个数后，可以将sums中数分为两组，一组为包含这个数的，一组为不包含这个数的 取其中小的一组（应该可以随意选择哪组），继续上面的步骤，直到n个数全部得出 具体讲解：https://www.bilibili.com/video/BV1Qh411i7tS?p=5 代码：class Solution { public: vector&lt;int&gt; recoverArray(int n, vector&lt;int&gt;&amp; sums) { sort(sums.begin(), sums.end()); int nn = n; int lr = sums.front() + sums.back(); vector&lt;int&gt; ret; while(nn &gt; 0){ vector&lt;int&gt; s; int dif = sums[1] - sums[0]; ret.push_back(dif); unordered_map&lt;int,int&gt; m; for(int i = 0; i &lt; sums.size(); i++) m[sums[i]]++; for(int i = 0; i &lt; sums.size(); i++){ if(m.count(sums[i])){ s.push_back(sums[i]); if(!--m[sums[i]]) m.erase(sums[i]); if(!--m[sums[i] + dif]) m.erase(sums[i] + dif); } } sums = s; nn--; } for(int i = 0; i &lt; (1&lt;&lt;n); i++){ int sum = 0; for(int j = 0; j &lt; n; j++){ sum += (i &amp; (1 &lt;&lt; j)) ? ret[j] : -ret[j]; } if(sum == lr){ for(int j = 0; j &lt; n; j++){ if(!(i &amp; (1 &lt;&lt; j))) ret[j] *= -1; } return ret; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-array-given-subset-sums/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5852. 最小化目标值与所选元素的差]]></title>
    <url>%2F2021%2F08%2F23%2Fleetcode%205852.%20%E6%9C%80%E5%B0%8F%E5%8C%96%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%8E%E6%89%80%E9%80%89%E5%85%83%E7%B4%A0%E7%9A%84%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个大小为 m x n 的整数矩阵 mat 和一个整数 target 。 从矩阵的 每一行 中选择一个整数，你的目标是 最小化 所有选中元素之 和 与目标值 target 的 绝对差 。 返回 最小的绝对差 。 a 和 b 两数字的 绝对差 是 a - b 的绝对值。 示例：示例 1： 输入：mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13 输出：0 解释：一种可能的最优选择方案是： - 第一行选出 1 - 第二行选出 5 - 第三行选出 7 所选元素的和是 13 ，等于目标值，所以绝对差是 0 。 示例 2： 输入：mat = [[1],[2],[3]], target = 100 输出：94 解释：唯一一种选择方案是： - 第一行选出 1 - 第二行选出 2 - 第三行选出 3 所选元素的和是 6 ，绝对差是 94 。 示例 3： 输入：mat = [[1,2,9,8,7]], target = 6 输出：1 解释：最优的选择方案是选出第一行的 7 。 绝对差是 1 。 提示： m == mat.length n == mat[i].length 1 &lt;= m, n &lt;= 70 1 &lt;= mat[i][j] &lt;= 70 1 &lt;= target &lt;= 800 分析：动态规划 dp[i][j]，表示前i行是否可以组合出和为j的方案 dp[i][j] = dp[i-1][j-mat[i][k]]，k为遍历i行 正常需要三重循环，可以使用 bitset 来按位优化。 方法来源：https://leetcode-cn.com/problems/minimize-the-difference-between-target-and-chosen-elements/solution/jian-dan-bei-bao-dp-by-lightcml-eukp/ 代码：class Solution { public: int minimizeTheDifference(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int target) { int n = mat.size(); int m = mat[0].size(); bitset&lt;5000&gt; dp[n]; dp[0] = 0; for(int i = 0; i &lt; m; i++){ dp[0][mat[0][i]] = 1; } for(int i = 1; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ dp[i] |= dp[i-1] &lt;&lt; mat[i][j]; } } int ans = 4900; for(int i = 1; i &lt;= 4900; i++){ if(dp[n-1][i]){ ans = min(ans, abs(target-i)); } } return ans; } }; 题目地址:https://leetcode-cn.com/problems/minimize-the-difference-between-target-and-chosen-elements/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5851. 找出不同的二进制字符串]]></title>
    <url>%2F2021%2F08%2F23%2Fleetcode%205851.%20%E6%89%BE%E5%87%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串数组 nums ，该数组由 n 个 互不相同 的二进制字符串组成，且每个字符串长度都是 n 。请你找出并返回一个长度为 n 且 没有出现 在 nums 中的二进制字符串。如果存在多种答案，只需返回 任意一个 即可。 示例：示例 1： 输入：nums = [&quot;01&quot;,&quot;10&quot;] 输出：&quot;11&quot; 解释：&quot;11&quot; 没有出现在 nums 中。&quot;00&quot; 也是正确答案。 示例 2： 输入：nums = [&quot;00&quot;,&quot;01&quot;] 输出：&quot;11&quot; 解释：&quot;11&quot; 没有出现在 nums 中。&quot;10&quot; 也是正确答案。 示例 3： 输入：nums = [&quot;111&quot;,&quot;011&quot;,&quot;001&quot;] 输出：&quot;101&quot; 解释：&quot;101&quot; 没有出现在 nums 中。&quot;000&quot;、&quot;010&quot;、&quot;100&quot;、&quot;110&quot; 也是正确答案。 提示： n == nums.length 1 &lt;= n &lt;= 16 nums[i].length == n nums[i] 为 ‘0’ 或 ‘1’ 分析：转换成数字，用map存储 从小遍历数字，直到遇到map中没有的数字，转换成01字符串返回 代码：class Solution { public: string findDifferentBinaryString(vector&lt;string&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; for(int i = 0; i &lt; nums.size(); i++){ int z = 0; for(int j = 0; j &lt; nums[i].size(); j++){ z *= 2; z = z + (nums[i][j]-&apos;0&apos;); } m[z] = 1; } int n = 2; for(int i = 1; i &lt; nums[0].size(); i++){ n *= 2; } for(int i = 0; i &lt; n; i++){ if(m.count(i) == 0){ string str = &quot;&quot;; int z = i; for(int j = 0; j &lt; nums[0].size(); j++){ if(z == 0 || z % 2 == 0){ str = &apos;0&apos; + str; } else{ str = &apos;1&apos; + str; } if(z &gt; 0) z /= 2; } return str; } } return &quot;0&quot;; } }; 题目地址:https://leetcode-cn.com/problems/find-unique-binary-string/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5850. 找出数组的最大公约数]]></title>
    <url>%2F2021%2F08%2F23%2Fleetcode%205850.%20%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums ，返回数组中最大数和最小数的 最大公约数 。 两个数的 最大公约数 是能够被两个数整除的最大正整数。 示例：示例 1： 输入：nums = [2,5,6,9,10] 输出：2 解释： nums 中最小的数是 2 nums 中最大的数是 10 2 和 10 的最大公约数是 2 示例 2： 输入：nums = [7,5,6,8,3] 输出：1 解释： nums 中最小的数是 3 nums 中最大的数是 8 3 和 8 的最大公约数是 1 示例 3： 输入：nums = [3,3] 输出：3 解释： nums 中最小的数是 3 nums 中最大的数是 3 3 和 3 的最大公约数是 3 提示： 2 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 1000 分析：排序，找出两个数，然后开始尝试公约数直到1为止 代码：class Solution { public: int findGCD(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); for(int i = nums[0]; i&gt;=1; i--){ if(nums.back() % i == 0 &amp;&amp; nums[0] % i == 0) return i; } return 1; } }; 题目地址:https://leetcode-cn.com/problems/find-greatest-common-divisor-of-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5845. 你能穿过矩阵的最后一天]]></title>
    <url>%2F2021%2F08%2F16%2Fleetcode%205845.%20%E4%BD%A0%E8%83%BD%E7%A9%BF%E8%BF%87%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 1 开始的二进制矩阵，其中 0 表示陆地，1 表示水域。同时给你 row 和 col 分别表示矩阵中行和列的数目。 一开始在第 0 天，整个 矩阵都是 陆地 。但每一天都会有一块新陆地被 水 淹没变成水域。给你一个下标从 1 开始的二维数组 cells ，其中 cells[i] = [ri, ci] 表示在第 i 天，第 ri 行 ci 列（下标都是从 1 开始）的陆地会变成 水域 （也就是 0 变成 1 ）。 你想知道从矩阵最 上面 一行走到最 下面 一行，且只经过陆地格子的 最后一天 是哪一天。你可以从最上面一行的 任意 格子出发，到达最下面一行的 任意 格子。你只能沿着 四个 基本方向移动（也就是上下左右）。 请返回只经过陆地格子能从最 上面 一行走到最 下面 一行的 最后一天 。 示例：示例 1： 输入：row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]] 输出：2 解释：上图描述了矩阵从第 0 天开始是如何变化的。 可以从最上面一行到最下面一行的最后一天是第 2 天。 示例 2： 输入：row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]] 输出：1 解释：上图描述了矩阵从第 0 天开始是如何变化的。 可以从最上面一行到最下面一行的最后一天是第 1 天。 示例 3： 输入：row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]] 输出：3 解释：上图描述了矩阵从第 0 天开始是如何变化的。 可以从最上面一行到最下面一行的最后一天是第 3 天。 提示： 2 &lt;= row, col &lt;= 2 * 10^4 4 &lt;= row col &lt;= 2 10^4 cells.length == row * col 1 &lt;= ri &lt;= row 1 &lt;= ci &lt;= col cells 中的所有格子坐标都是 唯一 的。 分析：使用dfs来确认是否可以从第一排到最后一排 因为今天如果路线已经被封闭，明天肯定也会封闭，所以可以使用二分找出合适的一天。 代码：class Solution { public: bool dfs(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; m){ if(m[x][y] == 1) return false; if(x == m.size()-2) return true; int x1[4] = {0, -1, 0, 1}; int y1[4] = {-1, 0, 1, 0}; m[x][y] = 1; for(int i = 0; i &lt; 4; i++){ if(dfs(x+x1[i], y+y1[i], m)) return true; } return false; } int latestDayToCross(int row, int col, vector&lt;vector&lt;int&gt;&gt;&amp; cells) { int l = 0; int r = cells.size()-1; while(l &lt; r){ int mid = (l+r+1)/2; bool b = false; vector&lt;vector&lt;int&gt;&gt; m(row+2, vector&lt;int&gt;(col+2, 0)); for(int i = 0; i &lt; row+2; i++){ m[i][0] = 1; m[i][col+1] = 1; } for(int i = 0; i &lt; col+2; i++){ m[0][i] = 1; m[row+1][i] = 1; } for(int i = 0; i &lt;= mid; i++){ m[cells[i][0]][cells[i][1]] = 1; } for(int i = 1; i &lt; col+1; i++){ b = dfs(1, i, m); if(b) break; } if(b){ l = mid; } else{ r = mid-1; } } return l+1; } }; 题目地址:https://leetcode-cn.com/problems/last-day-where-you-can-still-cross/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5844. 数组元素的最小非零乘积]]></title>
    <url>%2F2021%2F08%2F16%2Fleetcode%205844.%20%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E9%9D%9E%E9%9B%B6%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目：给你一个正整数 p 。你有一个下标从 1 开始的数组 nums ，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次： 从 nums 中选择两个元素 x 和 y 。 选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。 比方说，如果 x = 1101 且 y = 0011 ，交换右边数起第 2 位后，我们得到 x = 1111 和 y = 0001 。 请你算出进行以上操作 任意次 以后，nums 能得到的 最小非零 乘积。将乘积对 109 + 7 取余 后返回。 注意：答案应为取余 之前 的最小值。 示例：示例 1： 输入：p = 1 输出：1 解释：nums = [1] 。 只有一个元素，所以乘积为该元素。 示例 2： 输入：p = 2 输出：6 解释：nums = [01, 10, 11] 。 所有交换要么使乘积变为 0 ，要么乘积与初始乘积相同。 所以，数组乘积 1 * 2 * 3 = 6 已经是最小值。 示例 3： 输入：p = 3 输出：1512 解释：nums = [001, 010, 011, 100, 101, 110, 111] - 第一次操作中，我们交换第二个和第五个元素最左边的数位。 - 结果数组为 [001, 110, 011, 100, 001, 110, 111] 。 - 第二次操作中，我们交换第三个和第四个元素中间的数位。 - 结果数组为 [001, 110, 001, 110, 001, 110, 111] 。 数组乘积 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512 是最小乘积。 提示： 1 &lt;= p &lt;= 60 分析：因为交换后和不会改变，所以尽可能让数组有比较多的1，这样相乘后的数字会更小 在数字转换成二进制后，可以统计每一位的1和0的数量，除了多出了一个全1的数字，剩下可以组成为n个0加一个1与n个1加一个0 n为 2^(p-1)-1 最后可以用快速幂的方式将这些数相乘 代码：class Solution { public: long long PowerMod(long long a, long long b, int c) { long long ans = 1; a = a % c; while(b&gt;0) { if(b % 2 == 1) ans = (ans * a) % c; b = b/2; a = (a * a) % c; } return ans; } int minNonZeroProduct(int p) { long long z = 1; if(p == 1) return 1; for(int i = 1; i &lt; p; i++){ z *= 2; } return PowerMod(z*2-2, z-1, 1000000007) * ((z*2-1) % 1000000007) % 1000000007; } }; 题目地址:https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5832. 构造元素不等于两相邻元素平均值的数组]]></title>
    <url>%2F2021%2F08%2F16%2Fleetcode%205832.%20%E6%9E%84%E9%80%A0%E5%85%83%E7%B4%A0%E4%B8%8D%E7%AD%89%E4%BA%8E%E4%B8%A4%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%B9%B3%E5%9D%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个 下标从 0 开始 的数组 nums ，数组由若干 互不相同的 整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都 不等于 其两侧相邻元素的 平均值 。 更公式化的说法是，重新排列的数组应当满足这一属性：对于范围 1 &lt;= i &lt; nums.length - 1 中的每个 i ，(nums[i-1] + nums[i+1]) / 2 不等于 nums[i] 均成立 。 返回满足题意的任一重排结果。 示例：示例 1： 输入：nums = [1,2,3,4,5] 输出：[1,2,4,5,3] 解释： i=1, nums[i] = 2, 两相邻元素平均值为 (1+4) / 2 = 2.5 i=2, nums[i] = 4, 两相邻元素平均值为 (2+5) / 2 = 3.5 i=3, nums[i] = 5, 两相邻元素平均值为 (4+3) / 2 = 3.5 示例 2： 输入：nums = [6,2,0,9,7] 输出：[9,7,6,2,0] 解释： i=1, nums[i] = 7, 两相邻元素平均值为 (9+6) / 2 = 7.5 i=2, nums[i] = 6, 两相邻元素平均值为 (7+2) / 2 = 4.5 i=3, nums[i] = 2, 两相邻元素平均值为 (6+0) / 2 = 3 提示： 3 &lt;= nums.length &lt;= 10^5 0 &lt;= nums[i] &lt;= 10^5 分析：可以将nums排序，按一个小，一个大的顺序组成数组即可 代码：class Solution { public: vector&lt;int&gt; rearrangeArray(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int l = 0; int r = nums.size()-1; vector&lt;int&gt; ret; while(l &lt; r){ ret.push_back(nums[l]); ret.push_back(nums[r]); l++; r--; } if(nums.size() % 2 == 1){ ret.push_back(nums[l]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5843. 作为子字符串出现在单词中的字符串数目]]></title>
    <url>%2F2021%2F08%2F16%2Fleetcode%205843.%20%E4%BD%9C%E4%B8%BA%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BA%E7%8E%B0%E5%9C%A8%E5%8D%95%E8%AF%8D%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串数组 patterns 和一个字符串 word ，统计 patterns 中有多少个字符串是 word 的子字符串。返回字符串数目。 子字符串 是字符串中的一个连续字符序列。 示例：示例 1： 输入：patterns = [&quot;a&quot;,&quot;abc&quot;,&quot;bc&quot;,&quot;d&quot;], word = &quot;abc&quot; 输出：3 解释： - &quot;a&quot; 是 &quot;abc&quot; 的子字符串。 - &quot;abc&quot; 是 &quot;abc&quot; 的子字符串。 - &quot;bc&quot; 是 &quot;abc&quot; 的子字符串。 - &quot;d&quot; 不是 &quot;abc&quot; 的子字符串。 patterns 中有 3 个字符串作为子字符串出现在 word 中。 示例 2： 输入：patterns = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], word = &quot;aaaaabbbbb&quot; 输出：2 解释： - &quot;a&quot; 是 &quot;aaaaabbbbb&quot; 的子字符串。 - &quot;b&quot; 是 &quot;aaaaabbbbb&quot; 的子字符串。 - &quot;c&quot; 不是 &quot;aaaaabbbbb&quot; 的字符串。 patterns 中有 2 个字符串作为子字符串出现在 word 中。 示例 3： 输入：patterns = [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;], word = &quot;ab&quot; 输出：3 解释：patterns 中的每个字符串都作为子字符串出现在 word &quot;ab&quot; 中。 提示： 1 &lt;= patterns.length &lt;= 100 1 &lt;= patterns[i].length &lt;= 100 1 &lt;= word.length &lt;= 100 patterns[i] 和 word 由小写英文字母组成 分析：暴力匹配 代码：class Solution { public: int numOfStrings(vector&lt;string&gt;&amp; patterns, string word) { int ret = 0; for(int i = 0; i &lt; patterns.size(); i++){ bool b = false; for(int j = 0; j &lt; (int)word.size() - (int)patterns[i].size() + 1; j++){ for(int k = 0; k &lt; patterns[i].size(); k++){ if(word[j+k] != patterns[i][k]){ break; } else if(patterns[i].size()-1 == k){ ret++; b = true; break; } } if(b) break; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-strings-that-appear-as-substrings-in-word/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1963. 使字符串平衡的最小交换次数]]></title>
    <url>%2F2021%2F08%2F09%2Fleetcode%201963.%20%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s ，下标从 0 开始 ，且长度为偶数 n 。字符串 恰好 由 n / 2 个开括号 ‘[‘ 和 n / 2 个闭括号 ‘]’ 组成。 只有能满足下述所有条件的字符串才能称为 平衡字符串 ： 字符串是一个空字符串，或者 字符串可以记作 AB ，其中 A 和 B 都是 平衡字符串 ，或者 字符串可以写成 [C] ，其中 C 是一个 平衡字符串 。 你可以交换 任意 两个下标所对应的括号 任意 次数。 返回使 s 变成 平衡字符串 所需要的 最小 交换次数。 示例：示例 1： 输入：s = &quot;][][&quot; 输出：1 解释：交换下标 0 和下标 3 对应的括号，可以使字符串变成平衡字符串。 最终字符串变成 &quot;[[]]&quot; 。 示例 2： 输入：s = &quot;]]][[[&quot; 输出：2 解释：执行下述操作可以使字符串变成平衡字符串： - 交换下标 0 和下标 4 对应的括号，s = &quot;[]][[]&quot; 。 - 交换下标 1 和下标 5 对应的括号，s = &quot;[[][]]&quot; 。 最终字符串变成 &quot;[[][]]&quot; 。 示例 3： 输入：s = &quot;[]&quot; 输出：0 解释：这个字符串已经是平衡字符串。 提示： n == s.length 2 &lt;= n &lt;= 106 n 为偶数 s[i] 为’[‘ 或 ‘]’ 开括号 ‘[‘ 的数目为 n / 2 ，闭括号 ‘]’ 的数目也是 n / 2 分析：每次交换可以消掉左括号和右括号各两个，所以只要统计位置不正确的左括号个数，除以2即可 代码：class Solution { public: int minSwaps(string s) { int l = 0; int r = 0; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == &apos;[&apos;) l++; else{ if(l &gt; 0) l--; else r++; } } return r-r/2; } }; 题目地址:https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1962. 移除石子使总数最小]]></title>
    <url>%2F2021%2F08%2F09%2Fleetcode%201962.%20%E7%A7%BB%E9%99%A4%E7%9F%B3%E5%AD%90%E4%BD%BF%E6%80%BB%E6%95%B0%E6%9C%80%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 piles ，数组 下标从 0 开始 ，其中 piles[i] 表示第 i 堆石子中的石子数量。另给你一个整数 k ，请你执行下述操作 恰好 k 次： 选出任一石子堆 piles[i] ，并从中 移除 floor(piles[i] / 2) 颗石子。 注意：你可以对 同一堆 石子多次执行此操作。 返回执行 k 次操作后，剩下石子的 最小 总数。 floor(x) 为 小于 或 等于 x 的 最大 整数。（即，对 x 向下取整）。 示例：示例 1： 输入：piles = [5,4,9], k = 2 输出：12 解释：可能的执行情景如下： - 对第 2 堆石子执行移除操作，石子分布情况变成 [5,4,5] 。 - 对第 0 堆石子执行移除操作，石子分布情况变成 [3,4,5] 。 剩下石子的总数为 12 。 示例 2： 输入：piles = [4,3,6,7], k = 3 输出：12 解释：可能的执行情景如下： - 对第 2 堆石子执行移除操作，石子分布情况变成 [4,3,3,7] 。 - 对第 3 堆石子执行移除操作，石子分布情况变成 [4,3,3,4] 。 - 对第 0 堆石子执行移除操作，石子分布情况变成 [2,3,3,4] 。 剩下石子的总数为 12 。 提示： 1 &lt;= piles.length &lt;= 10^5 1 &lt;= piles[i] &lt;= 10^4 1 &lt;= k &lt;= 10^5 分析：使用 multiset 存储石子 每次对最大的数字进行操作，将操作过后的数字重新加入multiset，重复k遍 代码：class Solution { public: int minStoneSum(vector&lt;int&gt;&amp; piles, int k) { int n = piles.size()-1; multiset&lt;int, greater&lt;int&gt;&gt; s(piles.begin(), piles.end()); for(int i = 0; i &lt; k; i++){ int z = *(s.begin()); s.erase(s.begin()); s.insert(z - z/2); } int ret = 0; for(auto a = s.begin(); a != s.end(); a++){ ret += *a; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/remove-stones-to-minimize-the-total/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1961. 检查字符串是否为数组前缀]]></title>
    <url>%2F2021%2F08%2F09%2Fleetcode%201961.%20%E6%A3%80%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s 和一个字符串数组 words ，请你判断 s 是否为 words 的 前缀字符串 。 字符串 s 要成为 words 的 前缀字符串 ，需要满足：s 可以由 words 中的前 k（k 为 正数 ）个字符串按顺序相连得到，且 k 不超过 words.length 。 如果 s 是 words 的 前缀字符串 ，返回 true ；否则，返回 false 。 示例：示例 1： 输入：s = &quot;iloveleetcode&quot;, words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;apples&quot;] 输出：true 解释： s 可以由 &quot;i&quot;、&quot;love&quot; 和 &quot;leetcode&quot; 相连得到。 示例 2： 输入：s = &quot;iloveleetcode&quot;, words = [&quot;apples&quot;,&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;] 输出：false 解释： 数组的前缀相连无法得到 s 。 提示： 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 20 1 &lt;= s.length &lt;= 1000 words[i] 和 s 仅由小写英文字母组成 分析：连接字符串直到长度等于s时比较 代码：class Solution { public: bool isPrefixString(string s, vector&lt;string&gt;&amp; words) { string str; for(int i = 0; i &lt; words.size(); i++){ if(s.size() &gt; str.size()){ str += words[i]; } } if(str == s) return true; return false; } }; 题目地址:https://leetcode-cn.com/problems/check-if-string-is-a-prefix-of-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1964. 找出到每个位置为止最长的有效障碍赛跑路线]]></title>
    <url>%2F2021%2F08%2F09%2Fleetcode%201964.%20%E6%89%BE%E5%87%BA%E5%88%B0%E6%AF%8F%E4%B8%AA%E4%BD%8D%E7%BD%AE%E4%B8%BA%E6%AD%A2%E6%9C%80%E9%95%BF%E7%9A%84%E6%9C%89%E6%95%88%E9%9A%9C%E7%A2%8D%E8%B5%9B%E8%B7%91%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[题目：你打算构建一些障碍赛跑路线。给你一个 下标从 0 开始 的整数数组 obstacles ，数组长度为 n ，其中 obstacles[i] 表示第 i 个障碍的高度。 对于每个介于 0 和 n - 1 之间（包含 0 和 n - 1）的下标 i ，在满足下述条件的前提下，请你找出 obstacles 能构成的最长障碍路线的长度： 你可以选择下标介于 0 到 i 之间（包含 0 和 i）的任意个障碍。 在这条路线中，必须包含第 i 个障碍。 你必须按障碍在 obstacles 中的 出现顺序 布置这些障碍。 除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 相同 或者 更高 。 返回长度为 n 的答案数组 ans ，其中 ans[i] 是上面所述的下标 i 对应的最长障碍赛跑路线的长度。 示例：示例 1： 输入：obstacles = [1,2,3,2] 输出：[1,2,3,3] 解释：每个位置的最长有效障碍路线是： - i = 0: [1], [1] 长度为 1 - i = 1: [1,2], [1,2] 长度为 2 - i = 2: [1,2,3], [1,2,3] 长度为 3 - i = 3: [1,2,3,2], [1,2,2] 长度为 3 示例 2： 输入：obstacles = [2,2,1] 输出：[1,2,1] 解释：每个位置的最长有效障碍路线是： - i = 0: [2], [2] 长度为 1 - i = 1: [2,2], [2,2] 长度为 2 - i = 2: [2,2,1], [1] 长度为 1 示例 3： 输入：obstacles = [3,1,5,6,4,2] 输出：[1,1,2,3,2,2] 解释：每个位置的最长有效障碍路线是： - i = 0: [3], [3] 长度为 1 - i = 1: [3,1], [1] 长度为 1 - i = 2: [3,1,5], [3,5] 长度为 2, [1,5] 也是有效的障碍赛跑路线 - i = 3: [3,1,5,6], [3,5,6] 长度为 3, [1,5,6] 也是有效的障碍赛跑路线 - i = 4: [3,1,5,6,4], [3,4] 长度为 2, [1,4] 也是有效的障碍赛跑路线 - i = 5: [3,1,5,6,4,2], [1,2] 长度为 2 提示： n == obstacles.length 1 &lt;= n &lt;= 10^5 1 &lt;= obstacles[i] &lt;= 10^7 分析：v[i] 表示以 v[i]高的障碍 结尾的最长路线 遍历时，遇到一个新的障碍，有两种可能： 比最后的障碍高或相等，加入数组v 比最后的障碍低，从数组中找到刚刚比最新障碍高的数，替换掉（这一步可以使用二分加快查找） 代码：class Solution { public: vector&lt;int&gt; longestObstacleCourseAtEachPosition(vector&lt;int&gt;&amp; obstacles) { vector&lt;int&gt; ret{1}; vector&lt;int&gt; v{obstacles[0]}; for(int i = 1; i &lt; obstacles.size(); i++){ if(obstacles[i] &gt;= v.back()){ v.push_back(obstacles[i]); ret.push_back(v.size()); } else{ int l = 0; int r = v.size(); while(l &lt; r){ int m = (l+r)/2; if(v[m] &lt;= obstacles[i]){ l = m+1; } else{ r = m; } } v[l] = obstacles[i]; ret.push_back(l+1); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-the-longest-valid-obstacle-course-at-each-position/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5833. 统计特殊子序列的数目]]></title>
    <url>%2F2021%2F08%2F02%2Fleetcode%205833.%20%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：特殊序列 是由 正整数 个 0 ，紧接着 正整数 个 1 ，最后 正整数 个 2 组成的序列。 比方说，[0,1,2] 和 [0,0,1,1,1,2] 是特殊序列。 相反，[2,1,0] ，[1] 和 [0,1,2,0] 就不是特殊序列。 给你一个数组 nums （仅 包含整数 0，1 和 2），请你返回 不同特殊子序列的数目 。由于答案可能很大，请你将它对 109 + 7 取余 后返回。 一个数组的 子序列 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 下标集合 不同，那么这两个子序列是 不同的 。 示例：示例 1： 输入：nums = [0,1,2,2] 输出：3 解释：特殊子序列为 [0,1,2,2]，[0,1,2,2] 和 [0,1,2,2] 。 示例 2： 输入：nums = [2,2,0,0] 输出：0 解释：数组 [2,2,0,0] 中没有特殊子序列。 示例 3： 输入：nums = [0,1,2,0,1,2] 输出：7 解释：特殊子序列包括： - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] 提示： 1 &lt;= nums.length &lt;= 10^5 0 &lt;= nums[i] &lt;= 2 分析：动态规划 dp[i][j]，表示到第i个元素为止，集合为j的组合数量。 j有三种取值，三种状态转移方程： 0，表示全是0的组合数量，dp[i][0] = dp[i-1][0]*2 + 1，其余不变 （组成：原先的组合，原先的组合后边多一个0，单独一个0） 1，表示由0和1组成的组合数量，dp[i][1] = dp[i-1][1]*2 + dp[i][0]，其余不变 （组成：原先的组合，原先的组合后边多一个1，0的组合后面多一个1） 2，表示有0和1和2组成的组合数量，do[i][2] = dp[i-1][2]*2 + dp[i][1]，其余不变 （组成：原先的组合，原先的组合后边多一个2，1的组合后边多一个2） 代码：class Solution { public: int countSpecialSubsequences(vector&lt;int&gt;&amp; nums) { long long dp0 = 0; long long dp1 = 0; long long dp2 = 0; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] == 0){ dp0 = dp0*2+1; dp0 %= 1000000007; } else if(nums[i] == 1){ dp1 = dp1*2+dp0; dp1 %= 1000000007; } else{ dp2 = dp2*2+dp1; dp2 %= 1000000007; } } return dp2; } }; 题目地址:https://leetcode-cn.com/problems/count-number-of-special-subsequences/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5187. 收集足够苹果的最小花园周长]]></title>
    <url>%2F2021%2F08%2F02%2Fleetcode%205187.%20%E6%94%B6%E9%9B%86%E8%B6%B3%E5%A4%9F%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%B0%8F%E8%8A%B1%E5%9B%AD%E5%91%A8%E9%95%BF%2F</url>
    <content type="text"><![CDATA[题目：给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 (i, j) 处的苹果树有 |i| + |j| 个苹果。 你将会买下正中心坐标是 (0, 0) 的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。 给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。 |x| 的值定义为： 如果 x &gt;= 0 ，那么值为 x 如果 x &lt; 0 ，那么值为 -x 示例：示例 1： 输入：neededApples = 1 输出：8 解释：边长长度为 1 的正方形不包含任何苹果。 但是边长为 2 的正方形包含 12 个苹果（如上图所示）。 周长为 2 * 4 = 8 。 示例 2： 输入：neededApples = 13 输出：16 示例 3： 输入：neededApples = 1000000000 输出：5040 提示： 1 &lt;= neededApples &lt;= 10^15 分析：可以找规律 第0排，边长为1： 0 第1排，边长为3： 2 1 2 第2排，边长为5： 4 3 2 3 4 正下方的数字为上方+1，两边各加上排数*2 代码：class Solution { public: long long minimumPerimeter(long long neededApples) { long long z = 0; long long m = 0; long long b = 0; int i = 1; for(i; m &lt; neededApples; i++){ z = (b + i*2-1 + i * 2) * 4; b = b + i*2-1 + i * 4; m = m + z; } return (i-1)*2*4; } }; 题目地址:https://leetcode-cn.com/problems/minimum-garden-perimeter-to-collect-enough-apples/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5831. 你可以工作的最大周数]]></title>
    <url>%2F2021%2F08%2F02%2Fleetcode%205831.%20%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。 你可以按下面两个规则参与项目中的工作： 每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。 在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。 一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。 返回在不违反上面规则的情况下你 最多 能工作多少周。 示例：示例 1： 输入：milestones = [1,2,3] 输出：6 解释：一种可能的情形是： ​​​​- 第 1 周，你参与并完成项目 0 中的一个阶段任务。 - 第 2 周，你参与并完成项目 2 中的一个阶段任务。 - 第 3 周，你参与并完成项目 1 中的一个阶段任务。 - 第 4 周，你参与并完成项目 2 中的一个阶段任务。 - 第 5 周，你参与并完成项目 1 中的一个阶段任务。 - 第 6 周，你参与并完成项目 2 中的一个阶段任务。 总周数是 6 。 示例 2： 输入：milestones = [5,2,1] 输出：7 解释：一种可能的情形是： - 第 1 周，你参与并完成项目 0 中的一个阶段任务。 - 第 2 周，你参与并完成项目 1 中的一个阶段任务。 - 第 3 周，你参与并完成项目 0 中的一个阶段任务。 - 第 4 周，你参与并完成项目 1 中的一个阶段任务。 - 第 5 周，你参与并完成项目 0 中的一个阶段任务。 - 第 6 周，你参与并完成项目 2 中的一个阶段任务。 - 第 7 周，你参与并完成项目 0 中的一个阶段任务。 总周数是 7 。 注意，你不能在第 8 周参与完成项目 0 中的最后一个阶段任务，因为这会违反规则。 因此，项目 0 中会有一个阶段任务维持未完成状态。 提示： n == milestones.length 1 &lt;= n &lt;= 10^5 1 &lt;= milestones[i] &lt;= 10^9 分析：因为只要有两个以上的任务就可以组合完成，所以只要考虑最多的那个任务是否大于其他任务的总和： 大于，剩下的那部分无法完成 小于或等于，可以全部完成 注意，在大于的情况下，可以先从最多的任务开始，这样可以多做一次任务 代码：class Solution { public: long long numberOfWeeks(vector&lt;int&gt;&amp; milestones) { sort(milestones.begin(), milestones.end()); long long h = 0; for(int i = 0; i &lt; milestones.size()-1; i++){ h += milestones[i]; } if(h &lt; milestones[milestones.size()-1]){ return h*2+1; } return h + milestones[milestones.size()-1]; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5830. 三除数]]></title>
    <url>%2F2021%2F08%2F02%2Fleetcode%205830.%20%E4%B8%89%E9%99%A4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n 。如果 n 恰好有三个正除数 ，返回 true ；否则，返回 false 。 如果存在整数 k ，满足 n = k * m ，那么整数 m 就是 n 的一个 除数 。 示例：示例 1： 输入：n = 2 输出：false 解释：2 只有两个除数：1 和 2 。 示例 2： 输入：n = 4 输出：true 解释：4 有三个除数：1、2 和 4 。 提示： 1 &lt;= n &lt;= 10^4 分析：从1到n一个个除过来 代码：class Solution { public: bool isThree(int n) { int z = 2; for(int i = 2; i &lt; n &amp;&amp; z &lt;= 3; i++){ if(n % i == 0){ if(n/i == i) z++; else z+= 2; } } if(z == 3) return true; return false; } }; 题目地址:https://leetcode-cn.com/problems/three-divisors/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5826. 删除系统中的重复文件夹]]></title>
    <url>%2F2021%2F07%2F26%2Fleetcode%205826.%20%E5%88%A0%E9%99%A4%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[题目：由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组 paths，其中 paths[i] 是一个表示文件系统中第 i 个文件夹的绝对路径的数组。 例如，[“one”, “two”, “three”] 表示路径 “/one/two/three” 。 如果两个文件夹（不需要在同一层级）包含 非空且相同的 子文件夹 集合 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 不 需要相同。如果存在两个（或两个以上）相同 文件夹，则需要将这些文件夹和所有它们的子文件夹 标记 为待删除。 例如，下面文件结构中的文件夹 “/a” 和 “/b” 相同。它们（以及它们的子文件夹）应该被 全部 标记为待删除： /a /a/x /a/x/y /a/z /b /b/x /b/x/y /b/z 然而，如果文件结构中还包含路径 “/b/w” ，那么文件夹 “/a” 和 “/b” 就不相同。注意，即便添加了新的文件夹 “/b/w” ，仍然认为 “/a/x” 和 “/b/x” 相同。 一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 删除 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。 返回二维数组 ans ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 任意顺序 返回。 示例：示例 1： 输入：paths = [[&quot;a&quot;],[&quot;c&quot;],[&quot;d&quot;],[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;d&quot;,&quot;a&quot;]] 输出：[[&quot;d&quot;],[&quot;d&quot;,&quot;a&quot;]] 解释：文件结构如上所示。 文件夹 &quot;/a&quot; 和 &quot;/c&quot;（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 &quot;b&quot; 的空文件夹。 示例 2： 输入：paths = [[&quot;a&quot;],[&quot;c&quot;],[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;x&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;x&quot;,&quot;y&quot;],[&quot;w&quot;],[&quot;w&quot;,&quot;y&quot;]] 输出：[[&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;]] 解释：文件结构如上所示。 文件夹 &quot;/a/b/x&quot; 和 &quot;/w&quot;（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 &quot;y&quot; 的空文件夹。 注意，文件夹 &quot;/a&quot; 和 &quot;/c&quot; 在删除后变为相同文件夹，但这两个文件夹不会被删除，因为删除只会进行一次，且它们没有在删除前被标记。 示例 3： 输入：paths = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;],[&quot;c&quot;],[&quot;a&quot;] 提示： 1 &lt;= paths.length &lt;= 2 * 104 1 &lt;= paths[i].length &lt;= 500 1 &lt;= paths[i][j].length &lt;= 10 1 &lt;= sum(paths[i][j].length) &lt;= 2 * 105 path[i][j] 由小写英文字母组成不会存在两个路径都指向同一个文件夹的情况 对于不在根层级的任意文件夹，其父文件夹也会包含在输入中 分析：可以用括号表示法来表示子树中的节点，比如示例1中的子树a：a(b()) 使用dfs遍历树，将每个子树的节点以括号表示法的方式存入map统计数量。 再度dfs遍历树，去除出现数量大于1的子树 代码：class Solution { struct Node{ string val; string serial; unordered_map&lt;string, Node*&gt; children; }; unordered_map&lt;string, int&gt; m; vector&lt;vector&lt;string&gt;&gt; ret; Node* root; public: string construct(Node* n){ if(n == NULL) return &quot;&quot;; string str = &quot;&quot;; vector&lt;string&gt; v; for(auto a = n-&gt;children.begin(); a != n-&gt;children.end(); a++){ v.push_back(construct(a-&gt;second)); } sort(v.begin(), v.end()); for(int i = 0; i &lt; v.size(); i++){ str += v[i]; } if(n-&gt;children.size() != 0) m[str]++; n-&gt;serial = str; str = n-&gt;val + &quot;(&quot; + str + &quot;)&quot;; return str; } void operate(Node* n, vector&lt;string&gt; vs){ if(m[n-&gt;serial] &gt; 1){ return; } else{ if(n != root){ vs.push_back(n-&gt;val); ret.push_back(vs); } if(n-&gt;children.size() != 0){ for(auto a = n-&gt;children.begin(); a != n-&gt;children.end(); a++){ operate(a-&gt;second, vs); } } } } vector&lt;vector&lt;string&gt;&gt; deleteDuplicateFolder(vector&lt;vector&lt;string&gt;&gt;&amp; paths) { root = new Node(); for(int i = 0; i &lt; paths.size(); i++){ Node* n = root; for(int j = 0; j &lt; paths[i].size(); j++){ if(n-&gt;children.count(paths[i][j])){ n = n-&gt;children[paths[i][j]]; } else{ n-&gt;children[paths[i][j]] = new Node(); n-&gt;children[paths[i][j]]-&gt;val = paths[i][j]; n = n-&gt;children[paths[i][j]]; } } } construct(root); operate(root, vector&lt;string&gt;{}); return ret; } }; 题目地址:https://leetcode-cn.com/problems/delete-duplicate-folders-in-system/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5825. 最大兼容性评分和]]></title>
    <url>%2F2021%2F07%2F26%2Fleetcode%205825.%20%E6%9C%80%E5%A4%A7%E5%85%BC%E5%AE%B9%E6%80%A7%E8%AF%84%E5%88%86%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：有一份由 n 个问题组成的调查问卷，每个问题的答案要么是 0（no，否），要么是 1（yes，是）。 这份调查问卷被分发给 m 名学生和 m 名导师，学生和导师的编号都是从 0 到 m - 1 。学生的答案用一个二维整数数组 students 表示，其中 students[i] 是一个整数数组，包含第 i 名学生对调查问卷给出的答案（下标从 0 开始）。导师的答案用一个二维整数数组 mentors 表示，其中 mentors[j] 是一个整数数组，包含第 j 名导师对调查问卷给出的答案（下标从 0 开始）。 每个学生都会被分配给 一名 导师，而每位导师也会分配到 一名 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。 例如，学生答案为[1, 0, 1] 而导师答案为 [0, 0, 1] ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。 请你找出最优的学生与导师的配对方案，以 最大程度上 提高 兼容性评分和 。 给你 students 和 mentors ，返回可以得到的 最大兼容性评分和 。 示例：示例 1： 输入：students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]] 输出：8 解释：按下述方式分配学生和导师： - 学生 0 分配给导师 2 ，兼容性评分为 3 。 - 学生 1 分配给导师 0 ，兼容性评分为 2 。 - 学生 2 分配给导师 1 ，兼容性评分为 3 。 最大兼容性评分和为 3 + 2 + 3 = 8 。 示例 2： 输入：students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]] 输出：0 解释：任意学生与导师配对的兼容性评分都是 0 。 提示： m == students.length == mentors.length n == students[i].length == mentors[j].length 1 &lt;= m, n &lt;= 8 students[i][k] 为 0 或 1 mentors[j][k] 为 0 或 1 分析：直接枚举所有可能 还可以使用状压dp：https://leetcode-cn.com/problems/maximum-compatibility-score-sum/solution/zui-da-jian-rong-xing-ping-fen-he-by-lee-be2l/ 代码：class Solution { vector&lt;vector&lt;int&gt;&gt; s; vector&lt;vector&lt;int&gt;&gt; m; int ret; public: void dfs(int n, int i, vector&lt;bool&gt; b){ if(i == s.size()){ ret = max(ret, n); return; } for(int j = 0; j &lt; m.size(); j++){ if(b[j]){ int n1 = n; for(int k = 0; k &lt; s[0].size(); k++){ if(s[i][k] == m[j][k]) n1++; } b[j] = false; dfs(n1, i+1, b); b[j] = true; } } } int maxCompatibilitySum(vector&lt;vector&lt;int&gt;&gt;&amp; students, vector&lt;vector&lt;int&gt;&gt;&amp; mentors) { s = students; m = mentors; ret = 0; dfs(0, 0, vector&lt;bool&gt;(m.size(), true)); return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-compatibility-score-sum/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5824. 子字符串突变后可能得到的最大整数]]></title>
    <url>%2F2021%2F07%2F26%2Fleetcode%205824.%20%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AA%81%E5%8F%98%E5%90%8E%E5%8F%AF%E8%83%BD%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 num ，该字符串表示一个大整数。另给你一个长度为 10 且 下标从 0 开始 的整数数组 change ，该数组将 0-9 中的每个数字映射到另一个数字。更规范的说法是，数字 d 映射为数字 change[d] 。 你可以选择 突变 num 的任一子字符串。突变 子字符串意味着将每位数字 num[i] 替换为该数字在 change 中的映射（也就是说，将 num[i] 替换为 change[num[i]]）。 请你找出在对 num 的任一子字符串执行突变操作（也可以不执行）后，可能得到的 最大整数 ，并用字符串表示返回。 子字符串 是字符串中的一个连续序列。 示例：示例 1： 输入：num = &quot;132&quot;, change = [9,8,5,0,3,6,4,2,6,8] 输出：&quot;832&quot; 解释：替换子字符串 &quot;1&quot;： - 1 映射为 change[1] = 8 。 因此 &quot;132&quot; 变为 &quot;832&quot; 。 &quot;832&quot; 是可以构造的最大整数，所以返回它的字符串表示。 示例 2： 输入：num = &quot;021&quot;, change = [9,4,3,5,7,2,1,9,0,6] 输出：&quot;934&quot; 解释：替换子字符串 &quot;021&quot;： - 0 映射为 change[0] = 9 。 - 2 映射为 change[2] = 3 。 - 1 映射为 change[1] = 4 。 因此，&quot;021&quot; 变为 &quot;934&quot; 。 &quot;934&quot; 是可以构造的最大整数，所以返回它的字符串表示。 示例 3： 输入：num = &quot;5&quot;, change = [1,4,7,5,3,2,5,6,9,4] 输出：&quot;5&quot; 解释：&quot;5&quot; 已经是可以构造的最大整数，所以返回它的字符串表示。 提示： 1 &lt;= num.length &lt;= 10^5 num 仅由数字 0-9 组成 change.length == 10 0 &lt;= change[d] &lt;= 9 分析：从数字高位开始遍历，如果替换后会大于当前数字，就替换。 需要注意开始替换时数需要大于当前数字，而替换中途需要大于等于当前数字 代码：class Solution { public: string maximumNumber(string num, vector&lt;int&gt;&amp; change) { for(int i = 0; i &lt; num.size(); i++){ if(change[num[i]-&apos;0&apos;]+&apos;0&apos; &gt; num[i]){ num[i] = change[num[i]-&apos;0&apos;]+&apos;0&apos;; for(int j = i+1; j &lt; num.size(); j++){ if(change[num[j]-&apos;0&apos;]+&apos;0&apos; &gt;= num[j]){ num[j] = change[num[j]-&apos;0&apos;]+&apos;0&apos;; } else{ break; } } return num; } } return num; } }; 题目地址:https://leetcode-cn.com/problems/largest-number-after-mutating-substring/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5823. 字符串转化后的各位数字之和]]></title>
    <url>%2F2021%2F07%2F26%2Fleetcode%205823.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E5%90%8E%E7%9A%84%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个由小写字母组成的字符串 s ，以及一个整数 k 。 首先，用字母在字母表中的位置替换该字母，将 s 转化 为一个整数（也就是，’a’ 用 1 替换，’b’ 用 2 替换，… ‘z’ 用 26 替换）。接着，将整数 转换 为其 各位数字之和 。共重复 转换 操作 k 次 。 例如，如果 s = “zbax” 且 k = 2 ，那么执行下述步骤后得到的结果是整数 8 ： 转化：”zbax” ➝ “(26)(2)(1)(24)” ➝ “262124” ➝ 262124 转换 #1：262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17 转换 #2：17 ➝ 1 + 7 ➝ 8 返回执行上述操作后得到的结果整数。 示例：示例 1： 输入：s = &quot;iiii&quot;, k = 1 输出：36 解释：操作如下： - 转化：&quot;iiii&quot; ➝ &quot;(9)(9)(9)(9)&quot; ➝ &quot;9999&quot; ➝ 9999 - 转换 #1：9999 ➝ 9 + 9 + 9 + 9 ➝ 36 因此，结果整数为 36 。 示例 2： 输入：s = &quot;leetcode&quot;, k = 2 输出：6 解释：操作如下： - 转化：&quot;leetcode&quot; ➝ &quot;(12)(5)(5)(20)(3)(15)(4)(5)&quot; ➝ &quot;12552031545&quot; ➝ 12552031545 - 转换 #1：12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33 - 转换 #2：33 ➝ 3 + 3 ➝ 6 因此，结果整数为 6 。 提示： 1 &lt;= s.length &lt;= 100 1 &lt;= k &lt;= 10 s 由小写英文字母组成 分析：直接模拟就好 代码：class Solution { public: int getLucky(string s, int k) { string str = &quot;&quot;; int ret = 0; for(int i = 0; i &lt; s.size(); i++){ int z = s[i]-&apos;a&apos;+1; while(z &gt; 0){ str += z%10 + &apos;0&apos;; z /= 10; } } for(int i = 0; i &lt; k; i++){ int z = 0; for(int j = 0; j &lt; str.size(); j++){ z += str[j] - &apos;0&apos;; } ret = z; str.clear(); while(z &gt; 0){ str += z % 10 + &apos;0&apos;; z /= 10; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/sum-of-digits-of-string-after-convert/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1938. 查询最大基因差]]></title>
    <url>%2F2021%2F07%2F19%2Fleetcode%201938.%20%E6%9F%A5%E8%AF%A2%E6%9C%80%E5%A4%A7%E5%9F%BA%E5%9B%A0%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一棵 n 个节点的有根树，节点编号从 0 到 n - 1 。每个节点的编号表示这个节点的 独一无二的基因值 （也就是说节点 x 的基因值为 x）。两个基因值的 基因差 是两者的 异或和 。给你整数数组 parents ，其中 parents[i] 是节点 i 的父节点。如果节点 x 是树的 根 ，那么 parents[x] == -1 。 给你查询数组 queries ，其中 queries[i] = [nodei, vali] 。对于查询 i ，请你找到 vali 和 pi 的 最大基因差 ，其中 pi 是节点 nodei 到根之间的任意节点（包含 nodei 和根节点）。更正式的，你想要最大化 vali XOR pi 。 请你返回数组 ans ，其中 ans[i] 是第 i 个查询的答案。 示例：示例 1： 输入：parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]] 输出：[2,3,7] 解释：查询数组处理如下： - [0,2]：最大基因差的对应节点为 0 ，基因差为 2 XOR 0 = 2 。 - [3,2]：最大基因差的对应节点为 1 ，基因差为 2 XOR 1 = 3 。 - [2,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。 示例 2： 输入：parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]] 输出：[6,14,7] 解释：查询数组处理如下： - [4,6]：最大基因差的对应节点为 0 ，基因差为 6 XOR 0 = 6 。 - [1,15]：最大基因差的对应节点为 1 ，基因差为 15 XOR 1 = 14 。 - [0,5]：最大基因差的对应节点为 2 ，基因差为 5 XOR 2 = 7 。 提示： 2 &lt;= parents.length &lt;= 105 对于每个 不是 根节点的 i ，有 0 &lt;= parents[i] &lt;= parents.length - 1 。 parents[root] == -1 1 &lt;= queries.length &lt;= 3 * 104 0 &lt;= nodei &lt;= parents.length - 1 0 &lt;= vali &lt;= 2 * 105 分析：离线，字典树，dfs 将节点编号转换成二进制就可以使用字典树来存储，通过字典树可以快速判断出异或和最大的数。 先找到根结点。从根结点开始dfs，遍历到到节点时加入字典树，从节点返回时从字典树中移除，遇到需要查询的节点时从当前字典树中查询。 c++编写字典树的移除方法时需要注意要传入指针的指针 代码：class Solution { private: struct Node{ Node* l; Node* r; Node(){ l = NULL; r = NULL; } }; unordered_map&lt;int, vector&lt;int&gt;&gt; m; unordered_map&lt;int, vector&lt;int&gt;&gt; q; vector&lt;int&gt; ret; Node r; public: void insert(vector&lt;int&gt;&amp; v, Node* n){ Node* n1 = n; for(int i = 0; i &lt; 18; i++){ if(v[i] == 0){ if(n1-&gt;l == NULL){ n1-&gt;l = new Node; } n1 = n1-&gt;l; } else{ if(n1-&gt;r == NULL){ n1-&gt;r = new Node; } n1 = n1-&gt;r; } } } void erase(vector&lt;int&gt;&amp; v, Node** n, int i){ if(i == 18){ //delete (*n); // 去除就超时 *n = NULL; return; } if(v[i] == 0){ erase(v, &amp;((*n)-&gt;l), i+1); } else{ erase(v, &amp;((*n)-&gt;r), i+1); } if(i == 0) return; if((*n)-&gt;l == NULL &amp;&amp; (*n)-&gt;r == NULL){ //delete (*n); // 去除就超时 *n = NULL; } } int match(vector&lt;int&gt;&amp; v, Node* n){ Node* n1 = n; int ans = 0; for(int i = 0; i &lt; v.size(); i++){ if(v[i] == 0){ if(n1-&gt;r == NULL){ n1 = n1-&gt;l; ans = ans*2; } else{ n1 = n1-&gt;r; ans = ans*2+1; } } else{ if(n1-&gt;l == NULL){ n1 = n1-&gt;r; ans = ans*2; } else{ n1 = n1-&gt;l; ans = ans*2+1; } } } return ans; } void dfs(int val){ int val1 = val; vector&lt;int&gt; v(18, 0); for(int i = 17; i &gt;= 0 &amp;&amp; val1 &gt; 0; i--){ v[i] = val1 % 2; val1 /= 2; } insert(v, &amp;r); if(q.count(val)){ for(int j = 0; j &lt; q[val].size(); j+=2){ vector&lt;int&gt; v1(18, 0); int val1 = q[val][j]; for(int k = 17; k &gt;= 0 &amp;&amp; val1 &gt; 0; k--){ v1[k] = val1 % 2; val1 /= 2; } ret[q[val][j+1]] = match(v1, &amp;r); } } for(int i = 0; i &lt; m[val].size(); i++){ dfs(m[val][i]); } Node* n = &amp;r; erase(v, &amp;n, 0); } vector&lt;int&gt; maxGeneticDifference(vector&lt;int&gt;&amp; parents, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { ret = vector&lt;int&gt;(queries.size(), 0); int root; for(int i = 0; i &lt; parents.size(); i++){ if(parents[i] == -1){ root = i; } else{ m[parents[i]].push_back(i); } } for(int i = 0; i &lt; queries.size(); i++){ q[queries[i][0]].push_back(queries[i][1]); q[queries[i][0]].push_back(i); } dfs(root); return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-genetic-difference-query/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1937. 扣分后的最大得分]]></title>
    <url>%2F2021%2F07%2F19%2Fleetcode%201937.%20%E6%89%A3%E5%88%86%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目：给你一个 m x n 的整数矩阵 points （下标从 0 开始）。一开始你的得分为 0 ，你想最大化从矩阵中得到的分数。 你的得分方式为：每一行 中选取一个格子，选中坐标为 (r, c) 的格子会给你的总得分 增加 points[r][c] 。 然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 r 和 r + 1 （其中 0 &lt;= r &lt; m - 1），选中坐标为 (r, c1) 和 (r + 1, c2) 的格子，你的总得分 减少 abs(c1 - c2) 。 请你返回你能得到的 最大 得分。 abs(x) 定义为： 如果 x &gt;= 0 ，那么值为 x 。 如果 x &lt; 0 ，那么值为 -x 。 示例：示例 1： 输入：points = [[1,2,3],[1,5,1],[3,1,1]] 输出：9 解释： 蓝色格子是最优方案选中的格子，坐标分别为 (0, 2)，(1, 1) 和 (2, 0) 。 你的总得分增加 3 + 5 + 3 = 11 。 但是你的总得分需要扣除 abs(2 - 1) + abs(1 - 0) = 2 。 你的最终得分为 11 - 2 = 9 。 示例 2： 输入：points = [[1,5],[2,3],[4,2]] 输出：11 解释： 蓝色格子是最优方案选中的格子，坐标分别为 (0, 1)，(1, 1) 和 (2, 0) 。 你的总得分增加 5 + 3 + 4 = 12 。 但是你的总得分需要扣除 abs(1 - 1) + abs(1 - 0) = 1 。 你的最终得分为 12 - 1 = 11 。 提示： m == points.length n == points[r].length 1 &lt;= m, n &lt;= 105 1 &lt;= m * n &lt;= 105 0 &lt;= points[r][c] &lt;= 105 分析：动态规划，前后缀最大值 动态规划很明显，但直接遍历的话复杂度为O(nmm)，所以需要优化 优化方法：https://leetcode-cn.com/problems/maximum-number-of-points-with-cost/solution/dp-you-hua-ji-qiao-chai-xiang-qian-hou-z-5vvc/ 代码：class Solution { public: long long maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) { long long dp[points.size()][points[0].size()]; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; points[0].size(); i++){ dp[0][i] = points[0][i]; } for(int i = 1; i &lt; points.size(); i++){ vector&lt;long long&gt; l(points[0].size(), 0); vector&lt;long long&gt; r(points[0].size(), 0); l[0] = dp[i-1][0]; for(int j = 1; j &lt; points[0].size(); j++){ l[j] = max(dp[i-1][j] + j, l[j-1]); } r[points[0].size()-1] = dp[i-1][points[0].size()-1] - (points[0].size()-1); for(int j = points[0].size()-2; j &gt;= 0; j--){ r[j] = max(dp[i-1][j] - j, r[j+1]); } for(int j = 0; j &lt; points[i].size(); j++){ dp[i][j] = max(points[i][j] - j + l[j], points[i][j] + j + r[j]); } } long long ret = INT_MIN; for(int i = 0; i &lt; points[0].size(); i++){ ret = max(dp[points.size()-1][i], ret); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-points-with-cost/solution/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1936. 新增的最少台阶数]]></title>
    <url>%2F2021%2F07%2F19%2Fleetcode%201936.%20%E6%96%B0%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%91%E5%8F%B0%E9%98%B6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个 严格递增 的整数数组 rungs ，用于表示梯子上每一台阶的 高度 。当前你正站在高度为 0 的地板上，并打算爬到最后一个台阶。 另给你一个整数 dist 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）不超过 dist 高度的台阶。当然，你也可以在任何正 整数 高度处插入尚不存在的新台阶。 返回爬到最后一阶时必须添加到梯子上的 最少 台阶数。 示例：示例 1： 输入：rungs = [1,3,5,10], dist = 2 输出：2 解释： 现在无法到达最后一阶。 在高度为 7 和 8 的位置增设新的台阶，以爬上梯子。 梯子在高度为 [1,3,5,7,8,10] 的位置上有台阶。 示例 2： 输入：rungs = [3,6,8,10], dist = 3 输出：0 解释： 这个梯子无需增设新台阶也可以爬上去。 示例 3： 输入：rungs = [3,4,6,7], dist = 2 输出：1 解释： 现在无法从地板到达梯子的第一阶。 在高度为 1 的位置增设新的台阶，以爬上梯子。 梯子在高度为 [1,3,4,6,7] 的位置上有台阶。 示例 4： 输入：rungs = [5], dist = 10 输出：0 解释：这个梯子无需增设新台阶也可以爬上去。 提示： 1 &lt;= rungs.length &lt;= 10^5 1 &lt;= rungs[i] &lt;= 10^9 1 &lt;= dist &lt;= 10^9 rungs 严格递增 分析：遍历台阶，计算在两个无法一步到达的台阶之间需要几个台阶，将所有需要的台阶数量累加。 注意是从0开始，不是第一级台阶开始 代码：class Solution { public: int addRungs(vector&lt;int&gt;&amp; rungs, int dist) { int ret = 0; if(rungs[0] &gt; dist){ ret += (rungs[0]-1) / dist; } for(int i = 1; i &lt; rungs.size(); i++){ if(rungs[i] - rungs[i-1] &gt; dist){ ret += (rungs[i] - rungs[i-1]-1) / dist; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/add-minimum-number-of-rungs/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1935. 可以输入的最大单词数]]></title>
    <url>%2F2021%2F07%2F19%2Fleetcode%201935.%20%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。 给你一个由若干单词组成的字符串 text ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 brokenLetters ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 text 中单词的数目。 示例：示例 1： 输入：text = &quot;hello world&quot;, brokenLetters = &quot;ad&quot; 输出：1 解释：无法输入 &quot;world&quot; ，因为字母键 &apos;d&apos; 已损坏。 示例 2： 输入：text = &quot;leet code&quot;, brokenLetters = &quot;lt&quot; 输出：1 解释：无法输入 &quot;leet&quot; ，因为字母键 &apos;l&apos; 和 &apos;t&apos; 已损坏。 示例 3： 输入：text = &quot;leet code&quot;, brokenLetters = &quot;e&quot; 输出：0 解释：无法输入任何单词，因为字母键 &apos;e&apos; 已损坏。 提示： 1 &lt;= text.length &lt;= 10^4 0 &lt;= brokenLetters.length &lt;= 26 text 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格 每个单词仅由小写英文字母组成 brokenLetters 由 互不相同 的小写英文字母组成 分析：将brokenLetters转换成map，遍历一遍单词即可 代码：class Solution { public: int canBeTypedWords(string text, string brokenLetters) { vector&lt;string&gt; t; string s = &quot;&quot;; int ret = 0; map&lt;char, int&gt; m; for(int i = 0; i &lt; brokenLetters.size(); i++){ m[brokenLetters[i]] = 1; } for(int i = 0; i &lt; text.size(); i++){ if(text[i] == &apos; &apos;){ t.push_back(s); s.clear(); } else{ s += text[i]; } } t.push_back(s); for(int i = 0; i &lt; t.size(); i++){ for(int j = 0; j &lt; t[i].size(); j++){ if(m.count(t[i][j])){ ret--; break; } } ret++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-words-you-can-type/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1932. 合并多棵二叉搜索树]]></title>
    <url>%2F2021%2F07%2F12%2Fleetcode%201932.%20%E5%90%88%E5%B9%B6%E5%A4%9A%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目：给你 n 个 二叉搜索树的根节点 ，存储在数组 trees 中（下标从 0 开始），对应 n 棵不同的二叉搜索树。trees 中的每棵二叉搜索树 最多有 3 个节点 ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤： 选择两个 不同的 下标 i 和 j ，要求满足在 trees[i] 中的某个 叶节点 的值等于 trees[j] 的 根节点的值 。 用 trees[j] 替换 trees[i] 中的那个叶节点。 从 trees 中移除 trees[j] 。 如果在执行 n - 1 次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 根节点 ；如果无法构造一棵有效的二叉搜索树，返回 null 。 二叉搜索树是一种二叉树，且树中每个节点均满足下述属性： 任意节点的左子树中的值都 严格小于 此节点的值。 任意节点的右子树中的值都 严格大于 此节点的值。叶节点是不含子节点的节点。 示例：示例 1： 输入：trees = [[2,1],[3,2,5],[5,4]] 输出：[3,2,5,1,null,4] 解释： 第一步操作中，选出 i=1 和 j=0 ，并将 trees[0] 合并到 trees[1] 中。 删除 trees[0] ，trees = [[3,2,5,1],[5,4]] 。 在第二步操作中，选出 i=0 和 j=1 ，将 trees[1] 合并到 trees[0] 中。 删除 trees[1] ，trees = [[3,2,5,1,null,4]] 。 结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。 示例 2： 输入：trees = [[5,3,8],[3,2,6]] 输出：[] 解释： 选出 i=0 和 j=1 ，然后将 trees[1] 合并到 trees[0] 中。 删除 trees[1] ，trees = [[5,3,8,2,6]] 。 结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 null 。 示例 3： 输入：trees = [[5,4],[3]] 输出：[] 解释：无法执行任何操作。 示例 4： 输入：trees = [[2,1,3]] 输出：[2,1,3] 解释：trees 中只有一棵树，且这棵树已经是一棵有效的二叉搜索树，所以返回该树的根节点。 提示： n == trees.length 1 &lt;= n &lt;= 5 * 10^4 每棵树中节点数目在范围 [1, 3] 内。 trees 中不存在两棵树根节点值相同的情况。 输入中的所有树都是 有效的二叉树搜索树 。 1 &lt;= TreeNode.val &lt;= 5 * 10^4. 分析：二叉搜索树中没有重复的结点，所以只要将根结点和子节点一一连接起来，并进行判断是否有环、是否是标准的二叉搜索树、是否只有一个根结点。 具体见代码 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { unordered_map&lt;int, int&gt; mhuan; public: bool huan(TreeNode* root){ // 判断是否有环 if(mhuan.count(root-&gt;val)){ return false; } mhuan[root-&gt;val] = 1; if(root-&gt;left != NULL) if(!huan(root-&gt;left)) return false; if(root-&gt;right != NULL) if(!huan(root-&gt;right)) return false; return true; } pair&lt;int, int&gt; dfs(TreeNode* root){ // dfs判断二叉搜索树的内部是否符合标准 //{-1，-1}：不符合标准 //{-2，-2}，子树为空 pair&lt;int, int&gt; l{-2, -2}; pair&lt;int, int&gt; r{-2, -2}; int min1 = INT_MAX; int max1 = 0; if(root-&gt;left != NULL) l = dfs(root-&gt;left); if(root-&gt;right != NULL) r = dfs(root-&gt;right); if(l.first == -1 || r.first == -1) return {-1, -1}; // 子树已经不符合标准直接返回 if(l.first != -2){ // 判断左子树是否符合标准 if(l.second &lt; root-&gt;val){ min1 = min(min1, l.first); max1 = max(max1, l.second); } else{ return {-1, -1}; } } if(r.first != -2){ // 判断右子树是否符合标准 if(r.first &gt; root-&gt;val){ min1 = min(min1, r.first); max1 = max(max1, r.second); } else{ return {-1, -1}; } } if(l.first == -2 &amp;&amp; r.first == -2){ // 当左右子树都为空时，表示为叶节点 return {root-&gt;val, root-&gt;val}; } min1 = min(min1, root-&gt;val); max1 = max(max1, root-&gt;val); return {min1, max1}; } TreeNode* canMerge(vector&lt;TreeNode*&gt;&amp; trees) { unordered_map&lt;int, TreeNode*&gt; m; // 保存每个根结点的值所对应的树 unordered_map&lt;int, int&gt; mroot; // 保存作为根结点并且不是子节点的结点 for(int i = 0; i &lt; trees.size(); i++){ m[trees[i]-&gt;val] = trees[i]; mroot[trees[i]-&gt;val] = 1; } for(int i = 0; i &lt; trees.size(); i++){ // 将子节点和根结点一一对应 if(trees[i]-&gt;left != NULL &amp;&amp; m.count(trees[i]-&gt;left-&gt;val)){ trees[i]-&gt;left = m[trees[i]-&gt;left-&gt;val]; mroot.erase(trees[i]-&gt;left-&gt;val); } if(trees[i]-&gt;right != NULL &amp;&amp; m.count(trees[i]-&gt;right-&gt;val)){ trees[i]-&gt;right = m[trees[i]-&gt;right-&gt;val]; mroot.erase(trees[i]-&gt;right-&gt;val); } } if(mroot.size() != 1) return NULL; // 如果还有一个以上的根结点，返回NULL // 判断是否存在环，如果有环，返回NULL if(!huan(m[mroot.begin()-&gt;first])) return NULL; for(auto a : trees){ if(mhuan.count(a-&gt;val) == 0){ if(!huan(a)) return NULL; } } // 如果不符合二叉搜索树的标准，返回NULL if(dfs(m[mroot.begin()-&gt;first]).first == -1) return NULL; return m[mroot.begin()-&gt;first]; } }; 题目地址:https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1931. 用三种不同颜色为网格涂色]]></title>
    <url>%2F2021%2F07%2F12%2Fleetcode%201931.%20%E7%94%A8%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E9%A2%9C%E8%89%B2%E4%B8%BA%E7%BD%91%E6%A0%BC%E6%B6%82%E8%89%B2%2F</url>
    <content type="text"><![CDATA[题目：给你两个整数 m 和 n 。构造一个 m x n 的网格，其中每个单元格最开始是白色。请你用 红、绿、蓝 三种颜色为每个单元格涂色。所有单元格都需要被涂色。 涂色方案需要满足：不存在相邻两个单元格颜色相同的情况 。返回网格涂色的方法数。因为答案可能非常大， 返回 对 10^9 + 7 取余 的结果。 示例：示例 1： 输入：m = 1, n = 1 输出：3 解释：如上图所示，存在三种可能的涂色方案。 示例 2： 输入：m = 1, n = 2 输出：6 解释：如上图所示，存在六种可能的涂色方案。 示例 3： 输入：m = 5, n = 5 输出：580986 提示： 1 &lt;= m &lt;= 5 1 &lt;= n &lt;= 1000 分析：可以将列压缩为一个三进制的数，再使用动态规划 先预处理列内的涂色方案 i表示第i列，k和j是枚举之前预处理的涂色方案的状态当第i列的状态j与第i+1列的状态k符合涂色要求时：dp[i+1][k] += do[i][j] 代码：class Solution { int m1; public: bool pd(int a, int b){ int a1; int b1; if(a &lt; m1 &amp;&amp; b &lt; m1) return false; while(a &gt; 0 || b &gt; 0){ a1 = a%3; a /= 3; b1 = b%3; b /= 3; if(a1 == b1) return false; } return true; } int colorTheGrid(int m, int n) { vector&lt;int&gt; v; int ret = 0; int q = 1; for(int i = 0; i &lt; m; i++) q *= 3; m1 = q / 3; cout &lt;&lt; m1; for(int i = 0; i &lt; q; i++){ vector&lt;int&gt; v1; for(int j = 0, i1 = i; j &lt; m; i1 /= 3, j++){ v1.push_back(i1 % 3); } bool b = true; for(int j = 1; j &lt; v1.size(); j++){ if(v1[j] == v1[j-1]){ b = false; break; } } if(b) v.push_back(i); } vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(v.size(), 0)); for(int i = 0; i &lt; v.size(); i++){ dp[0][i] = 1; } for(int i = 0; i &lt; n-1; i++){ for(int j = 0; j &lt; v.size(); j++){ for(int k = 0; k &lt; v.size(); k++){ if(pd(v[j], v[k])){ dp[i+1][k] += dp[i][j]; dp[i+1][k] %= 1000000007; } } } } for(int i = 0; i &lt; v.size(); i++){ ret = (ret + dp[n-1][i]) % 1000000007; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1930. 长度为 3 的不同回文子序列]]></title>
    <url>%2F2021%2F07%2F12%2Fleetcode%201930.%20%E9%95%BF%E5%BA%A6%E4%B8%BA%203%20%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s ，返回 s 中 长度为 3 的不同回文子序列 的个数。 即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。 回文 是正着读和反着读一样的字符串。 子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。 例如，”ace” 是 “abcde” 的一个子序列。 示例：示例 1： 输入：s = &quot;aabca&quot; 输出：3 解释：长度为 3 的 3 个回文子序列分别是： - &quot;aba&quot; (&quot;aabca&quot; 的子序列) - &quot;aaa&quot; (&quot;aabca&quot; 的子序列) - &quot;aca&quot; (&quot;aabca&quot; 的子序列) 示例 2： 输入：s = &quot;adc&quot; 输出：0 解释：&quot;adc&quot; 不存在长度为 3 的回文子序列。 示例 3： 输入：s = &quot;bbcbaba&quot; 输出：4 解释：长度为 3 的 4 个回文子序列分别是： - &quot;bbb&quot; (&quot;bbcbaba&quot; 的子序列) - &quot;bcb&quot; (&quot;bbcbaba&quot; 的子序列) - &quot;bab&quot; (&quot;bbcbaba&quot; 的子序列) - &quot;aba&quot; (&quot;bbcbaba&quot; 的子序列) 提示： 3 &lt;= s.length &lt;= 10^5 s 仅由小写英文字母组成 分析：使用前缀和就可以知道每段之间各个字符的数量 枚举中间字符，判断两边是否有相同字符 注意需要去重 代码：class Solution { public: int countPalindromicSubsequence(string s) { vector&lt;vector&lt;int&gt;&gt; v(s.size(), vector&lt;int&gt;(26)); unordered_map&lt;int, unordered_map&lt;int, bool&gt;&gt; m; v[0][s[0]-&apos;a&apos;]++; for(int i = 1; i &lt; s.size(); i++){ for(int j = 0; j &lt; 26; j++){ if(s[i] == j+&apos;a&apos;){ v[i][j] = v[i-1][j]+1; } else{ v[i][j] = v[i-1][j]; } } } for(int i = 1; i &lt; s.size(); i++){ for(int j = 0; j &lt; 26; j++){ if(v[i-1][j] &gt; 0 &amp;&amp; v[v.size()-1][j] - v[i][j] &gt; 0){ m[j][s[i]-&apos;a&apos;] = true; } } } int ret = 0; for(auto a = m.begin(); a != m.end(); a++){ ret += (a-&gt;second).size(); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1929. 数组串联]]></title>
    <url>%2F2021%2F07%2F12%2Fleetcode%201929.%20%E6%95%B0%E7%BB%84%E4%B8%B2%E8%81%94%2F</url>
    <content type="text"><![CDATA[题目：给你一个长度为 n 的整数数组 nums 。请你构建一个长度为 2n 的答案数组 ans ，数组下标 从 0 开始计数 ，对于所有 0 &lt;= i &lt; n 的 i ，满足下述所有要求： ans[i] == nums[i] ans[i + n] == nums[i] 具体而言，ans 由两个 nums 数组 串联 形成。 返回数组 ans 。 示例：示例 1： 输入：nums = [1,2,1] 输出：[1,2,1,1,2,1] 解释：数组 ans 按下述方式形成： - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]] - ans = [1,2,1,1,2,1] 示例 2： 输入：nums = [1,3,2,1] 输出：[1,3,2,1,1,3,2,1] 解释：数组 ans 按下述方式形成： - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]] - ans = [1,3,2,1,1,3,2,1] 提示： n == nums.length 1 &lt;= n &lt;= 1000 1 &lt;= nums[i] &lt;= 1000 分析：将两段nums连接到一起 代码：class Solution { public: vector&lt;int&gt; getConcatenation(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ret = nums; for(int i = 0; i &lt; nums.size(); i++){ ret.push_back(nums[i]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/concatenation-of-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5803. 最长公共子路径]]></title>
    <url>%2F2021%2F07%2F05%2Fleetcode%205803.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目：一个国家由 n 个编号为 0 到 n - 1 的城市组成。在这个国家里，每两个 城市之间都有一条道路连接。 总共有 m 个编号为 0 到 m - 1 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 重复 出现，但同一个城市在一条路径中不会连续出现。 给你一个整数 n 和二维数组 paths ，其中 paths[i] 是一个整数数组，表示第 i 个朋友走过的路径，请你返回 每一个 朋友都走过的 最长公共子路径 的长度，如果不存在公共子路径，请你返回 0 。 一个 子路径 指的是一条路径中连续的城市序列。 示例：示例 1： 输入：n = 5, paths = [[0,1,2,3,4], [2,3,4], [4,0,1,2,3]] 输出：2 解释：最长公共子路径为 [2,3] 。 示例 2： 输入：n = 3, paths = [[0],[1],[2]] 输出：0 解释：三条路径没有公共子路径。 示例 3： 输入：n = 5, paths = [[0,1,2,3,4], [4,3,2,1,0]] 输出：1 解释：最长公共子路径为 [0]，[1]，[2]，[3] 和 [4] 。它们长度都为 1 。 提示： 1 &lt;= n &lt;= 10^5 m == paths.length 2 &lt;= m &lt;= 10^5 sum(paths[i].length) &lt;= 10^5 0 &lt;= paths[i][j] &lt; n paths[i] 中同一个城市不会连续重复出现。 分析：二分+滚动哈希（字符串哈希） 二分的是子字符串长度，二分后通过滚动哈希判断是否所有字符串都包含此子字符串 滚动哈希将字符串转换成一串数字，通过取模的方式，压缩为long long类型的数字。之后使用unordered_set可以方便判断子字符串是否在之前的字符串中出现过 这道题有点特殊，因为哈希值取模过后有可能会冲突，所以即使代码正确也有可能通不过更详细的：https://leetcode-cn.com/problems/longest-common-subpath/solution/zui-chang-gong-gong-zi-lu-jing-by-leetco-ypip/ 代码：class Solution { using LL = long long; static constexpr LL mod = 100000000699; public: int longestCommonSubpath(int n, vector&lt;vector&lt;int&gt;&gt;&amp; paths) { cout &lt;&lt; mod; int m = paths.size(); mt19937 gen{random_device{}()}; auto dis = uniform_int_distribution&lt;int&gt;(1e6, 1e7); int base = dis(gen); int left = 1; int right = min_element(paths.begin(), paths.end(), [](const auto&amp; p1, const auto&amp; p2) {return p1.size() &lt; p2.size();})-&gt;size(); int ans = 0; while(left &lt;= right){ int len = (left + right) / 2; LL mult = 1; for(int i = 1; i &lt;= len; i++){ mult = (LL)mult * base % mod; } unordered_set&lt;LL&gt; s; bool check = true; for(int i = 0; i &lt; m; i++){ LL hash = 0; for(int j = 0; j &lt; len; j++){ hash = ((LL) hash * base + paths[i][j]) % mod; } unordered_set&lt;LL&gt; t; if(i == 0 || s.count(hash)){ t.emplace(hash); } for(int j = len; j &lt; paths[i].size(); j++){ hash = (((LL)hash * base % mod - (LL)paths[i][j - len] * mult % mod + paths[i][j]) % mod + mod) % mod; if(i == 0 || s.count(hash)){ t.emplace(hash); } } if(t.empty()){ check = false; break; } s = move(t); } if(check){ ans = len; left = len+1; } else{ right = len-1; } } return ans; } }; 题目地址:https://leetcode-cn.com/problems/longest-common-subpath/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5802. 统计好数字的数目]]></title>
    <url>%2F2021%2F07%2F05%2Fleetcode%205802.%20%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：我们称一个数字字符串是 好数字 当它满足（下标从 0 开始）偶数 下标处的数字为 偶数 且 奇数 下标处的数字为 质数 （2，3，5 或 7）。 比方说，”2582” 是好数字，因为偶数下标处的数字（2 和 8）是偶数且奇数下标处的数字（5 和 2）为质数。但 “3245” 不是 好数字，因为 3 在偶数下标处但不是偶数。给你一个整数 n ，请你返回长度为 n 且为好数字的数字字符串 总数 。由于答案可能会很大，请你将它对 109 + 7 取余后返回 。 一个 数字字符串 是每一位都由 0 到 9 组成的字符串，且可能包含前导 0 示例：示例 1： 输入：n = 1 输出：5 解释：长度为 1 的好数字包括 &quot;0&quot;，&quot;2&quot;，&quot;4&quot;，&quot;6&quot;，&quot;8&quot; 。 示例 2： 输入：n = 4 输出：400 示例 3： 输入：n = 50 输出：564908303 提示： 1 &lt;= n &lt;= 10^15 分析：可以将n位数分为两份，奇数位和偶数位，奇数位有4种可能，偶数位有5种可能 偶数位数量为 w = (n+1)/2，奇数位为 s = n-w 我们要求的就是 5^w * 4^s，可以用快速幂计算 代码：class Solution { public: long long fastPower(long long base, long long exponent) { long long sum = 1; while (exponent != 0) { if ((exponent &amp; 1) != 0) { sum *= base; sum = sum % 1000000007; } exponent = exponent &gt;&gt; 1; // 对指数进行移位 base *= base; // 让base的次幂以2的倍数增长 base = base % 1000000007; } return sum; } int countGoodNumbers(long long n) { long long w = (n+1)/2; long long s = n-w; long long ret = fastPower(5, w) * fastPower(4, s); ret = ret % 1000000007; return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-good-numbers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5801. 消灭怪物的最大数量]]></title>
    <url>%2F2021%2F07%2F05%2Fleetcode%205801.%20%E6%B6%88%E7%81%AD%E6%80%AA%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 下标从 0 开始 且长度为 n 的整数数组 dist ，其中 dist[i] 是第 i 个怪物与城市的 初始距离（单位：米）。 怪物以 恒定 的速度走向城市。给你一个长度为 n 的整数数组 speed 表示每个怪物的速度，其中 speed[i] 是第 i 个怪物的速度（单位：米/分）。 怪物从 第 0 分钟 时开始移动。你有一把武器，并可以 选择 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。 一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 恰 在某一分钟开始时到达城市，这会被视为 输掉 游戏，在你可以使用武器之前，游戏就会结束。 返回在你输掉游戏前可以消灭的怪物的 最大 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回 n 。 示例：示例 1： 输入：dist = [1,3,4], speed = [1,1,1] 输出：3 解释： 第 0 分钟开始时，怪物的距离是 [1,3,4]，你消灭了第一个怪物。 第 1 分钟开始时，怪物的距离是 [X,2,3]，你没有消灭任何怪物。 第 2 分钟开始时，怪物的距离是 [X,1,2]，你消灭了第二个怪物。 第 3 分钟开始时，怪物的距离是 [X,X,1]，你消灭了第三个怪物。 所有 3 个怪物都可以被消灭。 示例 2： 输入：dist = [1,1,2,3], speed = [1,1,1,1] 输出：1 解释： 第 0 分钟开始时，怪物的距离是 [1,1,2,3]，你消灭了第一个怪物。 第 1 分钟开始时，怪物的距离是 [X,0,1,2]，你输掉了游戏。 你只能消灭 1 个怪物。 示例 3： 输入：dist = [3,2,4], speed = [5,3,2] 输出：1 解释： 第 0 分钟开始时，怪物的距离是 [3,2,4]，你消灭了第一个怪物。 第 1 分钟开始时，怪物的距离是 [X,0,2]，你输掉了游戏。 你只能消灭 1 个怪物。 提示： n == dist.length == speed.length 1 &lt;= n &lt;= 10^5 1 &lt;= dist[i], speed[i] &lt;= 10^5 分析：将距离和速度转化为需要的时间 按照需要的时间排序，如果第i个怪物在i-1的时间无法消灭，就代表输掉了游戏 代码：class Solution { public: int eliminateMaximum(vector&lt;int&gt;&amp; dist, vector&lt;int&gt;&amp; speed) { vector&lt;int&gt; v; int ret = 0; for(int i = 0; i &lt; dist.size(); i++){ v.push_back((dist[i] - 1) / speed[i] + 1); } sort(v.begin(), v.end()); for(int i = 0; i &lt; v.size(); i++){ if(i &gt;= v[i]) return ret; ret++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/eliminate-maximum-number-of-monsters/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5800. 基于排列构建数组]]></title>
    <url>%2F2021%2F07%2F05%2Fleetcode%205800.%20%E5%9F%BA%E4%BA%8E%E6%8E%92%E5%88%97%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个 从 0 开始的排列 nums（下标也从 0 开始）。请你构建一个 同样长度 的数组 ans ，其中，对于每个 i（0 &lt;= i &lt; nums.length），都满足 ans[i] = nums[nums[i]] 。返回构建好的数组 ans 。 从 0 开始的排列 nums 是一个由 0 到 nums.length - 1（0 和 nums.length - 1 也包含在内）的不同整数组成的数组。 示例：示例 1： 输入：nums = [0,2,1,5,3,4] 输出：[0,1,2,4,5,3] 解释：数组 ans 构建如下： ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]] = [0,1,2,4,5,3] 示例 2： 输入：nums = [5,0,1,2,3,4] 输出：[4,5,0,1,2,3] 解释：数组 ans 构建如下： ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]] = [4,5,0,1,2,3] 提示： 1 &lt;= nums.length &lt;= 1000 0 &lt;= nums[i] &lt; nums.length nums 中的元素 互不相同 分析：按照要求构建数组 代码：class Solution { public: vector&lt;int&gt; buildArray(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ret; for(int i = 0; i &lt; nums.size(); i++){ ret.push_back(nums[nums[i]]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/build-array-from-permutation/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1916. 统计为蚁群构筑房间的不同顺序]]></title>
    <url>%2F2021%2F06%2F28%2Fleetcode%201916.%20%E7%BB%9F%E8%AE%A1%E4%B8%BA%E8%9A%81%E7%BE%A4%E6%9E%84%E7%AD%91%E6%88%BF%E9%97%B4%E7%9A%84%E4%B8%8D%E5%90%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目：你是一只蚂蚁，负责为蚁群构筑 n 间编号从 0 到 n-1 的新房间。给你一个 下标从 0 开始 且长度为 n 的整数数组 prevRoom 作为扩建计划。其中，prevRoom[i] 表示在构筑房间 i 之前，你必须先构筑房间 prevRoom[i] ，并且这两个房间必须 直接 相连。房间 0 已经构筑完成，所以 prevRoom[0] = -1 。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 0 可以访问到每个房间。 你一次只能构筑 一个 房间。你可以在 已经构筑好的 房间之间自由穿行，只要这些房间是 相连的 。如果房间 prevRoom[i] 已经构筑完成，那么你就可以构筑房间 i。 返回你构筑所有房间的 不同顺序的数目 。由于答案可能很大，请返回对 10^9 + 7 取余 的结果。 示例：示例 1： 输入：prevRoom = [-1,0,1] 输出：1 解释：仅有一种方案可以完成所有房间的构筑：0 → 1 → 2 示例 2： 输入：prevRoom = [-1,0,0,1,2] 输出：6 解释： 有 6 种不同顺序： 0 → 1 → 3 → 2 → 4 0 → 2 → 4 → 1 → 3 0 → 1 → 2 → 3 → 4 0 → 1 → 2 → 4 → 3 0 → 2 → 1 → 3 → 4 0 → 2 → 1 → 4 → 3 提示： n == prevRoom.length 2 &lt;= n &lt;= 10^5 prevRoom[0] == -1 对于所有的 1 &lt;= i &lt; n ，都有 0 &lt;= prevRoom[i] &lt; n 题目保证所有房间都构筑完成后，从房间 0 可以访问到每个房间 分析：前置知识点： 排列数计算。假设有 a0 个物品 0，a1 个物品 1，…，an-1 个物品 n−1，将它们排成一排，那么方案数为(a0+a1+…+an-1)! / a0! / a1! / … / an-1! 乘法逆元。在一个取模m的情况下， b / a = b*a^-1(mod m)，m为质数的情况下使用 费马小定理 ：a^(m-2) = a^-1 （可以用快速幂来方便计算） 参考：https://leetcode-cn.com/problems/count-ways-to-build-rooms-in-an-ant-colony/solution/tong-ji-wei-yi-qun-gou-zhu-fang-jian-de-uqhn7/快速幂：https://www.cnblogs.com/Bylight/p/10538891.html 每个房间都依靠着另一个已经存在的房间，并且只有一个起始房间，可以用数据结构树来存储 对于每一个结点来说，可以构筑房间不同顺序的数目为： 结点下子树整体的排列数 * 各个子树内部的排列数 遍历方式可以使用dfs 代码：class Solution { static constexpr int mod = 1000000007; unordered_map&lt;int, vector&lt;int&gt;&gt; m; vector&lt;int&gt; cj; // 乘阶 vector&lt;int&gt; ny; // 乘法逆元 vector&lt;int&gt; v; // 各个子树节点数 vector&lt;int&gt; v1;// 各个子树不同构建顺序数量 public: // 快速幂计算 x^y int quickmul(int x, int y) { int ret = 1, cur = x; while (y) { if (y &amp; 1) { ret = (long long)ret * cur % mod; } cur = (long long)cur * cur % mod; y &gt;&gt;= 1; } return ret; }; void dfs(int z){ if(m[z].size() == 0){ v[z] = 1; v1[z] = 1; return; } int n = 0; for(int i = 0; i &lt; m[z].size(); i++){ dfs(m[z][i]); n += v[m[z][i]]; } int n1 = cj[n]; for(int i = 0; i &lt; m[z].size(); i++){ n1 = (long long)n1 * ny[v[m[z][i]]] % mod; n1 = (long long)n1 * v1[m[z][i]] % mod; } v[z] = n+1; v1[z] = n1; } int waysToBuildRooms(vector&lt;int&gt;&amp; prevRoom) { v = vector&lt;int&gt;(prevRoom.size()); v1 = v; for(int i = 1; i &lt; prevRoom.size(); i++){ m[prevRoom[i]].push_back(i); } cj.push_back(1); ny.push_back(1); for(int i = 1; i &lt; prevRoom.size(); i++){ cj.push_back((long long)i*cj.back() % mod); ny.push_back(quickmul(cj.back(), mod-2)); } dfs(0); return v1[0]; } }; 题目地址:https://leetcode-cn.com/problems/count-ways-to-build-rooms-in-an-ant-colony/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1915. 最美子字符串的数目]]></title>
    <url>%2F2021%2F06%2F28%2Fleetcode%201915.%20%E6%9C%80%E7%BE%8E%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：如果某个字符串中 至多一个 字母出现 奇数 次，则称其为 最美 字符串。 例如，”ccjjc” 和 “abab” 都是最美字符串，但 “ab” 不是。 给你一个字符串 word ，该字符串由前十个小写英文字母组成（’a’ 到 ‘j’）。请你返回 word 中 最美非空子字符串 的数目。如果同样的子字符串在 word 中出现多次，那么应当对 每次出现 分别计数。 子字符串 是字符串中的一个连续字符序列。 示例：示例 1： 输入：word = &quot;aba&quot; 输出：4 解释：4 个最美子字符串如下所示： - &quot;aba&quot; -&gt; &quot;a&quot; - &quot;aba&quot; -&gt; &quot;b&quot; - &quot;aba&quot; -&gt; &quot;a&quot; - &quot;aba&quot; -&gt; &quot;aba&quot; 示例 2： 输入：word = &quot;aabb&quot; 输出：9 解释：9 个最美子字符串如下所示： - &quot;aabb&quot; -&gt; &quot;a&quot; - &quot;aabb&quot; -&gt; &quot;aa&quot; - &quot;aabb&quot; -&gt; &quot;aab&quot; - &quot;aabb&quot; -&gt; &quot;aabb&quot; - &quot;aabb&quot; -&gt; &quot;a&quot; - &quot;aabb&quot; -&gt; &quot;abb&quot; - &quot;aabb&quot; -&gt; &quot;b&quot; - &quot;aabb&quot; -&gt; &quot;bb&quot; - &quot;aabb&quot; -&gt; &quot;b&quot; 示例 3： 输入：word = &quot;he&quot; 输出：2 解释：2 个最美子字符串如下所示： - &quot;he&quot; -&gt; &quot;h&quot; - &quot;he&quot; -&gt; &quot;e&quot; 提示： 1 &lt;= word.length &lt;= 10^5 word 由从 ‘a’ 到 ‘j’ 的小写英文字母组成 分析：因为只有十种不同字符，并且每种字符出现的次数有两种可能（奇数或偶数），所以可以状态压缩，用mask[i]存储到i位置字符出现数量为偶数或奇数 可以使用前缀和的方法 word[i…j]每个字母出现次数奇偶： mask[i-1] 等于 mask[j]，woed[i…j]为偶数。 mask[i-1] 不等于 mask[j]，woed[i…j]为奇数。 遍历word，对于每一个word[i]，计算出mask[i]，然后判断之前出现过几次mask[i]这个状态（出现几次就代表可以组成几个符合条件的子字符串）（可以用map的方式存储各个状态出现过的次数） 一个字符出现奇数次可以在遍历word时，对mask[i]中每一位进行修改 在开始遍历之前，需要初始化map，将{0,1}存入（表示全偶数状态出现一次） 代码：class Solution { public: long long wonderfulSubstrings(string word) { long long ret = 0; unordered_map&lt;int, int&gt; m; m[0] = 1; int mask = 0; for(int i = 0; i &lt; word.size(); i++){ int idx = word[i] - &apos;a&apos;; mask ^= (1 &lt;&lt; idx); if(m.count(mask)){ ret += m[mask]; } for(int i = 0; i &lt; 10; i++){ if(m.count(mask ^ (1 &lt;&lt; i))){ ret += m[mask ^ (1 &lt;&lt; i)]; } } m[mask]++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-wonderful-substrings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1914. 循环轮转矩阵]]></title>
    <url>%2F2021%2F06%2F28%2Fleetcode%201914.%20%E5%BE%AA%E7%8E%AF%E8%BD%AE%E8%BD%AC%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目：给你一个大小为 m x n 的整数矩阵 grid​​​ ，其中 m 和 n 都是 偶数 ；另给你一个整数 k 。 矩阵由若干层组成，如下图所示，每种颜色代表一层： https://assets.leetcode.com/uploads/2021/06/10/ringofgrid.png 矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 逆时针 方向的相邻元素。轮转示例如下： https://assets.leetcode.com/uploads/2021/06/22/explanation_grid.jpg 返回执行 k 次循环轮转操作后的矩阵。 示例：示例 1： 输入：grid = [[40,10],[30,20]], k = 1 输出：[[10,20],[40,30]] 解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。 示例 2： 输入：grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2 输出：[[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]] 解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。 提示： m == grid.length n == grid[i].length 2 &lt;= m, n &lt;= 50 m 和 n 都是 偶数 1 &lt;= grid[i][j] &lt;= 5000 1 &lt;= k &lt;= 10^9 分析：按圈获取数字，将获取的数字存入一个数组。对于每个数字i来说，变换后存放位置为（i+k）% 数组长度。之后再按获取数据的方式在写入一遍 代码：class Solution { public: vector&lt;vector&lt;int&gt;&gt; rotateGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) { int m = grid.size(); int n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; ret(m, vector&lt;int&gt;(n, 0)); for(int i = 0; i &lt; (min(m, n)+1) / 2; i++){ vector&lt;int&gt; v; for(int j = i; j &lt; m - i-1; j++){ v.push_back(grid[j][i]); } for(int j = i; j &lt; n - i-1; j++){ v.push_back(grid[m-i-1][j]); } for(int j = m-i-1; j &gt;= i+1; j--){ v.push_back(grid[j][n-i-1]); } for(int j = n-i-1; j &gt;= i+1; j--){ v.push_back(grid[i][j]); } vector&lt;int&gt; v1(v.size(), 0); for(int j = 0; j &lt; v.size(); j++){ v1[(j+k) % v.size()] = v[j]; } int z = 0; for(int j = i; j &lt; m - i-1; j++){ ret[j][i] = v1[z]; z++; } for(int j = i; j &lt; n - i-1; j++){ ret[m-i-1][j] = v1[z]; z++; } for(int j = m-i-1; j &gt;= i+1; j--){ ret[j][n-i-1] = v1[z]; z++; } for(int j = n-i-1; j &gt;= i+1; j--){ ret[i][j] = v1[z]; z++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/cyclically-rotating-a-grid/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1913. 两个数对之间的最大乘积差]]></title>
    <url>%2F2021%2F06%2F28%2Fleetcode%201913.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AF%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[题目：两个数对 (a, b) 和 (c, d) 之间的 乘积差 定义为 (a b) - (c d) 。 例如，(5, 6) 和 (2, 7) 之间的乘积差是 (5 6) - (2 7) = 16 。 给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，使数对 (nums[w], nums[x]) 和 (nums[y], nums[z]) 之间的 乘积差 取到 最大值 。 返回以这种方式取得的乘积差中的 最大值 。 示例：示例 1： 输入：nums = [5,6,2,7,4] 输出：34 解释：可以选出下标为 1 和 3 的元素构成第一个数对 (6, 7) 以及下标 2 和 4 构成第二个数对 (2, 4) 乘积差是 (6 * 7) - (2 * 4) = 34 示例 2： 输入：nums = [4,2,5,9,7,4,8] 输出：64 解释：可以选出下标为 3 和 6 的元素构成第一个数对 (9, 8) 以及下标 1 和 5 构成第二个数对 (2, 4) 乘积差是 (9 * 8) - (2 * 4) = 64 提示： 4 &lt;= nums.length &lt;= 10^4 1 &lt;= nums[i] &lt;= 10^4 分析：排序，找出最大和最小各两个数，按规律运算 代码：class Solution { public: int maxProductDifference(vector&lt;int&gt;&amp; nums) { int s = nums.size(); sort(nums.begin(), nums.end()); return nums[s-2] * nums[s-1] - nums[0] * nums[1]; } }; 题目地址:https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5790. 查询差绝对值的最小值]]></title>
    <url>%2F2021%2F06%2F21%2Fleetcode%205790.%20%E6%9F%A5%E8%AF%A2%E5%B7%AE%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：一个数组 a 的 差绝对值的最小值 定义为：0 &lt;= i &lt; j &lt; a.length 且 a[i] != a[j] 的 |a[i] - a[j]| 的 最小值。如果 a 中所有元素都 相同 ，那么差绝对值的最小值为 -1 。 比方说，数组 [5,2,3,7,2] 差绝对值的最小值是 |2 - 3| = 1 。注意答案不为 0 ，因为 a[i] 和 a[j] 必须不相等。 给你一个整数数组 nums 和查询数组 queries ，其中 queries[i] = [li, ri] 。对于每个查询 i ，计算 子数组 nums[li…ri] 中 差绝对值的最小值 ，子数组 nums[li…ri] 包含 nums 数组（下标从 0 开始）中下标在 li 和 ri 之间的所有元素（包含 li 和 ri 在内）。 请你返回 ans 数组，其中 ans[i] 是第 i 个查询的答案。 子数组 是一个数组中连续的一段元素。 |x| 的值定义为： 如果 x &gt;= 0 ，那么值为 x 。 如果 x &lt; 0 ，那么值为 -x 。 示例：示例 1： 输入：nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]] 输出：[2,1,4,1] 解释：查询结果如下： - queries[0] = [0,1]：子数组是 [1,3] ，差绝对值的最小值为 |1-3| = 2 。 - queries[1] = [1,2]：子数组是 [3,4] ，差绝对值的最小值为 |3-4| = 1 。 - queries[2] = [2,3]：子数组是 [4,8] ，差绝对值的最小值为 |4-8| = 4 。 - queries[3] = [0,3]：子数组是 [1,3,4,8] ，差的绝对值的最小值为 |3-4| = 1 。 示例 2： 输入：nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]] 输出：[-1,1,1,3] 解释：查询结果如下： - queries[0] = [2,3]：子数组是 [2,2] ，差绝对值的最小值为 -1 ，因为所有元素相等。 - queries[1] = [0,2]：子数组是 [4,5,2] ，差绝对值的最小值为 |4-5| = 1 。 - queries[2] = [0,5]：子数组是 [4,5,2,2,7,10] ，差绝对值的最小值为 |4-5| = 1 。 - queries[3] = [3,5]：子数组是 [2,7,10] ，差绝对值的最小值为 |7-10| = 3 。 提示： 2 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 100 1 &lt;= queries.length &lt;= 2 * 10^4 0 &lt;= li &lt; ri &lt; nums.length 分析：nums[i] 的范围只有1到100，可以使用前缀和将其统计。这样就可以快速求出一个区间中各个值的数量。 遍历一遍各个区间，计算各个区间中差绝对值的最小值即可 代码：class Solution { public: vector&lt;int&gt; minDifference(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { vector&lt;vector&lt;int&gt;&gt; pre(nums.size()+5, vector&lt;int&gt;(105, 0)); vector&lt;int&gt; ret; for(int i = 1; i &lt;= nums.size(); i++) { for(int j = 1; j &lt;= 100; j++){ if(j == nums[i-1]){ pre[i][j] = pre[i-1][j] + 1; } else{ pre[i][j] = pre[i-1][j]; } } } for(int i = 0; i &lt; queries.size(); i++){ int l = queries[i][0]+1; int r = queries[i][1]+1; int last = -1; int m = 100; for(int j = 1; j &lt;= 100; j++){ if(pre[r][j] - pre[l-1][j] &gt; 0){ if(last == -1){ last = j; } else{ m = min(m, j - last); last = j; } } } if(m == 100){ ret.push_back(-1); } else{ ret.push_back(m); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-absolute-difference-queries/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5791. 统计子岛屿]]></title>
    <url>%2F2021%2F06%2F21%2Fleetcode%205791.%20%E7%BB%9F%E8%AE%A1%E5%AD%90%E5%B2%9B%E5%B1%BF%2F</url>
    <content type="text"><![CDATA[题目：给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。 如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。 请你返回 grid2 中 子岛屿 的 数目 。 示例：示例 1： 输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]] 输出：3 解释：如上图所示，左边为 grid1 ，右边为 grid2 。 grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。 示例 2： 输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]] 输出：2 解释：如上图所示，左边为 grid1 ，右边为 grid2 。 grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。 提示： m == grid1.length == grid2.length n == grid1[i].length == grid2[i].length 1 &lt;= m, n &lt;= 500 grid1[i][j] 和 grid2[i][j] 都要么是 0 要么是 1 。 分析：grid2中的一个岛屿的陆地在grid1中也是陆地，那么这个岛屿就是子岛屿 使用dfs遍历岛屿 代码：class Solution { int n, m; public: bool dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid1, vector&lt;vector&lt;int&gt;&gt;&amp; grid2, int x, int y){ bool b = true; grid2[x][y] = -1; if(x+1 &lt; n &amp;&amp; grid2[x+1][y] == 1){ if(dfs(grid1, grid2, x+1, y) == false) b = false; } if(x-1 &gt;= 0 &amp;&amp; grid2[x-1][y] == 1){ if(dfs(grid1, grid2, x-1, y) == false) b = false; } if(y+1 &lt; m &amp;&amp; grid2[x][y+1] == 1){ if(dfs(grid1, grid2, x, y+1) == false) b = false; } if(y-1 &gt;= 0 &amp;&amp; grid2[x][y-1] == 1){ if(dfs(grid1, grid2, x, y-1) == false) b = false; } if(grid1[x][y] == 0 || b == false) return false; return true; } int countSubIslands(vector&lt;vector&lt;int&gt;&gt;&amp; grid1, vector&lt;vector&lt;int&gt;&gt;&amp; grid2) { n = grid1.size(); m = grid1[0].size(); int ret = 0; for(int x = 0; x &lt; n; x++){ for(int y = 0; y &lt; m; y++){ if(grid2[x][y] == 1){ if(dfs(grid1, grid2, x, y)) ret++; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-sub-islands/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5789. 你完成的完整对局数]]></title>
    <url>%2F2021%2F06%2F21%2Fleetcode%205789.%20%E4%BD%A0%E5%AE%8C%E6%88%90%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AF%B9%E5%B1%80%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：一款新的在线电子游戏在近期发布，在该电子游戏中，以 刻钟 为周期规划若干时长为 15 分钟 的游戏对局。这意味着，在 HH:00、HH:15、HH:30 和 HH:45 ，将会开始一个新的对局，其中 HH 用一个从 00 到 23 的整数表示。游戏中使用 24 小时制的时钟 ，所以一天中最早的时间是 00:00 ，最晚的时间是 23:59 。 给你两个字符串 startTime 和 finishTime ，均符合 “HH:MM” 格式，分别表示你 进入 和 退出 游戏的确切时间，请计算在整个游戏会话期间，你完成的 完整对局的对局数 。 例如，如果 startTime = “05:20” 且 finishTime = “05:59” ，这意味着你仅仅完成从 05:30 到 05:45 这一个完整对局。而你没有完成从 05:15 到 05:30 的完整对局，因为你是在对局开始后进入的游戏；同时，你也没有完成从 05:45 到 06:00 的完整对局，因为你是在对局结束前退出的游戏。 如果 finishTime 早于 startTime ，这表示你玩了个通宵（也就是从 startTime 到午夜，再从午夜到 finishTime）。 假设你是从 startTime 进入游戏，并在 finishTime 退出游戏，请计算并返回你完成的 完整对局的对局数 。 示例：示例 1： 输入：startTime = &quot;12:01&quot;, finishTime = &quot;12:44&quot; 输出：1 解释：你完成了从 12:15 到 12:30 的一个完整对局。 你没有完成从 12:00 到 12:15 的完整对局，因为你是在对局开始后的 12:01 进入的游戏。 你没有完成从 12:30 到 12:45 的完整对局，因为你是在对局结束前的 12:44 退出的游戏。 示例 2： 输入：startTime = &quot;20:00&quot;, finishTime = &quot;06:00&quot; 输出：40 解释：你完成了从 20:00 到 00:00 的 16 个完整的对局，以及从 00:00 到 06:00 的 24 个完整的对局。 16 + 24 = 40 示例 3： 输入：startTime = &quot;00:00&quot;, finishTime = &quot;23:59&quot; 输出：95 解释：除最后一个小时你只完成了 3 个完整对局外，其余每个小时均完成了 4 场完整对局。 提示： startTime 和 finishTime 的格式为 HH:MM 00 &lt;= HH &lt;= 23 00 &lt;= MM &lt;= 59 startTime 和 finishTime 不相等 分析：将开始时间调整为下一个周期开始，加一次15分钟计数加1，直到超过结束时间为止。 更好的方法，转换成分钟计算 代码：class Solution { public: bool bj(int a1, int a2, int b1, int b2){ if(a1 &gt; b1) return true; if(a1 &lt; b1) return false; if(a2 &gt; b2) return true; if(a2 &lt; b2) return false; return false; } void jia(int &amp;a1, int &amp;a2){ if(a2 + 15 &lt; 60){ a2 += 15; return; } else if(a1 + 1 &lt; 24){ a1++; a2 = 0; return; } else{ a1 = 0; a2 = 0; return; } } void cz(int &amp;a1, int &amp;a2){ if(a2 == 0 || a2 == 15 || a2 == 30 || a2 == 45) return; if(a2 &lt;= 15) a2 = 15; else if(a2 &lt;= 30) a2 = 30; else if(a2 &lt;= 45) a2 = 45; else{ a2 = 0; if(a1 == 23) a1 = 0; else a1++; } } int numberOfRounds(string startTime, string finishTime) { int a1 = stoi(startTime.substr(0, 2)); int a2 = stoi(startTime.substr(3, 2)); int b1 = stoi(finishTime.substr(0, 2)); int b2 = stoi(finishTime.substr(3, 2)); cz(a1, a2); int ret = 0; if(!bj(a1, a2, b1, b2)){ jia(a1, a2); while(!bj(a1, a2, b1, b2) &amp;&amp; bj(a1, a2, 0, 0)){ ret++; jia(a1, a2); } } else{ jia(a1, a2); if(bj(a1, a2, 0, 0)){ while(!bj(a1, a2, 23, 44)){ ret++; jia(a1, a2); } } jia(a1, a2); ret += 1; while(!bj(a1, a2, b1, b2)){ jia(a1, a2); ret++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/the-number-of-full-rounds-you-have-played/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5788. 字符串中的最大奇数]]></title>
    <url>%2F2021%2F06%2F21%2Fleetcode%205788.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%A5%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 num ，表示一个大整数。请你在字符串 num 的所有 非空子字符串 中找出 值最大的奇数 ，并以字符串形式返回。如果不存在奇数，则返回一个空字符串 “” 。 子字符串 是字符串中的一个连续的字符序列。 示例：示例 1： 输入：num = &quot;52&quot; 输出：&quot;5&quot; 解释：非空子字符串仅有 &quot;5&quot;、&quot;2&quot; 和 &quot;52&quot; 。&quot;5&quot; 是其中唯一的奇数。 示例 2： 输入：num = &quot;4206&quot; 输出：&quot;&quot; 解释：在 &quot;4206&quot; 中不存在奇数。 示例 3： 输入：num = &quot;35427&quot; 输出：&quot;35427&quot; 解释：&quot;35427&quot; 本身就是一个奇数。 提示： 1 &lt;= num.length &lt;= 10^5 num 仅由数字组成且不含前导零 分析：贪心 一个数是否是奇数只需要看最后一位，所以从后往前遍历，只要最后一位是奇数，去掉之后的字符，这就是最大的奇数字符串 代码：class Solution { public: string largestOddNumber(string num) { string ret = &quot;&quot;; for(int i = num.size()-1; i &gt;= 0; i--){ if((num[i]-&apos;0&apos;) % 2 == 1){ ret = num.substr(0, i+1); return ret; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/largest-odd-number-in-string/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1900. 最佳运动员的比拼回合]]></title>
    <url>%2F2021%2F06%2F15%2Fleetcode%201900.%20%E6%9C%80%E4%BD%B3%E8%BF%90%E5%8A%A8%E5%91%98%E7%9A%84%E6%AF%94%E6%8B%BC%E5%9B%9E%E5%90%88%2F</url>
    <content type="text"><![CDATA[题目：n 名运动员参与一场锦标赛，所有运动员站成一排，并根据 最开始的 站位从 1 到 n 编号（运动员 1 是这一排中的第一个运动员，运动员 2 是第二个运动员，依此类推）。 锦标赛由多个回合组成（从回合 1 开始）。每一回合中，这一排从前往后数的第 i 名运动员需要与从后往前数的第 i 名运动员比拼，获胜者将会进入下一回合。如果当前回合中运动员数目为奇数，那么中间那位运动员将轮空晋级下一回合。 例如，当前回合中，运动员 1, 2, 4, 6, 7 站成一排 运动员 1 需要和运动员 7 比拼 运动员 2 需要和运动员 6 比拼 运动员 4 轮空晋级下一回合 每回合结束后，获胜者将会基于最开始分配给他们的原始顺序（升序）重新排成一排。 编号为 firstPlayer 和 secondPlayer 的运动员是本场锦标赛中的最佳运动员。在他们开始比拼之前，完全可以战胜任何其他运动员。而任意两个其他运动员进行比拼时，其中任意一个都有获胜的可能，因此你可以 裁定 谁是这一回合的获胜者。 给你三个整数 n、firstPlayer 和 secondPlayer 。返回一个由两个值组成的整数数组，分别表示两位最佳运动员在本场锦标赛中比拼的 最早 回合数和 最晚 回合数。 示例：示例 1： 输入：n = 11, firstPlayer = 2, secondPlayer = 4 输出：[3,4] 解释： 一种能够产生最早回合数的情景是： 回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 回合 2：2, 3, 4, 5, 6, 11 回合 3：2, 3, 4 一种能够产生最晚回合数的情景是： 回合 1：1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 回合 2：1, 2, 3, 4, 5, 6 回合 3：1, 2, 4 回合 4：2, 4 示例 2： 输入：n = 5, firstPlayer = 1, secondPlayer = 5 输出：[1,1] 解释：两名最佳运动员 1 和 5 将会在回合 1 进行比拼。 不存在使他们在其他回合进行比拼的可能。 提示： 2 &lt;= n &lt;= 28 1 &lt;= firstPlayer &lt; secondPlayer &lt;= n 分析： 因为相对称的两位运动员会合并，所以相互交换后结果不会改变 因为两名最佳运动员一定获胜，所以两个最佳运动员之间位置进行交换也不影响结果 使用这两条原则可以保证f永远在s之前，并且f永远在左侧，这样根据s的位置，就只有三种可能了：s在左侧，s在中间，s在右边 具体见代码 代码：class Solution { private: int F[30][30][30], G[30][30][30]; public: // 返回值中前一个数为最快相遇回合数，后一个为最慢相遇回合数 pair&lt;int, int&gt; dp(int n, int f, int s){ // 当出现已经计算过的情况时直接返回 if(F[n][f][s]) return {F[n][f][s], G[n][f][s]}; // 如果两名运动员对上的话，直接返回 if(f+s == n+1) return {1, 1}; // f+s &gt; n+1 的情况下有两种可能 // 现在f位于中间或右侧 // 合并后会让s来到f之前 // 通过交换可以解决这个问题 if(f+s &gt; n+1){ auto a = dp(n, n + 1 - s, n + 1 - f); F[n][f][s] = a.first; G[n][f][s] = a.second; return a; } int earlist = INT_MAX; int latest = INT_MIN; int n_half = (n+1)/2; if(s &lt;= n_half){ // s在左侧或中间 // i表示f之前的运动员个数（包括f），也就会f位于第i位 // j表示f和s之间的运动员个数（包括s），也就是s位于第i+j位 for(int i = 1; i &lt;= f; i++){ for(int j = 1; j &lt;= s-f; j++){ auto a = dp(n_half, i, i+j); earlist = min(a.first, earlist); latest = max(a.second, latest); } } } else{ // s在右侧 int s_prime = n+1-s; // s_prime为s对称的位置 int mid = (n - 2 * s_prime + 1) / 2; // mid为s和s_prime中间的运动员数量除以2（向上取整） // i表示f之前的运动员个数（包括f），也就会f位于第i位 // j表示f和s_prime之间的运动员个数（包括s），也就是s位于第i+j+mid位（因为s运动员必胜，所以需要加上mid） for(int i = 1; i &lt;= f; i++){ for(int j = 1; j &lt;= s_prime - f; j++){ auto a = dp(n_half, i, i + j + mid); earlist = min(a.first, earlist); latest = max(a.second, latest); } } } return {F[n][f][s] = earlist + 1, G[n][f][s] = latest + 1}; } vector&lt;int&gt; earliestAndLatest(int n, int firstPlayer, int secondPlayer) { // 初始化 memset(F, 0, sizeof(F)); memset(G, 0, sizeof(G)); vector&lt;int&gt; ret; auto a = dp(n, firstPlayer, secondPlayer); ret.push_back(a.first); ret.push_back(a.second); return ret; } }; 题目地址:https://leetcode-cn.com/problems/the-earliest-and-latest-rounds-where-players-compete/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1899. 合并若干三元组以形成目标三元组]]></title>
    <url>%2F2021%2F06%2F15%2Fleetcode%201899.%20%E5%90%88%E5%B9%B6%E8%8B%A5%E5%B9%B2%E4%B8%89%E5%85%83%E7%BB%84%E4%BB%A5%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E4%B8%89%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：三元组 是一个由三个整数组成的数组。给你一个二维整数数组 triplets ，其中 triplets[i] = [ai, bi, ci] 表示第 i 个 三元组 。同时，给你一个整数数组 target = [x, y, z] ，表示你想要得到的 三元组 。 为了得到 target ，你需要对 triplets 执行下面的操作 任意次（可能 零 次）： 选出两个下标（下标 从 0 开始 计数）i 和 j（i != j），并 更新 triplets[j] 为 [max(ai, aj), max(bi, bj), max(ci, cj)] 。 例如，triplets[i] = [2, 5, 3] 且 triplets[j] = [1, 7, 5]，triplets[j] 将会更新为 [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5] 。 如果通过以上操作我们可以使得目标 三元组 target 成为 triplets 的一个 元素 ，则返回 true ；否则，返回 false 。 示例：示例 1： 输入：triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5] 输出：true 解释：执行下述操作： - 选择第一个和最后一个三元组 [[2,5,3],[1,8,4],[1,7,5]] 。更新最后一个三元组为 [max(2,1), max(5,7), max(3,5)] = [2,7,5] 。triplets = [[2,5,3],[1,8,4],[2,7,5]] 目标三元组 [2,7,5] 现在是 triplets 的一个元素。 示例 2： 输入：triplets = [[1,3,4],[2,5,8]], target = [2,5,8] 输出：true 解释：目标三元组 [2,5,8] 已经是 triplets 的一个元素。 示例 3： 输入：triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5] 输出：true 解释：执行下述操作： - 选择第一个和第三个三元组 [[2,5,3],[2,3,4],[1,2,5],[5,2,3]] 。更新第三个三元组为 [max(2,1), max(5,2), max(3,5)] = [2,5,5] 。triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]] 。 - 选择第三个和第四个三元组 [[2,5,3],[2,3,4],[2,5,5],[5,2,3]] 。更新第四个三元组为 [max(2,5), max(5,2), max(5,3)] = [5,5,5] 。triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]] 。 目标三元组 [5,5,5] 现在是 triplets 的一个元素。 示例 4： 输入：triplets = [[3,4,5],[4,5,6]], target = [3,2,5] 输出：false 解释：无法得到 [3,2,5] ，因为 triplets 不含 2 。 提示：1 &lt;= triplets.length &lt;= 10^5triplets[i].length == target.length == 31 &lt;= ai, bi, ci, x, y, z &lt;= 1000 分析：两个三元组合并得到的三元组为各个位的最大值，也就是说对于三元组（a,b,c）中其中一位，比如 a 的值符合target，只要剩下两位b和c小于等于target中对应的值，那么这个三元组与其他三元组合并的话可以满足a的值并且不影响b和c的值。 遍历所有的三元组，对每一位进行判断，如果三个位置都有合适的三元组，就返回true，否则返回false 代码：class Solution { public: bool mergeTriplets(vector&lt;vector&lt;int&gt;&gt;&amp; triplets, vector&lt;int&gt;&amp; target) { bool a = false; bool b = false; bool c = false; for(int i = 0; i &lt; triplets.size(); i++){ if(triplets[i][0] == target[0] &amp;&amp; triplets[i][1] &lt;= target[1] &amp;&amp; triplets[i][2] &lt;= target[2]){ a = true; } if(triplets[i][1] == target[1] &amp;&amp; triplets[i][0] &lt;= target[0] &amp;&amp; triplets[i][2] &lt;= target[2]){ b = true; } if(triplets[i][2] == target[2] &amp;&amp; triplets[i][0] &lt;= target[0] &amp;&amp; triplets[i][1] &lt;= target[1]){ c = true; } } if(a &amp;&amp; b &amp;&amp; c) return true; return false; } }; 题目地址:https://leetcode-cn.com/problems/merge-triplets-to-form-target-triplet/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1898. 可移除字符的最大数目]]></title>
    <url>%2F2021%2F06%2F15%2Fleetcode%201898.%20%E5%8F%AF%E7%A7%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你两个字符串 s 和 p ，其中 p 是 s 的一个 子序列 。同时，给你一个元素 互不相同 且下标 从 0 开始 计数的整数数组 removable ，该数组是 s 中下标的一个子集（s 的下标也 从 0 开始 计数）。 请你找出一个整数 k（0 &lt;= k &lt;= removable.length），选出 removable 中的 前 k 个下标，然后从 s 中移除这些下标对应的 k 个字符。整数 k 需满足：在执行完上述步骤后， p 仍然是 s 的一个 子序列 。更正式的解释是，对于每个 0 &lt;= i &lt; k ，先标记出位于 s[removable[i]] 的字符，接着移除所有标记过的字符，然后检查 p 是否仍然是 s 的一个子序列。 返回你可以找出的 最大 k ，满足在移除字符后 p 仍然是 s 的一个子序列。 字符串的一个 子序列 是一个由原字符串生成的新字符串，生成过程中可能会移除原字符串中的一些字符（也可能不移除）但不改变剩余字符之间的相对顺序。 示例：示例 1： 输入：s = &quot;abcacb&quot;, p = &quot;ab&quot;, removable = [3,1,0] 输出：2 解释：在移除下标 3 和 1 对应的字符后，&quot;abcacb&quot; 变成 &quot;accb&quot; 。 &quot;ab&quot; 是 &quot;accb&quot; 的一个子序列。 如果移除下标 3、1 和 0 对应的字符后，&quot;abcacb&quot; 变成 &quot;ccb&quot; ，那么 &quot;ab&quot; 就不再是 s 的一个子序列。 因此，最大的 k 是 2 。 示例 2： 输入：s = &quot;abcbddddd&quot;, p = &quot;abcd&quot;, removable = [3,2,1,4,5,6] 输出：1 解释：在移除下标 3 对应的字符后，&quot;abcbddddd&quot; 变成 &quot;abcddddd&quot; 。 &quot;abcd&quot; 是 &quot;abcddddd&quot; 的一个子序列。 示例 3： 输入：s = &quot;abcab&quot;, p = &quot;abc&quot;, removable = [0,1,2,3,4] 输出：0 解释：如果移除数组 removable 的第一个下标，&quot;abc&quot; 就不再是 s 的一个子序列。 提示：= 1 &lt;= p.length &lt;= s.length &lt;= 10^5 0 &lt;= removable.length &lt; s.length 0 &lt;= removable[i] &lt; s.length p 是 s 的一个 子字符串 s 和 p 都由小写英文字母组成 removable 中的元素 互不相同 分析：如果删除k个字依旧后 p 仍然是 s 的一个 子序列，那么删除k-1个字符 p 也是 s 的一个 子序列，反之同理。 这样就可以使用二分来确定k的值 代码：class Solution { public: int maximumRemovals(string s, string p, vector&lt;int&gt;&amp; removable) { int l = 0; int r = removable.size()-1; int b1 = 0; int b2 = 0; string s2 = s; s2[removable[0]] = 1; while(b2 &lt; p.size() &amp;&amp; b1 &lt; s2.size()){ if(s2[b1] == p[b2]){ b2++; if(b2 == p.size()) break; } b1++; } if(b2 != p.size()) return 0; while(l &lt; r){ int m = (l+r+1)/2; string s1 = s; for(int i = 0; i &lt;= m; i++){ s1[removable[i]] = 1; } int a1 = 0; int a2 = 0; while(a2 &lt; p.size() &amp;&amp; a1 &lt; s1.size()){ if(s1[a1] == p[a2]){ a2++; if(a2 == p.size()) break; } a1++; } if(a2 == p.size()) l = m; else{ r = m-1; } } return l+1; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-removable-characters/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1897. 重新分配字符使所有字符串都相等]]></title>
    <url>%2F2021%2F06%2F15%2Fleetcode%201897.%20%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E5%AD%97%E7%AC%A6%E4%BD%BF%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E7%9B%B8%E7%AD%89%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串数组 words（下标 从 0 开始 计数）。 在一步操作中，需先选出两个 不同 下标 i 和 j，其中 words[i] 是一个非空字符串，接着将 words[i] 中的 任一 字符移动到 words[j] 中的 任一 位置上。 如果执行任意步操作可以使 words 中的每个字符串都相等，返回 true ；否则，返回 false 。 示例：示例 1： 输入：words = [&quot;abc&quot;,&quot;aabc&quot;,&quot;bc&quot;] 输出：true 解释：将 words[1] 中的第一个 &apos;a&apos; 移动到 words[2] 的最前面。 使 words[1] = &quot;abc&quot; 且 words[2] = &quot;abc&quot; 。 所有字符串都等于 &quot;abc&quot; ，所以返回 true 。 示例 2： 输入：words = [&quot;ab&quot;,&quot;a&quot;] 输出：false 解释：执行操作无法使所有字符串都相等。 提示： 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 100 words[i] 由小写英文字母组成 分析：统计所有字符出现数量，判断是否可以平均分 代码：class Solution { public: bool makeEqual(vector&lt;string&gt;&amp; words) { vector&lt;int&gt; m(26, 0); for(int i = 0; i &lt; words.size(); i++){ for(int j = 0; j &lt; words[i].size(); j++){ m[words[i][j]-&apos;a&apos;]++; } } for(int i = 0; i &lt; m.size(); i++){ if(m[i] % words.size() != 0) return false; } return true; } }; 题目地址:https://leetcode-cn.com/problems/redistribute-characters-to-make-all-strings-equal/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>%2F2021%2F06%2F08%2F%E5%AE%89%E5%8D%93pc%E5%89%AA%E8%B4%B4%E6%9D%BF%E4%BA%92%E8%81%94%2F</url>
    <content type="text"><![CDATA[pc端前期准备 使用c++ 编译器cfree5 配置cfree 5 支持C++11 https://blog.csdn.net/cwl353253492/article/details/47127955 C-free5中使用ws2_32.lib包 会报错，解决方式：http://blog.sina.com.cn/s/blog_9f1f76e50102wbqb.html 使用到的头文件 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;WinSock2.h&gt; #pragma comment(lib, &quot;ws2_32.lib&quot;) //加载 ws2_32.dll #include &lt;thread&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;iostream&gt; 具体思路 socket套接字传输数据：https://blog.csdn.net/weixin_42351003/article/details/80519029 对客户端和服务器端各创建两个线程分别用于接受和发送：https://blog.csdn.net/u011808673/article/details/80811998 使用一个string存储当前剪贴板内容 发送线程，每隔一秒检测一次剪贴板，如果和上次不同，发送当前剪贴板中的内容，并更新string 接收线程接收到数据后同步剪贴板并且更新string 读取和写入剪贴板：https://zhuanlan.zhihu.com/p/33757669]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1889. 装包裹的最小浪费空间]]></title>
    <url>%2F2021%2F06%2F07%2Fleetcode%201889.%20%E8%A3%85%E5%8C%85%E8%A3%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B5%AA%E8%B4%B9%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：给你 n 个包裹，你需要把它们装在箱子里，每个箱子装一个包裹。总共有 m 个供应商提供 不同尺寸 的箱子（每个规格都有无数个箱子）。如果一个包裹的尺寸 小于等于 一个箱子的尺寸，那么这个包裹就可以放入这个箱子之中。 包裹的尺寸用一个整数数组 packages 表示，其中 packages[i] 是第 i 个包裹的尺寸。供应商用二维数组 boxes 表示，其中 boxes[j] 是第 j 个供应商提供的所有箱子尺寸的数组。 你想要选择 一个供应商 并只使用该供应商提供的箱子，使得 总浪费空间最小 。对于每个装了包裹的箱子，我们定义 浪费的 空间等于 箱子的尺寸 - 包裹的尺寸 。总浪费空间 为 所有 箱子中浪费空间的总和。 比方说，如果你想要用尺寸数组为 [4,8] 的箱子装下尺寸为 [2,3,5] 的包裹，你可以将尺寸为 2 和 3 的两个包裹装入两个尺寸为 4 的箱子中，同时把尺寸为 5 的包裹装入尺寸为 8 的箱子中。总浪费空间为 (4-2) + (4-3) + (8-5) = 6 。 请你选择 最优 箱子供应商，使得 总浪费空间最小 。如果 无法 将所有包裹放入箱子中，请你返回 -1 。由于答案可能会 很大 ，请返回它对 109 + 7 取余 的结果。 示例：示例 1： 输入：packages = [2,3,5], boxes = [[4,8],[2,8]] 输出：6 解释：选择第一个供应商最优，用两个尺寸为 4 的箱子和一个尺寸为 8 的箱子。 总浪费空间为 (4-2) + (4-3) + (8-5) = 6 。 示例 2： 输入：packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]] 输出：-1 解释：没有箱子能装下尺寸为 5 的包裹。 示例 3： 输入：packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]] 输出：9 解释：选择第三个供应商最优，用两个尺寸为 5 的箱子，两个尺寸为 10 的箱子和两个尺寸为 14 的箱子。 总浪费空间为 (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9 。 提示： n == packages.length m == boxes.length 1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^5 1 &lt;= packages[i] &lt;= 10^5 1 &lt;= boxes[j].length &lt;= 10^5 1 &lt;= boxes[j][k] &lt;= 10^5 sum(boxes[j].length) &lt;= 10^5 boxes[j] 中的元素 互不相同 。 分析：直接遍历，需要的时间复杂度为O(n*m)，可以将其中的n转换成logn 将包裹排序，每个供应商的箱子也排序 对于每个箱子，用二分法找到合适的最大包裹，只要记录剩余的尺寸最小的包裹，那么这两个之间的包裹都可以装入这个箱子 可以预处理包裹前缀和，方便计算每种盒子浪费的空间数量 代码：class Solution { public: int minWastedSpace(vector&lt;int&gt;&amp; packages, vector&lt;vector&lt;int&gt;&gt;&amp; boxes) { long long ret = LLONG_MAX; for(int i = 0; i &lt; boxes.size(); i++) sort(boxes[i].begin(), boxes[i].end()); sort(packages.begin(), packages.end()); vector&lt;long long&gt; pre(packages.size(), 0); pre[0] = packages[0]; for(int i = 1; i &lt; packages.size(); i++){ pre[i] = pre[i-1] + packages[i]; } for(int i = 0; i &lt; boxes.size(); i++){ long long total = 0; int last = 0; if(boxes[i].back() &lt; packages.back()) continue; // 如果所有箱子都不够大，跳过 for(int j = 0; j &lt; boxes[i].size(); j++){ if(packages[last] &gt; boxes[i][j]) continue; // 如果当前箱子不够大，跳过 int l = 0; int r = packages.size()-1; while(l &lt; r){ int m = (l+r+1)/2; if(packages[m] &gt; boxes[i][j]) r = m-1; else{ l = m; } } if(last == 0) total += (l-last+1)*(long long)boxes[i][j] - pre[l]; else total += (l-last+1)*(long long)boxes[i][j] - (pre[l] - pre[last-1]); last = l+1; if(last == packages.size()) break; // 全部包裹已装完，退出循环 } // cout &lt;&lt; total &lt;&lt; &quot; &quot;; ret = min(total, ret); } if(ret == LLONG_MAX) return -1; ret %= 1000000007; return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-space-wasted-from-packaging/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1888. 使二进制字符串字符交替的最少反转次数]]></title>
    <url>%2F2021%2F06%2F07%2Fleetcode%201888.%20%E4%BD%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E7%AC%A6%E4%BA%A4%E6%9B%BF%E7%9A%84%E6%9C%80%E5%B0%91%E5%8F%8D%E8%BD%AC%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个二进制字符串 s 。你可以按任意顺序执行以下两种操作任意次： 类型 1 ：删除 字符串 s 的第一个字符并将它 添加 到字符串结尾。 类型 2 ：选择 字符串 s 中任意一个字符并将该字符 反转 ，也就是如果值为 ‘0’ ，则反转得到 ‘1’ ，反之亦然。 请你返回使 s 变成 交替 字符串的前提下， 类型 2 的 最少 操作次数 。 我们称一个字符串是 交替 的，需要满足任意相邻字符都不同。 比方说，字符串 “010” 和 “1010” 都是交替的，但是字符串 “0100” 不是。 示例：示例 1： 输入：s = &quot;111000&quot; 输出：2 解释：执行第一种操作两次，得到 s = &quot;100011&quot; 。 然后对第三个和第六个字符执行第二种操作，得到 s = &quot;101010&quot; 。 示例 2： 输入：s = &quot;010&quot; 输出：0 解释：字符串已经是交替的。 示例 3： 输入：s = &quot;1110&quot; 输出：1 解释：对第二个字符执行第二种操作，得到 s = &quot;1010&quot; 。 提示： 1 &lt;= s.length &lt;= 105 s[i] 要么是 ‘0’ ，要么是 ‘1’ 。 分析：首先求出以0开头和以1开头需要操作的次数 第一种操作将一个数移到末尾并且要保持0101或1010有两种可能 字符串数量为偶数：1010 移动后 0101。只是将1移动到了后面，并没有改变 字符串数量为奇数：101 移动后 011。根据原先第一个数字进行改变，如当前状况下：当第一位为0时，101状态下进行了一次 类型 2 操作，移动后，就可以撤销此次操作。 代码：class Solution { public: int minFlips(string s) { int a = 0; int b = 0; bool bo = true; int ret = INT_MAX; for(int i = 0; i &lt; s.size(); i++){ if(bo == true){ if(s[i] == &apos;1&apos;){ a++; } bo = false; } else{ if(s[i] == &apos;0&apos;){ a++; } bo = true; } } bo = true; for(int i = 0; i &lt; s.size(); i++){ if(bo == true){ if(s[i] == &apos;0&apos;){ b++; } bo = false; } else{ if(s[i] == &apos;1&apos;){ b++; } bo = true; } } if(s.size() % 2 == 0){ return min(a, b); } for(int i = 0; i &lt; s.size(); i++){ if(s[i] == &apos;0&apos;){ a++; b--; } else{ a--; b++; } int c = a; a = b; b = c; ret = min(ret, a); ret = min(ret, b); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1887. 使数组元素相等的减少操作次数]]></title>
    <url>%2F2021%2F06%2F07%2Fleetcode%201887.%20%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89%E7%9A%84%E5%87%8F%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums ，你的目标是令 nums 中的所有元素相等。完成一次减少操作需要遵照下面的几个步骤： 找出 nums 中的 最大 值。记这个值为 largest 并取其下标 i （下标从 0 开始计数）。如果有多个元素都是最大值，则取最小的 i 。 找出 nums 中的 下一个最大 值，这个值 严格小于 largest ，记为 nextLargest 。 将 nums[i] 减少到 nextLargest 。 返回使 nums 中的所有元素相等的操作次数。 示例：示例 1： 输入：nums = [5,1,3] 输出：3 解释：需要 3 次操作使 nums 中的所有元素相等： 1. largest = 5 下标为 0 。nextLargest = 3 。将 nums[0] 减少到 3 。nums = [3,1,3] 。 2. largest = 3 下标为 0 。nextLargest = 1 。将 nums[0] 减少到 1 。nums = [1,1,3] 。 3. largest = 3 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [1,1,1] 。 示例 2： 输入：nums = [1,1,1] 输出：0 解释：nums 中的所有元素已经是相等的。 示例 3： 输入：nums = [1,1,2,2,3] 输出：4 解释：需要 4 次操作使 nums 中的所有元素相等： 1. largest = 3 下标为 4 。nextLargest = 2 。将 nums[4] 减少到 2 。nums = [1,1,2,2,2] 。 2. largest = 2 下标为 2 。nextLargest = 1 。将 nums[2] 减少到 1 。nums = [1,1,1,2,2] 。 3. largest = 2 下标为 3 。nextLargest = 1 。将 nums[3] 减少到 1 。nums = [1,1,1,1,2] 。 4. largest = 2 下标为 4 。nextLargest = 1 。将 nums[4] 减少到 1 。nums = [1,1,1,1,1] 。 提示： 1 &lt;= nums.length &lt;= 5 * 104 1 &lt;= nums[i] &lt;= 5 * 104 分析：先排序，遍历一遍数组，得到每个数是第几小的（最小的不需要操作，第二小的需要一次操作，以此类推），将需要的操作数相加 代码：class Solution { public: int reductionOperations(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); int ret = 0; int num = 0; for(int i = 1; i &lt; nums.size(); i++){ if(nums[i] != nums[i-1]){ num++; } ret += num; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/reduction-operations-to-make-the-array-elements-equal/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2021%2F06%2F07%2Fleetcode%201886.%20%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E7%BB%8F%E8%BD%AE%E8%BD%AC%E5%90%8E%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4%2F</url>
    <content type="text"><![CDATA[题目：给你两个大小为 n x n 的二进制矩阵 mat 和 target 。现 以 90 度顺时针轮转 矩阵 mat 中的元素 若干次 ，如果能够使 mat 与 target 一致，返回 true ；否则，返回 false 。 示例：示例 1： 输入：mat = [[0,1],[1,0]], target = [[1,0],[0,1]] 输出：true 解释：顺时针轮转 90 度一次可以使 mat 和 target 一致。 示例 2： 输入：mat = [[0,1],[1,1]], target = [[1,0],[0,1]] 输出：false 解释：无法通过轮转矩阵中的元素使 equal 与 target 一致。 示例 3： 输入：mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]] 输出：true 解释：顺时针轮转 90 度两次可以使 mat 和 target 一致。 提示： n == mat.length == target.length n == mat[i].length == target[i].length 1 &lt;= n &lt;= 10 mat[i][j] 和 target[i][j] 不是 0 就是 1 分析：旋转矩阵，对每种情况进行比较 代码：class Solution { public: bool duibi(vector&lt;vector&lt;int&gt;&gt;&amp; a, vector&lt;vector&lt;int&gt;&gt;&amp; b){ int s = a.size(); for(int x = 0; x &lt; s; x++){ for(int y = 0; y &lt; s; y++){ if(a[x][y] != b[x][y]) return false; } } return true; } bool findRotation(vector&lt;vector&lt;int&gt;&gt;&amp; mat, vector&lt;vector&lt;int&gt;&gt;&amp; target) { vector&lt;vector&lt;int&gt;&gt; a = mat; vector&lt;vector&lt;int&gt;&gt; b = mat; int s = mat.size(); for(int i = 0; i &lt; 4; i++){ for(int x = 0; x &lt; s; x++){ for(int y = 0; y &lt; s; y++){ b[y][s-x-1] = a[x][y]; } } a = b; for(int x = 0; x &lt; s; x++){ for(int y = 0; y &lt; s; y++){ if(duibi(a, target)) return true; } } } return false; } }; 题目地址:https://leetcode-cn.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1883. 准时抵达会议现场的最小跳过休息次数]]></title>
    <url>%2F2021%2F05%2F31%2Fleetcode%201883.%20%E5%87%86%E6%97%B6%E6%8A%B5%E8%BE%BE%E4%BC%9A%E8%AE%AE%E7%8E%B0%E5%9C%BA%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%B3%E8%BF%87%E4%BC%91%E6%81%AF%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 hoursBefore ，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经 n 条道路。道路的长度用一个长度为 n 的整数数组 dist 表示，其中 dist[i] 表示第 i 条道路的长度（单位：千米）。另给你一个整数 speed ，表示你在道路上前进的速度（单位：千米每小时）。 当你通过第 i 条路之后，就必须休息并等待，直到 下一个整数小时 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。 例如，如果你通过一条道路用去 1.4 小时，那你必须停下来等待，到 2 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 2 小时，就无需等待，可以直接继续。 然而，为了能准时到达，你可以选择 跳过 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。 例如，假设通过第 1 条道路用去 1.4 小时，且通过第 2 条道路用去 0.6 小时。跳过第 1 条道路的休息时间意味着你将会在恰好 2 小时完成通过第 2 条道路，且你能够立即开始通过第 3 条道路。 返回准时抵达会议现场所需要的 最小跳过次数 ，如果 无法准时参会 ，返回 -1 。 示例：示例 1： 输入：dist = [1,3,2], speed = 4, hoursBefore = 2 输出：1 解释： 不跳过任何休息时间，你将用 (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 小时才能抵达会议现场。 可以跳过第 1 次休息时间，共用 ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 小时抵达会议现场。 注意，第 2 次休息时间缩短为 0 ，由于跳过第 1 次休息时间，你是在整数小时处完成通过第 2 条道路。 示例 2： 输入：dist = [7,3,5,5], speed = 2, hoursBefore = 10 输出：2 解释： 不跳过任何休息时间，你将用 (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 小时才能抵达会议现场。 可以跳过第 1 次和第 3 次休息时间，共用 ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 小时抵达会议现场。 示例 3： 输入：dist = [7,3,5,5], speed = 1, hoursBefore = 10 输出：-1 解释：即使跳过所有的休息时间，也无法准时参加会议。 提示： n == dist.length 1 &lt;= n &lt;= 1000 1 &lt;= dist[i] &lt;= 10^5 1 &lt;= speed &lt;= 10^6 1 &lt;= hoursBefore &lt;= 10^7 分析：动态规划 dp[i][j]，表示当经过第i条道路并跳过了j次休息所花的时间 两种状态转移，取其中时间短的 当前道路不跳过：dp[i][j] = ceil(dp[i-1][j] + dist[i] / speed) 当前道路跳过：dp[i][j] = dp[i-1][j-1] + dist[i] / speed 当 j=0 时，不能通过 跳过 进行转移；当 j=i 时，不能通过 不跳过 进行转移 初始化dp[0][0] = 0，因为在没有经过任何路时花费时间为0 因为涉及到了浮点数，而浮点数在计算机中存储精度有限，所以要避免误差https://leetcode-cn.com/problems/minimum-skips-to-arrive-at-meeting-on-time/solution/minimum-skips-to-arrive-at-meeting-on-ti-dp7v/ 代码：class Solution { public: int minSkips(vector&lt;int&gt;&amp; dist, int speed, int hoursBefore) { vector&lt;vector&lt;double&gt;&gt; dp(dist.size()+1, vector&lt;double&gt;(dist.size()+1, INT_MAX)); dp[0][0] = 0; for(int i = 1; i &lt;= dist.size(); i++){ for(int j = 0; j &lt;= i; j++){ if(j != i) dp[i][j] = ceil(dp[i-1][j] + (double)dist[i-1] / speed - 0.00000001); if(j != 0) dp[i][j] = min(dp[i-1][j-1] + (double)dist[i-1] / speed, dp[i][j]); } } for(int i = 0; i &lt;= dist.size(); i++){ if(dp[dist.size()][i] - 0.00000001 &lt; hoursBefore) return i; } return -1; } }; 题目地址:https://leetcode-cn.com/problems/minimum-skips-to-arrive-at-meeting-on-time/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1882. 使用服务器处理任务]]></title>
    <url>%2F2021%2F05%2F31%2Fleetcode%201882.%20%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[题目：给你两个 下标从 0 开始 的整数数组 servers 和 tasks ，长度分别为 n​​​​​​ 和 m​​​​​​ 。servers[i] 是第 i​​​​​​​​​​ 台服务器的 权重 ，而 tasks[j] 是处理第 j​​​​​​ 项任务 所需要的时间（单位：秒）。 你正在运行一个仿真系统，在处理完所有任务后，该系统将会关闭。每台服务器只能同时处理一项任务。第 0 项任务在第 0 秒可以开始处理，相应地，第 j 项任务在第 j 秒可以开始处理。处理第 j 项任务时，你需要为它分配一台 权重最小 的空闲服务器。如果存在多台相同权重的空闲服务器，请选择 下标最小 的服务器。如果一台空闲服务器在第 t 秒分配到第 j 项任务，那么在 t + tasks[j] 时它将恢复空闲状态。 如果没有空闲服务器，则必须等待，直到出现一台空闲服务器，并 尽可能早 地处理剩余任务。 如果有多项任务等待分配，则按照 下标递增 的顺序完成分配。 如果同一时刻存在多台空闲服务器，可以同时将多项任务分别分配给它们。 构建长度为 m 的答案数组 ans ，其中 ans[j] 是第 j 项任务分配的服务器的下标。 返回答案数组 ans​​​​ 。 示例：示例 1： 输入：servers = [3,3,2], tasks = [1,2,3,2,1,2] 输出：[2,2,0,2,1,2] 解释：事件按时间顺序如下： - 0 秒时，第 0 项任务加入到任务队列，使用第 2 台服务器处理到 1 秒。 - 1 秒时，第 2 台服务器空闲，第 1 项任务加入到任务队列，使用第 2 台服务器处理到 3 秒。 - 2 秒时，第 2 项任务加入到任务队列，使用第 0 台服务器处理到 5 秒。 - 3 秒时，第 2 台服务器空闲，第 3 项任务加入到任务队列，使用第 2 台服务器处理到 5 秒。 - 4 秒时，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 5 秒。 - 5 秒时，所有服务器都空闲，第 5 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。 示例 2： 输入：servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1] 输出：[1,4,1,4,1,3,2] 解释：事件按时间顺序如下： - 0 秒时，第 0 项任务加入到任务队列，使用第 1 台服务器处理到 2 秒。 - 1 秒时，第 1 项任务加入到任务队列，使用第 4 台服务器处理到 2 秒。 - 2 秒时，第 1 台和第 4 台服务器空闲，第 2 项任务加入到任务队列，使用第 1 台服务器处理到 4 秒。 - 3 秒时，第 3 项任务加入到任务队列，使用第 4 台服务器处理到 7 秒。 - 4 秒时，第 1 台服务器空闲，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 9 秒。 - 5 秒时，第 5 项任务加入到任务队列，使用第 3 台服务器处理到 7 秒。 - 6 秒时，第 6 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。 提示： servers.length == n tasks.length == m 1 &lt;= n, m &lt;= 2 * 10^5 1 &lt;= servers[i], tasks[j] &lt;= 2 * 10^5 分析：使用两个有序队列idle和busy idle存储可以使用的服务器，格式为（权重，下标） busy存储无法使用的服务器，格式为（结束时间，下标） 声明一个时间戳t 遍历tasks，用i来表示下标 将t设置为i和t的最大值，因为i为任务开始的时间 将结束时间小于等于i的服务器移入idle 如果当前有空余服务器，使用服务器 如果当前没有空余服务器，将时间戳设置为busy队首的结束时间，重复第二步和第三步 代码：class Solution { public: vector&lt;int&gt; assignTasks(vector&lt;int&gt;&amp; servers, vector&lt;int&gt;&amp; tasks) { priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,greater&lt;pair&lt;int,int&gt; &gt; &gt; idle; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,greater&lt;pair&lt;int,int&gt; &gt; &gt; busy; vector&lt;int&gt; ret; int t = 0; for(int i = 0; i &lt; servers.size(); i++){ idle.push(pair&lt;int,int&gt; (servers[i], i)); } for(int i = 0; i &lt; tasks.size(); i++){ t = max(i, t); while(busy.size() != 0 &amp;&amp; busy.top().first == t){ idle.push(pair&lt;int,int&gt;(servers[busy.top().second], busy.top().second)); busy.pop(); } if(idle.size() &gt; 0){ pair&lt;int,int&gt; p = idle.top(); idle.pop(); ret.push_back(p.second); busy.push(pair&lt;int,int&gt;(t+tasks[i], p.second)); } else{ t = busy.top().first; while(busy.size() != 0 &amp;&amp; busy.top().first == t){ idle.push(pair&lt;int,int&gt;(servers[busy.top().second], busy.top().second)); busy.pop(); } pair&lt;int,int&gt; p = idle.top(); idle.pop(); ret.push_back(p.second); busy.push(pair&lt;int,int&gt;(t+tasks[i], p.second)); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/process-tasks-using-servers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1881. 插入后的最大值]]></title>
    <url>%2F2021%2F05%2F31%2Fleetcode%201881.%20%E6%8F%92%E5%85%A5%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个非常大的整数 n 和一个整数数字 x ，大整数 n 用一个字符串表示。n 中每一位数字和数字 x 都处于闭区间 [1, 9] 中，且 n 可能表示一个 负数 。 你打算通过在 n 的十进制表示的任意位置插入 x 来 最大化 n 的 数值 ​​​​​​。但 不能 在负号的左边插入 x 。 例如，如果 n = 73 且 x = 6 ，那么最佳方案是将 6 插入 7 和 3 之间，使 n = 763 。 如果 n = -55 且 x = 2 ，那么最佳方案是将 2 插在第一个 5 之前，使 n = -255 。 返回插入操作后，用字符串表示的 n 的最大值。 示例：示例 1： 输入：n = &quot;99&quot;, x = 9 输出：&quot;999&quot; 解释：不管在哪里插入 9 ，结果都是相同的。 示例 2： 输入：n = &quot;-13&quot;, x = 2 输出：&quot;-123&quot; 解释：向 n 中插入 x 可以得到 -213、-123 或者 -132 ，三者中最大的是 -123 。 提示： 1 &lt;= n.length &lt;= 10^5 1 &lt;= x &lt;= 9 n​​​ 中每一位的数字都在闭区间 [1, 9] 中。 n 代表一个有效的整数。 当 n 表示负数时，将会以字符 ‘-‘ 开始。 分析：考虑负数和正数两种情况： 负数，遇到第一个大于x的数字就插入 正数，遇到第一个小于x的数字就插入 代码：class Solution { public: string maxValue(string n, int x) { string ret = &quot;&quot;; if(n[0] != &apos;-&apos;){ for(int i = 0; i &lt; n.size(); i++){ if(n[i]-&apos;0&apos; &lt; x){ ret += &apos;0&apos; + x; while(i &lt; n.size()){ ret += n[i]; i++; } return ret; } ret += n[i]; } } else{ ret += n[0]; for(int i = 1; i &lt; n.size(); i++){ if(n[i]-&apos;0&apos; &gt; x){ ret += &apos;0&apos; + x; while(i &lt; n.size()){ ret += n[i]; i++; } return ret; } ret += n[i]; } } ret += (&apos;0&apos; + x); return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-value-after-insertion/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1880. 检查某单词是否等于两单词之和]]></title>
    <url>%2F2021%2F05%2F31%2Fleetcode%201880.%20%E6%A3%80%E6%9F%A5%E6%9F%90%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E4%B8%A4%E5%8D%95%E8%AF%8D%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：字母的 字母值 取决于字母在字母表中的位置，从 0 开始 计数。即，’a’ -&gt; 0、’b’ -&gt; 1、’c’ -&gt; 2，以此类推。 对某个由小写字母组成的字符串 s 而言，其 数值 就等于将 s 中每个字母的 字母值 按顺序 连接 并 转换 成对应整数。 例如，s = “acb” ，依次连接每个字母的字母值可以得到 “021” ，转换为整数得到 21 。 给你三个字符串 firstWord、secondWord 和 targetWord ，每个字符串都由从 ‘a’ 到 ‘j’ （含 ‘a’ 和 ‘j’ ）的小写英文字母组成。 如果 firstWord 和 secondWord 的 数值之和 等于 targetWord 的数值，返回 true ；否则，返回 false 。 示例：示例 1： 输入：firstWord = &quot;acb&quot;, secondWord = &quot;cba&quot;, targetWord = &quot;cdb&quot; 输出：true 解释： firstWord 的数值为 &quot;acb&quot; -&gt; &quot;021&quot; -&gt; 21 secondWord 的数值为 &quot;cba&quot; -&gt; &quot;210&quot; -&gt; 210 targetWord 的数值为 &quot;cdb&quot; -&gt; &quot;231&quot; -&gt; 231 由于 21 + 210 == 231 ，返回 true 示例 2： 输入：firstWord = &quot;aaa&quot;, secondWord = &quot;a&quot;, targetWord = &quot;aab&quot; 输出：false 解释： firstWord 的数值为 &quot;aaa&quot; -&gt; &quot;000&quot; -&gt; 0 secondWord 的数值为 &quot;a&quot; -&gt; &quot;0&quot; -&gt; 0 targetWord 的数值为 &quot;aab&quot; -&gt; &quot;001&quot; -&gt; 1 由于 0 + 0 != 1 ，返回 false 示例 3： 输入：firstWord = &quot;aaa&quot;, secondWord = &quot;a&quot;, targetWord = &quot;aaaa&quot; 输出：true 解释： firstWord 的数值为 &quot;aaa&quot; -&gt; &quot;000&quot; -&gt; 0 secondWord 的数值为 &quot;a&quot; -&gt; &quot;0&quot; -&gt; 0 targetWord 的数值为 &quot;aaaa&quot; -&gt; &quot;0000&quot; -&gt; 0 由于 0 + 0 == 0 ，返回 true 提示： 1 &lt;= firstWord.length, secondWord.length, targetWord.length &lt;= 8 firstWord、secondWord 和 targetWord 仅由从 ‘a’ 到 ‘j’ （含 ‘a’ 和 ‘j’ ）的小写英文字母组成。 分析：将字母转换成数字计算即可 代码：class Solution { public: bool isSumEqual(string firstWord, string secondWord, string targetWord) { int a = 0; int b = 0; int c = 0; for(int i = 0; i &lt; firstWord.size(); i++){ a = a * 10 + int(firstWord[i] - &apos;a&apos;); } for(int i = 0; i &lt; secondWord.size(); i++){ b = b * 10 + int(secondWord[i] - &apos;a&apos;); } for(int i = 0; i &lt; targetWord.size(); i++){ c = c * 10 + int(targetWord[i] - &apos;a&apos;); } if(a+b == c){ return true; } return false; } }; 题目地址:https://leetcode-cn.com/problems/check-if-word-equals-summation-of-two-words/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1872. 石子游戏 VIII]]></title>
    <url>%2F2021%2F05%2F24%2Fleetcode%201872.%20%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%20VIII%2F</url>
    <content type="text"><![CDATA[题目：Alice 和 Bob 玩一个游戏，两人轮流操作， Alice 先手 。 总共有 n 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 大于 1 ，他将执行以下操作： 选择一个整数 x &gt; 1 ，并且 移除 最左边的 x 个石子。 将 移除 的石子价值之 和 累加到该玩家的分数中。 将一个 新的石子 放在最左边，且新石子的值为被移除石子值之和。 当只剩下 一个 石子时，游戏结束。 Alice 和 Bob 的 分数之差 为 (Alice 的分数 - Bob 的分数) 。 Alice 的目标是 最大化 分数差，Bob 的目标是 最小化 分数差。 给你一个长度为 n 的整数数组 stones ，其中 stones[i] 是 从左边起 第 i 个石子的价值。请你返回在双方都采用 最优 策略的情况下，Alice 和 Bob 的 分数之差 。 示例：示例 1： 输入：stones = [-1,2,-3,4,-5] 输出：5 解释： - Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。 - Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。 两者分数之差为 2 - (-3) = 5 。 示例 2： 输入：stones = [7,-6,5,10,5,-2,-6] 输出：13 解释： - Alice 移除所有石子，得分增加 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 ，并且将一个价值为 13 的石子放在最左边。stones = [13] 。 两者分数之差为 13 - 0 = 13 。 示例 3： 输入：stones = [-10,-12] 输出：-22 解释： - Alice 只有一种操作，就是移除所有石子。得分增加 (-10) + (-12) = -22 ，并且将一个价值为 -22 的石子放在最左边。stones = [-22] 。 两者分数之差为 (-22) - 0 = -22 。 提示： n == stones.length 2 &lt;= n &lt;= 105 -10^4 &lt;= stones[i] &lt;= 10^4 分析：博弈问题，动态规划 因为每次拿走一堆石头还会放一块同等分值的石头回来，所以可以先预处理前缀和，得到pre数组 dp[i] 表示从第i个石子开始最佳的取石头得分差 从后往前遍历，对于每个dp[i]，都有两种可能： 选择当前石子，dp[i] = pre[i]-dp[i+1] 没选择当前石子，就需要从之后的选择中找到一个最优解，dp[i] = dp[i+1] 最后返回dp[1]即可（因为每次最少取两个石头，所以不存在dp[0]的取法） 参考：https://leetcode-cn.com/problems/stone-game-viii/solution/shi-zi-you-xi-viii-by-leetcode-solution-e8dx/ 代码：class Solution { public: int stoneGameVIII(vector&lt;int&gt;&amp; stones) { vector&lt;int&gt; pre(stones.size(), 0); vector&lt;int&gt; dp(stones.size(), 0); pre[0] = stones[0]; for(int i = 1; i &lt; stones.size(); i++){ pre[i] = pre[i-1] + stones[i]; } dp[stones.size()-1] = pre[stones.size()-1]; for(int i = stones.size()-2; i &gt; 0; i--){ dp[i] = max(dp[i+1], pre[i] - dp[i+1]); } return dp[1]; } }; 题目地址:https://leetcode-cn.com/problems/stone-game-viii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1871. 跳跃游戏 VII]]></title>
    <url>%2F2021%2F05%2F24%2Fleetcode%201871.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20VII%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的二进制字符串 s 和两个整数 minJump 和 maxJump 。一开始，你在下标 0 处，且该位置的值一定为 ‘0’ 。当同时满足如下条件时，你可以从下标 i 移动到下标 j 处： i + minJump &lt;= j &lt;= min(i + maxJump, s.length - 1) 且 s[j] == ‘0’. 如果你可以到达 s 的下标 s.length - 1 处，请你返回 true ，否则返回 false 。 示例：示例 1： 输入：s = &quot;011010&quot;, minJump = 2, maxJump = 3 输出：true 解释： 第一步，从下标 0 移动到下标 3 。 第二步，从下标 3 移动到下标 5 。 示例 2： 输入：s = &quot;01101110&quot;, minJump = 2, maxJump = 3 输出：false 提示： 2 &lt;= s.length &lt;= 10^5 s[i] 要么是 ‘0’ ，要么是 ‘1’ s[0] == ‘0’ 1 &lt;= minJump &lt;= maxJump &lt; s.length 分析：设一个数组用来记录是否可以到达 遍历数组，如果每次都将所有可以到达的数遍历一遍时间复杂度为O(n^2)，所以记录每次到达的数的最后下标，之后从此下标开始遍历，可以将复杂度降为O(n) 代码：class Solution { public: bool canReach(string s, int minJump, int maxJump) { vector&lt;int&gt; m(s.size(), 0); int r = 0; m[0] = 1; for(int i = 0; i &lt; s.size(); i++){ if(m[i] == 1){ for(int j = max(i+minJump, r); j &lt; s.size() &amp;&amp; j &lt;= i+maxJump; j++){ r = j; if(s[j] == &apos;0&apos;) m[j] = 1; } } } if(m[s.size()-1] == 1) return true; return false; } }; 题目地址:https://leetcode-cn.com/problems/jump-game-vii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1870. 准时到达的列车最小时速]]></title>
    <url>%2F2021%2F05%2F24%2Fleetcode%201870.%20%E5%87%86%E6%97%B6%E5%88%B0%E8%BE%BE%E7%9A%84%E5%88%97%E8%BD%A6%E6%9C%80%E5%B0%8F%E6%97%B6%E9%80%9F%2F</url>
    <content type="text"><![CDATA[题目：给你一个浮点数 hour ，表示你到达办公室可用的总通勤时间。要到达办公室，你必须按给定次序乘坐 n 趟列车。另给你一个长度为 n 的整数数组 dist ，其中 dist[i] 表示第 i 趟列车的行驶距离（单位是千米）。 每趟列车均只能在整点发车，所以你可能需要在两趟列车之间等待一段时间。 例如，第 1 趟列车需要 1.5 小时，那你必须再等待 0.5 小时，搭乘在第 2 小时发车的第 2 趟列车。 返回能满足你准时到达办公室所要求全部列车的 最小正整数 时速（单位：千米每小时），如果无法准时到达，则返回 -1 。 生成的测试用例保证答案不超过 107 ，且 hour 的 小数点后最多存在两位数字 。 示例：示例 1： 输入：dist = [1,3,2], hour = 6 输出：1 解释：速度为 1 时： - 第 1 趟列车运行需要 1/1 = 1 小时。 - 由于是在整数时间到达，可以立即换乘在第 1 小时发车的列车。第 2 趟列车运行需要 3/1 = 3 小时。 - 由于是在整数时间到达，可以立即换乘在第 4 小时发车的列车。第 3 趟列车运行需要 2/1 = 2 小时。 - 你将会恰好在第 6 小时到达。 示例 2： 输入：dist = [1,3,2], hour = 2.7 输出：3 解释：速度为 3 时： - 第 1 趟列车运行需要 1/3 = 0.33333 小时。 - 由于不是在整数时间到达，故需要等待至第 1 小时才能搭乘列车。第 2 趟列车运行需要 3/3 = 1 小时。 - 由于是在整数时间到达，可以立即换乘在第 2 小时发车的列车。第 3 趟列车运行需要 2/3 = 0.66667 小时。 - 你将会在第 2.66667 小时到达。 示例 3： 输入：dist = [1,3,2], hour = 1.9 输出：-1 解释：不可能准时到达，因为第 3 趟列车最早是在第 2 小时发车。 提示： n == dist.length 1 &lt;= n &lt;= 10^5 1 &lt;= dist[i] &lt;= 10^5 1 &lt;= hour &lt;= 10^9 hours 中，小数点后最多存在两位数字 分析：使用二分找出最小正整时速 计算每一段路程需要时间时得向上取整 向上取整方法：https://zhuanlan.zhihu.com/p/61423849 代码：class Solution { public: int minSpeedOnTime(vector&lt;int&gt;&amp; dist, double hour) { int l = 1; int r = 10000000; if(dist.size()-1 &gt; hour) return -1; while(l &lt; r){ int m = (l+r)/2; double t = 0; for(int i = 0; i &lt; dist.size()-1; i++){ t += (dist[i]-1)/m+1; } t += (double)dist[dist.size()-1] / m; if(t &lt;= hour) r = m; else{ l = m+1; } } return l; } }; 题目地址:https://leetcode-cn.com/problems/minimum-speed-to-arrive-on-time/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1869. 哪种连续子字符串更长]]></title>
    <url>%2F2021%2F05%2F24%2Fleetcode%201869.%20%E5%93%AA%E7%A7%8D%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%B4%E9%95%BF%2F</url>
    <content type="text"><![CDATA[题目：给你一个二进制字符串 s 。如果字符串中由 1 组成的 最长 连续子字符串 严格长于 由 0 组成的 最长 连续子字符串，返回 true ；否则，返回 false 。 例如，s = “110100010” 中，由 1 组成的最长连续子字符串的长度是 2 ，由 0 组成的最长连续子字符串的长度是 3 。 注意，如果字符串中不存在 0 ，此时认为由 0 组成的最长连续子字符串的长度是 0 。字符串中不存在 1 的情况也适用此规则。 示例：示例 1： 输入：s = &quot;1101&quot; 输出：true 解释： 由 1 组成的最长连续子字符串的长度是 2：&quot;1101&quot; 由 0 组成的最长连续子字符串的长度是 1：&quot;1101&quot; 由 1 组成的子字符串更长，故返回 true 。 示例 2： 输入：s = &quot;111000&quot; 输出：false 解释： 由 1 组成的最长连续子字符串的长度是 3：&quot;111000&quot; 由 0 组成的最长连续子字符串的长度是 3：&quot;111000&quot; 由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。 示例 3： 输入：s = &quot;110100010&quot; 输出：false 解释： 由 1 组成的最长连续子字符串的长度是 2：&quot;110100010&quot; 由 0 组成的最长连续子字符串的长度是 3：&quot;110100010&quot; 由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。 提示： 1 &lt;= s.length &lt;= 100 s[i] 不是 ‘0’ 就是 ‘1’ 分析：遍历一遍统计各个子字符串长度即可 代码：class Solution { public: bool checkZeroOnes(string s) { int am = 0; int a = 0; int bm = 0; int b = 0; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == &apos;1&apos;){ if(i == 0 || s[i-1] == &apos;1&apos;){ a++; } else{ am = max(a, am); a = 1; } } else{ if(i == 0 || s[i-1] == &apos;0&apos;){ b++; } else{ bm = max(b, bm); b = 1; } } } am = max(am, a); bm = max(bm, b); if(am &gt; bm){ return true; } else{ return false; } } }; 题目地址:https://leetcode-cn.com/problems/longer-contiguous-segments-of-ones-than-zeros/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1866. 恰有 K 根木棍可以看到的排列数目]]></title>
    <url>%2F2021%2F05%2F17%2Fleetcode%201866.%20%E6%81%B0%E6%9C%89%20K%20%E6%A0%B9%E6%9C%A8%E6%A3%8D%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%9A%84%E6%8E%92%E5%88%97%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：有 n 根长度互不相同的木棍，长度为从 1 到 n 的整数。请你将这些木棍排成一排，并满足从左侧 可以看到 恰好 k 根木棍。从左侧 可以看到 木棍的前提是这个木棍的 左侧 不存在比它 更长的 木棍。 例如，如果木棍排列为 [1,3,2,5,4] ，那么从左侧可以看到的就是长度分别为 1、3 、5 的木棍。 给你 n 和 k ，返回符合题目要求的排列 数目 。由于答案可能很大，请返回对 109 + 7 取余 的结果。 示例：示例 1： 输入：n = 3, k = 2 输出：3 解释：[1,3,2], [2,3,1] 和 [2,1,3] 是仅有的能满足恰好 2 根木棍可以看到的排列。 可以看到的木棍已经用粗体+斜体标识。 示例 2： 输入：n = 5, k = 5 输出：1 解释：[1,2,3,4,5] 是唯一一种能满足全部 5 根木棍可以看到的排列。 可以看到的木棍已经用粗体+斜体标识。 示例 3： 输入：n = 20, k = 11 输出：647427950 解释：总共有 647427950 (mod 109 + 7) 种能满足恰好有 11 根木棍可以看到的排列。 提示： 1 &lt;= n &lt;= 1000 1 &lt;= k &lt;= n 分析：动态规划 从长到短放入棍子，每次有两种放法： 放在可以看见的地方（也就是最前面） 放在看不见的地方（可能的数量为已经放置的木棍数量） dp[i][j]， i表示放的木棍长度，j表示可以看见的木棍数量 dp[i][j] = (dp[i+1][j-1] + dp[i+1][j] * (n-i)) 当dp[i][1]时为：dp[i][1] = dp[i+1][1] * (n-i) 初始化：dp[n][1] = 1; 代码：class Solution { public: int rearrangeSticks(int n, int k) { vector&lt;vector&lt;long long&gt;&gt; dp(n+5, vector&lt;long long&gt;(n+5, 0)); dp[n][1] = 1; for(int i = n-1; i &gt;= 1; i--){ dp[i][1] = dp[i+1][1] * (n-i) % 1000000007; for(int j = 2; j &lt;= n - i + 1; j++){ dp[i][j] = (dp[i+1][j-1] + dp[i+1][j] * (n-i)) % 1000000007; } } return dp[1][k]; } }; 题目地址:https://leetcode-cn.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1865. 找出和为指定值的下标对]]></title>
    <url>%2F2021%2F05%2F17%2Fleetcode%201865.%20%E6%89%BE%E5%87%BA%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%8B%E6%A0%87%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[题目：给你两个整数数组 nums1 和 nums2 ，请你实现一个支持下述两类查询的数据结构： 累加 ，将一个正整数加到 nums2 中指定下标对应元素上。 计数 ，统计满足 nums1[i] + nums2[j] 等于指定值的下标对 (i, j) 数目（0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; nums2.length）。 实现 FindSumPairs 类： FindSumPairs(int[] nums1, int[] nums2) 使用整数数组 nums1 和 nums2 初始化 FindSumPairs 对象。 void add(int index, int val) 将 val 加到 nums2[index] 上，即，执行 nums2[index] += val 。 int count(int tot) 返回满足 nums1[i] + nums2[j] == tot 的下标对 (i, j) 数目。 示例：输入： [&quot;FindSumPairs&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;, &quot;count&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;] [[[1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]], [7], [3, 2], [8], [4], [0, 1], [1, 1], [7]] 输出： [null, 8, null, 2, 1, null, null, 11] 解释： FindSumPairs findSumPairs = new FindSumPairs([1, 1, 2, 2, 2, 3], [1, 4, 5, 2, 5, 4]); findSumPairs.count(7); // 返回 8 ; 下标对 (2,2), (3,2), (4,2), (2,4), (3,4), (4,4) 满足 2 + 5 = 7 ，下标对 (5,1), (5,5) 满足 3 + 4 = 7 findSumPairs.add(3, 2); // 此时 nums2 = [1,4,5,4,5,4] findSumPairs.count(8); // 返回 2 ；下标对 (5,2), (5,4) 满足 3 + 5 = 8 findSumPairs.count(4); // 返回 1 ；下标对 (5,0) 满足 3 + 1 = 4 findSumPairs.add(0, 1); // 此时 nums2 = [2,4,5,4,5,4] findSumPairs.add(1, 1); // 此时 nums2 = [2,5,5,4,5,4] findSumPairs.count(7); // 返回 11 ；下标对 (2,1), (2,2), (2,4), (3,1), (3,2), (3,4), (4,1), (4,2), (4,4) 满足 2 + 5 = 7 ，下标对 (5,3), (5,5) 满足 3 + 4 = 7 提示： 1 &lt;= nums1.length &lt;= 1000 1 &lt;= nums2.length &lt;= 10^5 1 &lt;= nums1[i] &lt;= 10^9 1 &lt;= nums2[i] &lt;= 10^5 0 &lt;= index &lt; nums2.length 1 &lt;= val &lt;= 10^5 1 &lt;= tot &lt;= 10^9 最多调用 add 和 count 函数各 1000 次 分析：看一眼数据规模，直接硬算肯定是不行的 将nums2转换成map形式存储，每次查询时遍历nums1，寻找与之相符的nums2的数量 代码：class FindSumPairs { unordered_map&lt;int, int&gt; m; vector&lt;int&gt; n1; vector&lt;int&gt; n2; public: FindSumPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { for(int i = 0; i &lt; nums2.size(); i++){ m[nums2[i]]++; } n1 = nums1; n2 = nums2; } void add(int index, int val) { m[n2[index]]--; n2[index] += val; m[n2[index]]++; } int count(int tot) { int ret = 0; for(int i = 0; i &lt; n1.size(); i++){ if(m.count(tot - n1[i])){ ret += m[tot - n1[i]]; } } return ret; } }; /** * Your FindSumPairs object will be instantiated and called as such: * FindSumPairs* obj = new FindSumPairs(nums1, nums2); * obj-&gt;add(index,val); * int param_2 = obj-&gt;count(tot); */ 题目地址:https://leetcode-cn.com/problems/finding-pairs-with-a-certain-sum/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1864. 构成交替字符串需要的最小交换次数]]></title>
    <url>%2F2021%2F05%2F17%2Fleetcode%201864.%20%E6%9E%84%E6%88%90%E4%BA%A4%E6%9B%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个二进制字符串 s ，现需要将其转化为一个 交替字符串 。请你计算并返回转化所需的 最小 字符交换次数，如果无法完成转化，返回 -1 。 交替字符串 是指：相邻字符之间不存在相等情况的字符串。例如，字符串 “010” 和 “1010” 属于交替字符串，但 “0100” 不是。 任意两个字符都可以进行交换，不必相邻 。 示例：示例 1： 输入：s = &quot;111000&quot; 输出：1 解释：交换位置 1 和 4：&quot;111000&quot; -&gt; &quot;101010&quot; ，字符串变为交替字符串。 示例 2： 输入：s = &quot;010&quot; 输出：0 解释：字符串已经是交替字符串了，不需要交换。 示例 3： 输入：s = &quot;1110&quot; 输出：-1 提示： 1 &lt;= s.length &lt;= 1000 s[i] 的值为 ‘0’ 或 ‘1’ 分析：就两种可能0开头或1开头 注意点： 先判断是否可行 当0大于1时，0开头 当1大于0时，1开头 相等时各计算一次，比较 代码：class Solution { public: int minSwaps(string s) { int s1 = 0; int s0 = 0; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == &apos;0&apos;) s0++; if(s[i] == &apos;1&apos;) s1++; } if(s0 - s1 &gt; 1 || s1 - s0 &gt; 1) return -1; int z1 = 0; bool flg = true; if(s0 &gt;= s1){ for(int i = 0; i &lt; s.size(); i++){ if(flg){ if(s[i] == &apos;1&apos;){ z1++; } flg = false; } else{ if(s[i] == &apos;0&apos;){ z1++; } flg = true; } } } else{ z1 = INT_MAX; } int z2 = 0; if(s1 &gt;= s0){ flg = false; for(int i = 0; i &lt; s.size(); i++){ if(flg){ if(s[i] == &apos;1&apos;){ z2++; } flg = false; } else{ if(s[i] == &apos;0&apos;){ z2++; } flg = true; } } } else{ z2 = INT_MAX; } return min(z1, z2) / 2; } }; 题目地址:https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1863. 找出所有子集的异或总和再求和]]></title>
    <url>%2F2021%2F05%2F17%2Fleetcode%201863.%20%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86%E7%9A%84%E5%BC%82%E6%88%96%E6%80%BB%E5%92%8C%E5%86%8D%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：一个数组的 异或总和 定义为数组中所有元素按位 XOR 的结果；如果数组为 空 ，则异或总和为 0 。 例如，数组 [2,5,6] 的 异或总和 为 2 XOR 5 XOR 6 = 1 。 给你一个数组 nums ，请你求出 nums 中每个 子集 的 异或总和 ，计算并返回这些值相加之 和 。 注意：在本题中，元素 相同 的不同子集应 多次 计数。 数组 a 是数组 b 的一个 子集 的前提条件是：从 b 删除几个（也可能不删除）元素能够得到 a 。 示例：示例 1： 输入：nums = [1,3] 输出：6 解释：[1,3] 共有 4 个子集： - 空子集的异或总和是 0 。 - [1] 的异或总和为 1 。 - [3] 的异或总和为 3 。 - [1,3] 的异或总和为 1 XOR 3 = 2 。 0 + 1 + 3 + 2 = 6 示例 2： 输入：nums = [5,1,6] 输出：28 解释：[5,1,6] 共有 8 个子集： - 空子集的异或总和是 0 。 - [5] 的异或总和为 5 。 - [1] 的异或总和为 1 。 - [6] 的异或总和为 6 。 - [5,1] 的异或总和为 5 XOR 1 = 4 。 - [5,6] 的异或总和为 5 XOR 6 = 3 。 - [1,6] 的异或总和为 1 XOR 6 = 7 。 - [5,1,6] 的异或总和为 5 XOR 1 XOR 6 = 2 。 0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28 示例 3： 输入：nums = [3,4,5,6,7,8] 输出：480 解释：每个子集的全部异或总和值之和为 480 。 提示： 1 &lt;= nums.length &lt;= 12 1 &lt;= nums[i] &lt;= 20 分析：dfs把所有可能过一遍 代码：class Solution { int ret; public: void dfs(vector&lt;int&gt;&amp; nums, int i, int z){ if(i == nums.size()){ ret += z; return; } dfs(nums, i+1, z ^ nums[i]); dfs(nums, i+1, z); } int subsetXORSum(vector&lt;int&gt;&amp; nums) { ret = 0; dfs(nums, 0, 0); return ret; } }; 题目地址:https://leetcode-cn.com/problems/sum-of-all-subset-xor-totals/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1857. 有向图中最大颜色值]]></title>
    <url>%2F2021%2F05%2F10%2Fleetcode%201857.%20%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E9%A2%9C%E8%89%B2%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个 有向图 ，它含有 n 个节点和 m 条边。节点编号从 0 到 n - 1 。 给你一个字符串 colors ，其中 colors[i] 是小写英文字母，表示图中第 i 个节点的 颜色 （下标从 0 开始）。同时给你一个二维数组 edges ，其中 edges[j] = [aj, bj] 表示从节点 aj 到节点 bj 有一条 有向边 。 图中一条有效 路径 是一个点序列 x1 -&gt; x2 -&gt; x3 -&gt; … -&gt; xk ，对于所有 1 &lt;= i &lt; k ，从 xi 到 xi+1 在图中有一条有向边。路径的 颜色值 是路径中 出现次数最多 颜色的节点数目。 请你返回给定图中有效路径里面的 最大颜色值 。如果图中含有环，请返回 -1 。 示例：示例 1： 输入：colors = &quot;abaca&quot;, edges = [[0,1],[0,2],[2,3],[3,4]] 输出：3 解释：路径 0 -&gt; 2 -&gt; 3 -&gt; 4 含有 3 个颜色为 &quot;a&quot; 的节点（上图中的红色节点）。 示例 2： 输入：colors = &quot;a&quot;, edges = [[0,0]] 输出：-1 解释：从 0 到 0 有一个环。 提示： n == colors.length m == edges.length 1 &lt;= n &lt;= 10^5 0 &lt;= m &lt;= 10^5 colors 只含有小写英文字母。 0 &lt;= aj, bj &lt; n 分析：使用拓扑排序可以保证无环 在拓扑排序的同时使用dp记录到当前节点为止所有颜色的最大数量 dp[i][j] i表示为哪个节点，j表示为哪种颜色 代码：class Solution { public: int largestPathValue(string colors, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { int ret = 1; vector&lt;int&gt; v(colors.size(), 0); vector&lt;vector&lt;int&gt;&gt; dp(colors.size(), vector&lt;int&gt;(26, 0)); unordered_map&lt;int, vector&lt;int&gt;&gt; m; for(int i = 0; i &lt; edges.size(); i++){ m[edges[i][0]].push_back(edges[i][1]); } for(int i = 0; i &lt; edges.size(); i++){ v[edges[i][1]]++; } queue&lt;int&gt; q; for(int i = 0; i &lt; v.size(); i++){ if(v[i] == 0){ q.push(i); dp[i][colors[i]-&apos;a&apos;]++; } } while(q.size()){ int f = q.front(); q.pop(); for(int i = 0; i &lt; m[f].size(); i++){ v[m[f][i]]--; if(v[m[f][i]] == 0){ q.push(m[f][i]); } for(int j = 0; j &lt; 26; j++){ if(j == colors[m[f][i]]-&apos;a&apos;) dp[m[f][i]][j] = max(dp[m[f][i]][j], dp[f][j]+1); else dp[m[f][i]][j] = max(dp[m[f][i]][j], dp[f][j]); ret = max(ret, dp[m[f][i]][j]); } } } for(int i = 0; i &lt; v.size(); i++){ if(v[i] &gt; 0) return -1; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/largest-color-value-in-a-directed-graph/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5752. 子数组最小乘积的最大值]]></title>
    <url>%2F2021%2F05%2F10%2Fleetcode%205752.%20%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%8F%E4%B9%98%E7%A7%AF%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：一个数组的 最小乘积 定义为这个数组中 最小值 乘以 数组的 和 。 比方说，数组 [3,2,5] （最小值是 2）的最小乘积为 2 (3+2+5) = 2 10 = 20 。 给你一个正整数数组 nums ，请你返回 nums 任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对 109 + 7 取余 的结果。 请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 64 位有符号整数 保存。 子数组 定义为一个数组的 连续 部分。 示例：示例 1： 输入：nums = [1,2,3,2] 输出：14 解释：最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。 2 * (2+3+2) = 2 * 7 = 14 。 示例 2： 输入：nums = [2,3,3,1,2] 输出：18 解释：最小乘积的最大值由子数组 [3,3] （最小值是 3）得到。 3 * (3+3) = 3 * 6 = 18 。 示例 3： 输入：nums = [3,1,5,6,4,2] 输出：60 解释：最小乘积的最大值由子数组 [5,6,4] （最小值是 4）得到。 4 * (5+6+4) = 4 * 15 = 60 。 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^7 分析：目标，寻找以nums[i]为最小值的子数组，可以拆成两部分，在nums[i]之前并且大于nums[i]的元素和在nums[i]之后并且大于nums[i]的元素（可以使用之后代码中的方法或单调栈） 之后对每个nums[i]进行计算，比较即可（可以使用前缀和的方式方便计算子数组大小） 代码：class Solution { public: int maxSumMinProduct(vector&lt;int&gt;&amp; nums) { vector&lt;long long&gt; l(nums.size(), 1); vector&lt;long long&gt; r(nums.size(), 1); long long ret = 0; for(int i = 1; i &lt; nums.size(); i++){ // 如果左侧的数大于等于当前数，那么以左侧数为最小值的子数组也是以当前数为最小数的子数组，依次找下去，直到左侧数小于当前数或越界为止 for(int j = i-1; j &gt;= 0 &amp;&amp; nums[j] &gt;= nums[i]; j -= l[j]){ l[i] += l[j]; } } for(int i = nums.size()-2; i &gt;= 0; i--){ for(int j = i+1; j &lt; nums.size() &amp;&amp; nums[j] &gt;= nums[i]; j += r[j]){ r[i] += r[j]; } } vector&lt;long long&gt; he(nums.size(), 0); he[0] = nums[0]; he[nums.size()-1] = nums[nums.size()-1]; for(int i = 1; i &lt; nums.size(); i++){ he[i] = he[i-1] + nums[i]; } for(int i = 0; i &lt; nums.size(); i++){ if(i-l[i] &lt; 0){ ret = max(he[r[i]+i-1] * (long long)nums[i], ret); } else{ ret = max((he[r[i]+i-1] - he[i-l[i]]) * (long long)nums[i], ret); } } return ret % 1000000007; } }; 题目地址:https://leetcode-cn.com/problems/maximum-subarray-min-product/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5751. 下标对中的最大距离]]></title>
    <url>%2F2021%2F05%2F10%2Fleetcode%205751.%20%E4%B8%8B%E6%A0%87%E5%AF%B9%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题目：给你两个 非递增 的整数数组 nums1​​​​​​ 和 nums2​​​​​​ ，数组下标均 从 0 开始 计数。 下标对 (i, j) 中 0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; nums2.length 。如果该下标对同时满足 i &lt;= j 且 nums1[i] &lt;= nums2[j] ，则称之为 有效 下标对，该下标对的 距离 为 j - i​​ 。​​ 返回所有 有效 下标对 (i, j) 中的 最大距离 。如果不存在有效下标对，返回 0 。 一个数组 arr ，如果每个 1 &lt;= i &lt; arr.length 均有 arr[i-1] &gt;= arr[i] 成立，那么该数组是一个 非递增 数组。 示例：示例 1： 输入：nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5] 输出：2 解释：有效下标对是 (0,0), (2,2), (2,3), (2,4), (3,3), (3,4) 和 (4,4) 。 最大距离是 2 ，对应下标对 (2,4) 。 示例 2： 输入：nums1 = [2,2,2], nums2 = [10,10,1] 输出：1 解释：有效下标对是 (0,0), (0,1) 和 (1,1) 。 最大距离是 1 ，对应下标对 (0,1) 。 示例 3： 输入：nums1 = [30,29,19,5], nums2 = [25,25,25,25,25] 输出：2 解释：有效下标对是 (2,2), (2,3), (2,4), (3,3) 和 (3,4) 。 最大距离是 2 ，对应下标对 (2,4) 。 示例 4： 输入：nums1 = [5,4], nums2 = [3,2] 输出：0 解释：不存在有效下标对，所以返回 0 。 提示： 1 &lt;= nums1.length &lt;= 10^5 1 &lt;= nums2.length &lt;= 10^5 1 &lt;= nums1[i], nums2[j] &lt;= 10^5 nums1 和 nums2 都是 非递增 数组 分析：双指针，i1从nums1的下标0开始，i2从nums2的下标0开始，两种情况： nums1[i1] &lt;= nums2[i2]，i2++ nums1[i1] &gt; nums2[i2], i1++(需要注意i1不能大于i2) 代码：class Solution { public: int maxDistance(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { int i1 = 0; int i2 = 0; int ret = 0; while(i2 &lt; nums2.size() &amp;&amp; i1 &lt; nums1.size()){ if(nums1[i1] &lt;= nums2[i2]){ ret = max(i2 - i1, ret); i2++; } else{ i1++; if(i2 &lt; i1) i2 = i1; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-distance-between-a-pair-of-values/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5750. 人口最多的年份]]></title>
    <url>%2F2021%2F05%2F10%2Fleetcode%205750.%20%E4%BA%BA%E5%8F%A3%E6%9C%80%E5%A4%9A%E7%9A%84%E5%B9%B4%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[题目：给你一个二维整数数组 logs ，其中每个 logs[i] = [birthi, deathi] 表示第 i 个人的出生和死亡年份。 年份 x 的 人口 定义为这一年期间活着的人的数目。第 i 个人被计入年份 x 的人口需要满足：x 在闭区间 [birthi, deathi - 1] 内。注意，人不应当计入他们死亡当年的人口中。 返回 人口最多 且 最早 的年份。 示例：示例 1： 输入：logs = [[1993,1999],[2000,2010]] 输出：1993 解释：人口最多为 1 ，而 1993 是人口为 1 的最早年份。 示例 2： 输入：logs = [[1950,1961],[1960,1971],[1970,1981]] 输出：1960 解释： 人口最多为 2 ，分别出现在 1960 和 1970 。 其中最早年份是 1960 。 提示： 1 &lt;= logs.length &lt;= 100 1950 &lt;= birthi &lt; deathi &lt;= 2050 分析：将每个年份的人数进行记录，再从前往后遍历一遍即可。 代码：class Solution { public: int maximumPopulation(vector&lt;vector&lt;int&gt;&gt;&amp; logs) { vector&lt;int&gt; v(3000, 0); int ret = 0; int m = 0; for(int i = 0; i &lt; logs.size(); i++){ for(int j = logs[i][0]; j &lt; logs[i][1]; j++){ v[j]++; } } for(int i = 1950; i &lt; 2051; i++){ if(m &lt; v[i]){ m = v[i]; ret = i; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-population-year/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1851. 包含每个查询的最小区间]]></title>
    <url>%2F2021%2F05%2F06%2Fleetcode%201851.%20%E5%8C%85%E5%90%AB%E6%AF%8F%E4%B8%AA%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。 再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti &lt;= queries[j] &lt;= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。 以数组形式返回对应查询的所有答案。 示例：示例 1： 输入：intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] 输出：[3,3,1,4] 解释：查询处理如下： - Query = 2 ：区间 [2,4] 是包含 2 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 3 ：区间 [2,4] 是包含 3 的最小区间，答案为 4 - 2 + 1 = 3 。 - Query = 4 ：区间 [4,4] 是包含 4 的最小区间，答案为 4 - 4 + 1 = 1 。 - Query = 5 ：区间 [3,6] 是包含 5 的最小区间，答案为 6 - 3 + 1 = 4 。 示例 2： 输入：intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22] 输出：[2,-1,4,6] 解释：查询处理如下： - Query = 2 ：区间 [2,3] 是包含 2 的最小区间，答案为 3 - 2 + 1 = 2 。 - Query = 19：不存在包含 19 的区间，答案为 -1 。 - Query = 5 ：区间 [2,5] 是包含 5 的最小区间，答案为 5 - 2 + 1 = 4 。 - Query = 22：区间 [20,25] 是包含 22 的最小区间，答案为 25 - 20 + 1 = 6 。 提示： 1 &lt;= intervals.length &lt;= 10^5 1 &lt;= queries.length &lt;= 10^5 queries[i].length == 2 1 &lt;= lefti &lt;= righti &lt;= 10^7 1 &lt;= queries[j] &lt;= 10^7 分析：将intervals按照区间大小排序，将queries使用multimap&lt;int, int&gt;的方式存放（理由：映射；排序；方便的删除） 遍历intervals，使用multimap中的lower_bound函数可以找到比intervals[i][0] 大或相等的数，将intervals[i]区间内的数记录对应的区间大小并删除 代码：class Solution { public: vector&lt;int&gt; minInterval(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; queries) { multimap&lt;int, int&gt; m; vector&lt;int&gt; ret(queries.size(), -1); for(int i = 0; i &lt; queries.size(); i++){ m.insert({queries[i], i}); } sort(intervals.begin(), intervals.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ return a[1]-a[0] &lt; b[1]-b[0]; }); for(int i = 0; i &lt; intervals.size(); i++){ int l = intervals[i][0]; int r = intervals[i][1]; for(auto a = m.lower_bound(l); a != m.end() &amp;&amp; a-&gt;first &lt;= r; a = m.erase(a)){ ret[a-&gt;second] = r-l+1; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-interval-to-include-each-query/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1850. 邻位交换的最小次数]]></title>
    <url>%2F2021%2F05%2F06%2Fleetcode%201850.%20%E9%82%BB%E4%BD%8D%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个表示大整数的字符串 num ，和一个整数 k 。 如果某个整数是 num 中各位数字的一个 排列 且它的 值大于 num ，则称这个整数为 妙数 。可能存在很多妙数，但是只需要关注 值最小 的那些。 例如，num = “5489355142” ： 第 1 个最小妙数是 “5489355214” 第 2 个最小妙数是 “5489355241” 第 3 个最小妙数是 “5489355412” 第 4 个最小妙数是 “5489355421” 返回要得到第 k 个 最小妙数 需要对 num 执行的 相邻位数字交换的最小次数 。 测试用例是按存在第 k 个最小妙数而生成的。 示例：示例 1： 输入：num = &quot;5489355142&quot;, k = 4 输出：2 解释：第 4 个最小妙数是 &quot;5489355421&quot; ，要想得到这个数字： - 交换下标 7 和下标 8 对应的位：&quot;5489355142&quot; -&gt; &quot;5489355412&quot; - 交换下标 8 和下标 9 对应的位：&quot;5489355412&quot; -&gt; &quot;5489355421&quot; 示例 2： 输入：num = &quot;11112&quot;, k = 4 输出：4 解释：第 4 个最小妙数是 &quot;21111&quot; ，要想得到这个数字： - 交换下标 3 和下标 4 对应的位：&quot;11112&quot; -&gt; &quot;11121&quot; - 交换下标 2 和下标 3 对应的位：&quot;11121&quot; -&gt; &quot;11211&quot; - 交换下标 1 和下标 2 对应的位：&quot;11211&quot; -&gt; &quot;12111&quot; - 交换下标 0 和下标 1 对应的位：&quot;12111&quot; -&gt; &quot;21111&quot; 示例 3： 输入：num = &quot;00123&quot;, k = 1 输出：1 解释：第 1 个最小妙数是 &quot;00132&quot; ，要想得到这个数字： - 交换下标 3 和下标 4 对应的位：&quot;00123&quot; -&gt; &quot;00132&quot; 提示： 2 &lt;= num.length &lt;= 1000 1 &lt;= k &lt;= 1000 num 仅由数字组成 分析：由两步组成，第一步参照 31. 下一个排列 求出比num大的第k个排列n 第二步，将num每个字符通过交换和n对应，交换方式类似于冒泡排序 num[i] != n[i]时，找到最近的和n[i]相同的num[j]，利用冒泡排序的方式交换过来即可 代码：class Solution { public: void next_permutation(string&amp; num){ for(int i = num.size()-2; i &gt;= 0; i--){ if(num[i] &lt; num[i+1]){ if(i+1 == num.size()-1){ int z = num[i]; num[i] = num[i+1]; num[i+1] = z; return; } for(int j = i+1; j &lt; num.size(); j++){ if(num[i] &gt;= num[j]){ int z = num[i]; num[i] = num[j-1]; num[j-1] = z; break; } if(j == num.size()-1){ int z = num[i]; num[i] = num[j]; num[j] = z; } } for(int l = i+1, r = num.size()-1; l &lt; r; l++, r--){ int z = num[r]; num[r] = num[l]; num[l] = z; } return; } } } int getMinSwaps(string num, int k) { string n = num; for(int i = 0; i &lt; k; i++){ next_permutation(n); } int ret = 0; for(int i = 0; i &lt; num.size(); i++){ if(num[i] == n[i]) continue; for(int j = i+1; j &lt; num.size(); j++){ if(num[j] == n[i]){ int z = num[j]; for(int k = j-1; k &gt;= i; k--){ ret++; num[k+1] = num[k]; } num[i] = z; break; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1849. 将字符串拆分为递减的连续值]]></title>
    <url>%2F2021%2F05%2F06%2Fleetcode%201849.%20%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86%E4%B8%BA%E9%80%92%E5%87%8F%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个仅由数字组成的字符串 s 。 请你判断能否将 s 拆分成两个或者多个 非空子字符串 ，使子字符串的 数值 按 降序 排列，且每两个 相邻子字符串 的数值之 差 等于 1 。 例如，字符串 s = “0090089” 可以拆分成 [“0090”, “089”] ，数值为 [90,89] 。这些数值满足按降序排列，且相邻值相差 1 ，这种拆分方法可行。 另一个例子中，字符串 s = “001” 可以拆分成 [“0”, “01”]、[“00”, “1”] 或 [“0”, “0”, “1”] 。然而，所有这些拆分方法都不可行，因为对应数值分别是 [0,1]、[0,1] 和 [0,0,1] ，都不满足按降序排列的要求。 如果可以按要求拆分 s ，返回 true ；否则，返回 false 。 子字符串 是字符串中的一个连续字符序列。 示例：示例 1： 输入：s = &quot;1234&quot; 输出：false 解释：不存在拆分 s 的可行方法。 示例 2： 输入：s = &quot;050043&quot; 输出：true 解释：s 可以拆分为 [&quot;05&quot;, &quot;004&quot;, &quot;3&quot;] ，对应数值为 [5,4,3] 。 满足按降序排列，且相邻值相差 1 。 示例 3： 输入：s = &quot;9080701&quot; 输出：false 解释：不存在拆分 s 的可行方法。 示例 4： 输入：s = &quot;10009998&quot; 输出：true 解释：s 可以拆分为 [&quot;100&quot;, &quot;099&quot;, &quot;98&quot;] ，对应数值为 [100,99,98] 。 满足按降序排列，且相邻值相差 1 。 提示： 1 &lt;= s.length &lt;= 20 s 仅由数字组成 分析：之后每个数都比之前一个数小1，只需要确定第一个数，之后的数可以类推 第一重循环遍历尝试第一个数，若第一个数长度大于10，就直接返回false（因为，字符串最多20位，如果长度大于10，之后的数只能为9位，是不可能符合条件的） 第二重循环用来遍历之后的数 注意点： 将两个数之间和开头的0去掉 倒数第二个数为1的时候单独处理最后一个数为0的情况 使用long long 存储数据，int可能不够大 代码：class Solution { public: bool splitString(string s) { long long a = 0; int i = 0; int chang = 0; while(i &lt; s.size() &amp;&amp; s[i] == &apos;0&apos;) i++; if(s[i] == &apos;1&apos;){ int k = i+1; while(k &lt; s.size() &amp;&amp; s[k] == &apos;0&apos;) k++; if(k == s.size() &amp;&amp; k != i+1) return true; } for(; i &lt; s.size(); i++){ if(chang &gt; 10) return false; chang++; a = a*10+(s[i]-&apos;0&apos;); long long b = a; long long c = 0; int j = i+1; while(j &lt; s.size() &amp;&amp; s[j] == &apos;0&apos;) j++; for(; j &lt; s.size(); j++){ c = c*10+(s[j]-&apos;0&apos;); if(c == b-1){ b = c; c = 0; j++; if(j == s.size()) return true; if(b == 1){ while(j &lt; s.size() &amp;&amp; s[j] == &apos;0&apos;) j++; j--; if(j+1 == s.size() &amp;&amp; s[j] == &apos;0&apos;) return true; } else{ while(j &lt; s.size() &amp;&amp; s[j] == &apos;0&apos;) j++; j--; } continue; } if(c &gt;= b){ break; } } } return false; } }; 题目地址:https://leetcode-cn.com/problems/splitting-a-string-into-descending-consecutive-values/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1848. 到目标元素的最小距离]]></title>
    <url>%2F2021%2F05%2F06%2Fleetcode%201848.%20%E5%88%B0%E7%9B%AE%E6%A0%87%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums （下标 从 0 开始 计数）以及两个整数 target 和 start ，请你找出一个下标 i ，满足 nums[i] == target 且 abs(i - start) 最小化 。注意：abs(x) 表示 x 的绝对值。 返回 abs(i - start) 。 题目数据保证 target 存在于 nums 中。 示例：示例 1： 输入：nums = [1,2,3,4,5], target = 5, start = 3 输出：1 解释：nums[4] = 5 是唯一一个等于 target 的值，所以答案是 abs(4 - 3) = 1 。 示例 2： 输入：nums = [1], target = 1, start = 0 输出：0 解释：nums[0] = 1 是唯一一个等于 target 的值，所以答案是 abs(0 - 0) = 1 。 示例 3： 输入：nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0 输出：0 解释：nums 中的每个值都是 1 ，但 nums[0] 使 abs(i - start) 的结果得以最小化，所以答案是 abs(0 - 0) = 0 。 提示： 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 104 0 &lt;= start &lt; nums.length target 存在于 nums 中 分析：简单遍历一遍，按题目要求搜索即可 代码：class Solution { public: int getMinDistance(vector&lt;int&gt;&amp; nums, int target, int start) { int ret = INT_MAX; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] == target){ if(abs(start - i) &lt; ret){ ret = abs(start - i); } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1839. 所有元音按顺序排布的最长子字符串]]></title>
    <url>%2F2021%2F04%2F26%2Fleetcode%201839.%20%E6%89%80%E6%9C%89%E5%85%83%E9%9F%B3%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%B8%83%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：当一个字符串满足如下条件时，我们称它是 美丽的 ： 所有 5 个英文元音字母（’a’ ，’e’ ，’i’ ，’o’ ，’u’）都必须 至少 出现一次。 这些元音字母的顺序都必须按照 字典序 升序排布（也就是说所有的 ‘a’ 都在 ‘e’ 前面，所有的 ‘e’ 都在 ‘i’ 前面，以此类推） 比方说，字符串 “aeiou” 和 “aaaaaaeiiiioou” 都是 美丽的 ，但是 “uaeio” ，”aeoiu” 和 “aaaeeeooo” 不是美丽的 。 给你一个只包含英文元音字母的字符串 word ，请你返回 word 中 最长美丽子字符串的长度 。如果不存在这样的子字符串，请返回 0 。 子字符串 是字符串中一个连续的字符序列。 示例：示例 1： 输入：word = &quot;aeiaaioaaaaeiiiiouuuooaauuaeiu&quot; 输出：13 解释：最长子字符串是 &quot;aaaaeiiiiouuu&quot; ，长度为 13 。 示例 2： 输入：word = &quot;aeeeiiiioooauuuaeiou&quot; 输出：5 解释：最长子字符串是 &quot;aeiou&quot; ，长度为 5 。 示例 3： 输入：word = &quot;a&quot; 输出：0 解释：没有美丽子字符串，所以返回 0 。 提示： 1 &lt;= word.length &lt;= 5 * 10^5 word 只包含字符 ‘a’，’e’，’i’，’o’ 和 ‘u’ 。 分析：滑动窗口，每次尝试将右侧字符加入窗口，如果满足条件就加入，不满足，从左侧移除字符。 当满足最美字符串时将长度更新。 代码：class Solution { public: int longestBeautifulSubstring(string word) { int ret = 0; int l = 0; int r = 0; map&lt;char, char&gt; m; m[&apos;a&apos;] = &apos;e&apos;; m[&apos;e&apos;] = &apos;i&apos;; m[&apos;i&apos;] = &apos;o&apos;; m[&apos;o&apos;] = &apos;u&apos;; m[&apos;u&apos;] = &apos;u&apos;; while(r &lt; word.size()){ if(m[word[r]] == word[r+1] || word[r] == word[r+1]){ r++; } else{ if(l == r){ l++; r++; } while(word[r] != &apos;a&apos; &amp;&amp; r &lt; word.size()){ r++; } l = r; } if(word[r] == &apos;u&apos; &amp;&amp; word[l] == &apos;a&apos;) ret = max(ret, r-l+1); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/longest-substring-of-all-vowels-in-order/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5739. 最高频元素的频数]]></title>
    <url>%2F2021%2F04%2F25%2Fleetcode%205739.%20%E6%9C%80%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E7%9A%84%E9%A2%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：元素的 频数 是该元素在一个数组中出现的次数。 给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。 执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。 示例：示例 1： 输入：nums = [1,2,4], k = 5 输出：3 解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。 4 是数组中最高频元素，频数是 3 。 示例 2： 输入：nums = [1,4,8,13], k = 5 输出：2 解释：存在多种最优解决方案： - 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。 - 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。 - 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。 示例 3： 输入：nums = [3,9,6], k = 2 输出：1 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^5 1 &lt;= k &lt;= 10^5 分析：将数组从小到大排序 要让nums[i]成为最大频数的话，得让i之前一段区间中的数尽可能多的等于nums[i] 使用两个指针，一个l指向区间左侧，一个i指向区间右侧 i往右移动一位，所需要的操作次数为 区间中数的个数 * (nums[i+1] - nums[i]) 当i无法往右移动时l往右移动一位，并使可用操作次数加上nums[i] - nums[l] 要注意两个相邻的数差大于可操作次数时的处理 代码：class Solution { public: int maxFrequency(vector&lt;int&gt;&amp; nums, int k) { sort(nums.begin(), nums.end()); int l = 0, r = 0; int ret = 1; int c = 0; while(r &lt; nums.size()-1){ if(((long long)nums[r+1] - nums[r]) * (r+1-l) + c &lt;= k){ r++; c += (nums[r] - nums[r-1]) * (r-l); ret = max(ret, r-l+1); } else{ c -= nums[r] - nums[l]; l++; if(l &gt; r){ r = l; c = 0; continue; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5738. K 进制表示下的各位数字总和]]></title>
    <url>%2F2021%2F04%2F25%2Fleetcode%205738.%20K%20%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%8B%E7%9A%84%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n（10 进制）和一个基数 k ，请你将 n 从 10 进制表示转换为 k 进制表示，计算并返回转换后各位数字的 总和 。 转换后，各位数字应当视作是 10 进制数字，且它们的总和也应当按 10 进制表示返回。 示例：示例 1： 输入：n = 34, k = 6 输出：9 解释：34 (10 进制) 在 6 进制下表示为 54 。5 + 4 = 9 。 示例 2： 输入：n = 10, k = 10 输出：1 解释：n 本身就是 10 进制。 1 + 0 = 1 。 提示： 1 &lt;= n &lt;= 100 2 &lt;= k &lt;= 10 分析：使用短除法直接写 代码：class Solution { public: int sumBase(int n, int k) { int ret = 0;; while(n &gt; 0){ ret += n%k; n /= k; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/sum-of-digits-in-base-k/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1840. 最高建筑高度]]></title>
    <url>%2F2021%2F04%2F19%2Fleetcode%201840.%20%E6%9C%80%E9%AB%98%E5%BB%BA%E7%AD%91%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目：在一座城市里，你需要建 n 栋新的建筑。这些新的建筑会从 1 到 n 编号排成一列。 这座城市对这些新建筑有一些规定： 每栋建筑的高度必须是一个非负整数。 第一栋建筑的高度 必须 是 0 。 任意两栋相邻建筑的高度差 不能超过 1 。 除此以外，某些建筑还有额外的最高高度限制。这些限制会以二维整数数组 restrictions 的形式给出，其中 restrictions[i] = [idi, maxHeighti] ，表示建筑 idi 的高度 不能超过 maxHeighti 。 题目保证每栋建筑在 restrictions 中 至多出现一次 ，同时建筑 1 不会 出现在 restrictions 中。 请你返回 最高 建筑能达到的 最高高度 。 示例：示例 1： 输入：n = 5, restrictions = [[2,1],[4,1]] 输出：2 解释：上图中的绿色区域为每栋建筑被允许的最高高度。 我们可以使建筑高度分别为 [0,1,2,1,2] ，最高建筑的高度为 2 。 示例 2： 输入：n = 6, restrictions = [] 输出：5 解释：上图中的绿色区域为每栋建筑被允许的最高高度。 我们可以使建筑高度分别为 [0,1,2,3,4,5] ，最高建筑的高度为 5 。 示例 3： 输入：n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]] 输出：5 解释：上图中的绿色区域为每栋建筑被允许的最高高度。 我们可以使建筑高度分别为 [0,1,2,3,3,4,4,5,4,3] ，最高建筑的高度为 5 。 提示：2 &lt;= n &lt;= 10^90 &lt;= restrictions.length &lt;= min(n - 1, 10^5)2 &lt;= idi &lt;= nidi 是 唯一的 。0 &lt;= maxHeighti &lt;= 10^9 分析：从左到右遍历一遍，将限制从左传递到右 第i栋建筑的高度修改为：原先的高度 和 i-1栋建筑的高度+两栋建筑之间的距离 中较高的那个 从右到左遍历一遍，将限制从右传递到左 第i栋建筑的高度修改为：原先的高度 和 i+1栋建筑的高度+两栋建筑之间的距离 中较高的那个 最后遍历一遍，求出最高的建筑 i和j两个建筑之间最高的建筑为（(j-i) + i建筑高度 + j建筑高度）/ 2 代码：class Solution { public: int maxBuilding(int n, vector&lt;vector&lt;int&gt;&gt;&amp; restrictions) { restrictions.push_back(vector&lt;int&gt;{1, 0}); restrictions.push_back(vector&lt;int&gt;{n, n}); int ret = 0; sort(restrictions.begin(), restrictions.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ return a[0] &lt; b[0]; }); for(int i = 1; i &lt; restrictions.size(); i++){ restrictions[i][1] = min(restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0], restrictions[i][1]); } for(int i = restrictions.size()-2; i &gt;= 0; i--){ restrictions[i][1] = min(restrictions[i+1][1] + restrictions[i+1][0] - restrictions[i][0], restrictions[i][1]); } for(int i = 1; i &lt; restrictions.size(); i++){ ret = max(ret, (restrictions[i][0] - restrictions[i-1][0] + restrictions[i-1][1] + restrictions[i][1]) / 2); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-building-height/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1835. 所有数对按位与结果的异或和]]></title>
    <url>%2F2021%2F04%2F19%2Fleetcode%201835.%20%E6%89%80%E6%9C%89%E6%95%B0%E5%AF%B9%E6%8C%89%E4%BD%8D%E4%B8%8E%E7%BB%93%E6%9E%9C%E7%9A%84%E5%BC%82%E6%88%96%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：列表的 异或和（XOR sum）指对所有元素进行按位 XOR 运算的结果。如果列表中仅有一个元素，那么其 异或和 就等于该元素。 例如，[1,2,3,4] 的 异或和 等于 1 XOR 2 XOR 3 XOR 4 = 4 ，而 [3] 的 异或和 等于 3 。 给你两个下标 从 0 开始 计数的数组 arr1 和 arr2 ，两数组均由非负整数组成。 根据每个 (i, j) 数对，构造一个由 arr1[i] AND arr2[j]（按位 AND 运算）结果组成的列表。其中 0 &lt;= i &lt; arr1.length 且 0 &lt;= j &lt; arr2.length 。 返回上述列表的 异或和 。 示例：示例 1： 输入：arr1 = [1,2,3], arr2 = [6,5] 输出：0 解释：列表 = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1] ， 异或和 = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0 。 示例 2： 输入：arr1 = [12], arr2 = [4] 输出：4 解释：列表 = [12 AND 4] = [4] ，异或和 = 4 。 提示：1 &lt;= arr1.length, arr2.length &lt;= 10^50 &lt;= arr1[i], arr2[j] &lt;= 10^9 分析：先看arr1[i] 和 arr2[]中的元素的与 arr1[i] &amp; arr2[0] ^ arr1[i] &amp; arr2[1] ^ ... 可以简化为arr1[i] &amp; (arr2[0] ^ arr2[1] ^ ... ^ arr2[j]) 理由： (1&amp;1)^(1&amp;1) = 0 (1&amp;0)^(1&amp;0) = 0 (1&amp;1)^(1&amp;0) = 1 (0&amp;0)^(0&amp;0) = 0 (a&amp;b)^(a&amp;c) = a&amp;(b^c) 继续： arr1[i]&amp;(arr2中所有元素的异或) ^ arr[i+1]&amp;(arr2中所有元素的异或) ^ ... 可以根据上面的逻辑简化为 (arr2中所有元素的异或) &amp; (arr1[0] ^ arr1[1] ^ ... ^ arr2[i]) 也就是(arr1中所有元素的异或) &amp; (arr2中所有元素的异或) 代码：class Solution { public: int getXORSum(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) { int a1 = 0; int a2 = 0; for(int i = 0; i &lt; arr1.size(); i++){ a1 = a1 ^ arr1[i]; } for(int i = 0; i &lt; arr2.size(); i++){ a2 = a2 ^ arr2[i]; } return a1 &amp; a2; } }; 题目地址:https://leetcode-cn.com/problems/find-xor-sum-of-all-pairs-bitwise-and/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1834. 单线程 CPU]]></title>
    <url>%2F2021%2F04%2F19%2Fleetcode%201834.%20%E5%8D%95%E7%BA%BF%E7%A8%8B%20CPU%2F</url>
    <content type="text"><![CDATA[题目：给你一个二维数组 tasks ，用于表示 n​​​​​​ 项从 0 到 n - 1 编号的任务。其中 tasks[i] = [enqueueTimei, processingTimei] 意味着第 i​​​​​​​​​​ 项任务将会于 enqueueTimei 时进入任务队列，需要 processingTimei 的时长完成执行。 现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行： 如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。 如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 执行时间最短 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。 一旦某项任务开始执行，CPU 在 执行完整个任务 前都不会停止。 CPU 可以在完成一项任务后，立即开始执行一项新任务。 返回 CPU 处理任务的顺序。 示例：示例 1： 输入：tasks = [[1,2],[2,4],[3,2],[4,1]] 输出：[0,2,3,1] 解释：事件按下述流程运行： - time = 1 ，任务 0 进入任务队列，可执行任务项 = {0} - 同样在 time = 1 ，空闲状态的 CPU 开始执行任务 0 ，可执行任务项 = {} - time = 2 ，任务 1 进入任务队列，可执行任务项 = {1} - time = 3 ，任务 2 进入任务队列，可执行任务项 = {1, 2} - 同样在 time = 3 ，CPU 完成任务 0 并开始执行队列中用时最短的任务 2 ，可执行任务项 = {1} - time = 4 ，任务 3 进入任务队列，可执行任务项 = {1, 3} - time = 5 ，CPU 完成任务 2 并开始执行队列中用时最短的任务 3 ，可执行任务项 = {1} - time = 6 ，CPU 完成任务 3 并开始执行任务 1 ，可执行任务项 = {} - time = 10 ，CPU 完成任务 1 并进入空闲状态 示例 2： 输入：tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]] 输出：[4,3,2,0,1] 解释：事件按下述流程运行： - time = 7 ，所有任务同时进入任务队列，可执行任务项 = {0,1,2,3,4} - 同样在 time = 7 ，空闲状态的 CPU 开始执行任务 4 ，可执行任务项 = {0,1,2,3} - time = 9 ，CPU 完成任务 4 并开始执行任务 3 ，可执行任务项 = {0,1,2} - time = 13 ，CPU 完成任务 3 并开始执行任务 2 ，可执行任务项 = {0,1} - time = 18 ，CPU 完成任务 2 并开始执行任务 0 ，可执行任务项 = {1} - time = 28 ，CPU 完成任务 0 并开始执行任务 1 ，可执行任务项 = {} - time = 40 ，CPU 完成任务 1 并进入空闲状态 提示： tasks.length == n 1 &lt;= n &lt;= 10^5 1 &lt;= enqueueTimei, processingTimei &lt;= 10^9 分析：为每个任务添加一个系列号，按照任务开始时长先排序 将开始时间小于当前时间的任务加入优先队列，在优先队列中存储所需时长和序列号。 如果当时没有任务可以开始，将最近的下一个任务加入优先队列 代码：第一种写法： class Solution { public: vector&lt;int&gt; getOrder(vector&lt;vector&lt;int&gt;&gt;&amp; tasks) { vector&lt;int&gt; v(tasks.size()); iota(v.begin(), v.end(), 0); sort(v.begin(), v.end(), [&amp;](int i, int j) { return tasks[i][0] &lt; tasks[j][0]; }); long time = 0; vector&lt;int&gt; ret; priority_queue &lt;pair&lt;int, int&gt;,vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt; &gt; q; for(int i = 0; i &lt; v.size();){ if(q.size() == 0){ time = tasks[v[i]][0]; } for(; i &lt; v.size() &amp;&amp; tasks[v[i]][0] &lt;= time; i++){ q.push(pair&lt;int, int&gt;(tasks[v[i]][1], v[i])); } while(q.size() &gt; 0){ pair&lt;int, int&gt; t = q.top(); q.pop(); time += t.first; ret.push_back(t.second); for(; i &lt; tasks.size() &amp;&amp; tasks[v[i]][0] &lt;= time; i++){ q.push(pair&lt;int, int&gt;(tasks[v[i]][1], v[i])); } } } return ret; } }; 第二种写法： bool bj(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ if(a[0] == b[0]){ if(a[1] == b[1]) return a[2] &lt; b[2]; return a[1] &lt; b[1]; } return a[0] &lt; b[0]; } class Solution { public: vector&lt;int&gt; getOrder(vector&lt;vector&lt;int&gt;&gt;&amp; tasks) { for(int i = 0; i &lt; tasks.size(); i++){ tasks[i].push_back(i); } sort(tasks.begin(), tasks.end(), bj); long time = 0; vector&lt;int&gt; ret; ret.reserve(tasks.size()); priority_queue &lt;pair&lt;int, int&gt;,vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt; &gt; q; for(int i = 0; i &lt; tasks.size();){ if(q.size() == 0){ ret.push_back(tasks[i][2]); time = tasks[i][0] + tasks[i][1]; i++; } for(; i &lt; tasks.size() &amp;&amp; tasks[i][0] &lt;= time; i++){ q.push(pair&lt;int, int&gt;(tasks[i][1], tasks[i][2])); } while(q.size() &gt; 0){ pair&lt;int, int&gt; t = q.top(); q.pop(); time += t.first; ret.push_back(t.second); for(; i &lt; tasks.size() &amp;&amp; tasks[i][0] &lt;= time; i++){ q.push(pair&lt;int, int&gt;(tasks[i][1], tasks[i][2])); } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/single-threaded-cpu/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1833. 雪糕的最大数量]]></title>
    <url>%2F2021%2F04%2F19%2Fleetcode%201833.%20%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。 商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。 给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。 注意：Tony 可以按任意顺序购买雪糕。 示例：示例 1： 输入：costs = [1,3,2,4,1], coins = 7 输出：4 解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7 示例 2： 输入：costs = [10,6,8,7,7,8], coins = 5 输出：0 解释：Tony 没有足够的钱买任何一支雪糕。 示例 3： 输入：costs = [1,6,3,1,2,5], coins = 20 输出：6 解释：Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。 提示： costs.length == n 1 &lt;= n &lt;= 105 1 &lt;= costs[i] &lt;= 105 1 &lt;= coins &lt;= 108 分析：从小到大排序，买最便宜的冰棍，直到钱不够用 代码：class Solution { public: int maxIceCream(vector&lt;int&gt;&amp; costs, int coins) { sort(costs.begin(), costs.end()); int ret = 0; for(int i = 0; i &lt; costs.size(); i++){ if(coins &lt; costs[i]) break; ret++; coins -= costs[i]; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-ice-cream-bars/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5734. 判断句子是否为全字母句]]></title>
    <url>%2F2021%2F04%2F19%2Fleetcode%205734.%20%E5%88%A4%E6%96%AD%E5%8F%A5%E5%AD%90%E6%98%AF%E5%90%A6%E4%B8%BA%E5%85%A8%E5%AD%97%E6%AF%8D%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[题目：全字母句 指包含英语字母表中每个字母至少一次的句子。 给你一个仅由小写英文字母组成的字符串 sentence ，请你判断 sentence 是否为 全字母句 。 如果是，返回 true ；否则，返回 false 。 示例：示例 1： 输入：sentence = &quot;thequickbrownfoxjumpsoverthelazydog&quot; 输出：true 解释：sentence 包含英语字母表中每个字母至少一次。 示例 2： 输入：sentence = &quot;leetcode&quot; 输出：false 提示： 1 &lt;= sentence.length &lt;= 1000 sentence 由小写英语字母组成 分析：声明一个26位数组，遍历一遍字符串，统计是否每个字符都遍历到 代码：class Solution { public: bool checkIfPangram(string sentence) { vector&lt;int&gt; n(26, 0); for(int i = 0; i &lt; sentence.size(); i++){ n[sentence[i] - &apos;a&apos;] = 1; } for(int i = 0; i &lt; 26; i++){ if(n[i] == 0) return false; } return true; } }; 题目地址:https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1787. 使所有区间的异或结果为零]]></title>
    <url>%2F2021%2F03%2F08%2Fleetcode%201787.%20%E4%BD%BF%E6%89%80%E6%9C%89%E5%8C%BA%E9%97%B4%E7%9A%84%E5%BC%82%E6%88%96%E7%BB%93%E6%9E%9C%E4%B8%BA%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums​​​ 和一个整数 k​​​​​ 。区间 [left, right]（left &lt;= right）的 异或结果 是对下标位于 left 和 right（包括 left 和 right ）之间所有元素进行 XOR 运算的结果：nums[left] XOR nums[left+1] XOR … XOR nums[right] 。 返回数组中 要更改的最小元素数 ，以使所有长度为 k 的区间异或结果等于零。 示例：示例 1： 输入：nums = [1,2,0,3,0], k = 1 输出：3 解释：将数组 [1,2,0,3,0] 修改为 [0,0,0,0,0] 示例 2： 输入：nums = [3,4,5,2,1,7,3,4,7], k = 3 输出：3 解释：将数组 [3,4,5,2,1,7,3,4,7] 修改为 [3,4,7,3,4,7,3,4,7] 示例 3： 输入：nums = [1,2,4,1,2,5,1,2,6], k = 3 输出：3 解释：将数组[1,2,4,1,2,5,1,2,6] 修改为 [1,2,3,1,2,3,1,2,3] 提示： 1 &lt;= k &lt;= nums.length &lt;= 2000​​​​​​* 0 &lt;= nums[i] &lt; 2^10 分析：nums[i] ^ nums[i+1] ^ … ^ nums[k]nums[i+1] ^ nums[i+2] ^ … ^ nums[k+1]… 将两者异或可以得出 nums[i] == nums[k+1]，所以nums就是多个长度等于k的相同数组 将nums拆成多个长度为k的数组，摆成矩阵，纵的一列就是需要相等的数 计算出每一列各个数的数量groups和每列数的个数size 动态规划 dp[i][j]，表示修改第i列使异或为j的最少修改次数 状态转移 dp[i][j^v] = dp[i-1][j] + size[i-1] - c， v为groups中各个出现过的数，size[i-1]为第i列数的数量，c为v在这一列中出现过的次数 代码：class Solution { public: int minChanges(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; size(k+5, 0); // 每列数的个数 vector&lt;unordered_map&lt;int, int&gt;&gt; groups(k+5); // 每列各个数的数量 for(int i = 0; i &lt; nums.size(); i++){ size[i%k]++; groups[i%k][nums[i]]++; } vector&lt;vector&lt;int&gt;&gt; dp(k+5, vector&lt;int&gt;(1024, -1)); dp[0][0] = 0; for(int i = 1; i &lt;= k; i++){ int mi = -1; // 假设没有这个预先处理，最大复杂度为O(2000*1024*1024)，处理过后最大复杂度为O(2000*1024) // 优先计算将当前列的数修改为没有出现过的数需要修改的元素数 for(int j = 0; j &lt; 1024; j++){ if(dp[i-1][j] == -1) continue; if(mi == -1 || mi &gt; dp[i-1][j]) mi = dp[i-1][j]; } mi += size[i-1]; // 计算将当前列的数修改为出现过的数需要修改的元素数 for(int j = 0; j &lt; 1024; j++){ if(dp[i][j] == -1 || dp[i][j] &gt; mi) dp[i][j] = mi; if(dp[i-1][j] == -1) continue; for(auto a = groups[i-1].begin(); a != groups[i-1].end(); a++){ int v = a-&gt;first, c = a-&gt;second; int cost = dp[i-1][j] + size[i-1] - c; if(dp[i][j^v] == -1 || dp[i][j^v] &gt; cost) dp[i][j^v] = cost; } } } return dp[k][0]; } }; 题目地址:https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1786. 从第一个节点出发到最后一个节点的受限路径数]]></title>
    <url>%2F2021%2F03%2F08%2Fleetcode%201786.%20%E4%BB%8E%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E5%87%BA%E5%8F%91%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%8F%97%E9%99%90%E8%B7%AF%E5%BE%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ，其中每个 edges[i] = [ui, vi, weighti] 表示存在一条位于节点 ui 和 vi 之间的边，这条边的权重为 weighti 。 从节点 start 出发到节点 end 的路径是一个形如 [z0, z1, z2, …, zk] 的节点序列，满足 z0 = start 、zk = end 且在所有符合 0 &lt;= i &lt;= k-1 的节点 zi 和 zi+1 之间存在一条边。 路径的距离定义为这条路径上所有边的权重总和。用 distanceToLastNode(x) 表示节点 n 和 x 之间路径的最短距离。受限路径 为满足 distanceToLastNode(zi) &gt; distanceToLastNode(zi+1) 的一条路径，其中 0 &lt;= i &lt;= k-1 。 返回从节点 1 出发到节点 n 的 受限路径数 。由于数字可能很大，请返回对 109 + 7 取余 的结果。 示例：示例 1： 输入：n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]] 输出：3 解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是： 1) 1 --&gt; 2 --&gt; 5 2) 1 --&gt; 2 --&gt; 3 --&gt; 5 3) 1 --&gt; 3 --&gt; 5 示例 2： 输入：n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]] 输出：1 解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：1 --&gt; 3 --&gt; 7 。 提示： 1 &lt;= n &lt;= 2 * 10^4 n - 1 &lt;= edges.length &lt;= 4 * 10^4 edges[i].length == 3 1 &lt;= ui, vi &lt;= n ui != vi 1 &lt;= weighti &lt;= 10^5 任意两个节点之间至多存在一条边 任意两个节点之间至少存在一条路径 分析：使用Dijkstra算法计算出每个结点到结点n的最短距离 将结点按距离从小到大排序，存入数组v 动态规划 dp[i]，表示结点i到n有多少条线路 状态转移 dp[nezt] = dp[v[i]] + dp[next]，dp[v[i]]表示v[i]节点到n结点的路径数量，dp[next]表示v[i]结点连接的距离大于v[i]的结点next到结点n的线路数量。 代码：class Solution { map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; m; public: int countRestrictedPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { for(int i = 0; i &lt; edges.size(); i++){ m[edges[i][0]].push_back(pair&lt;int, int&gt; {edges[i][1], edges[i][2]}); m[edges[i][1]].push_back(pair&lt;int, int&gt; {edges[i][0], edges[i][2]}); } vector&lt;int&gt; qz(n+1, INT_MAX); priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;,greater&lt;pair&lt;int,int&gt; &gt; &gt; q; q.push(pair&lt;int, int&gt;{0, n}); while(q.size()){ pair&lt;int, int&gt; f = q.top(); q.pop(); if(f.first &lt; qz[f.second]){ // 当前节点的权值小于记录中当前节点的权值 qz[f.second] = f.first; for(int i = 0; i &lt; m[f.second].size(); i++){ pair&lt;int, int&gt; p{m[f.second][i].second+f.first, m[f.second][i].first}; q.push(p); } } } vector&lt;pair&lt;int, int&gt;&gt; v; // 最短路径，结点 for(int i = 1; i &lt; qz.size(); i++){ v.push_back(pair&lt;int, int&gt; {qz[i], i}); } sort(v.begin(), v.end()); vector&lt;int&gt; dp(n+1, 0); dp[n] = 1; for(int i = 0; i &lt; v.size(); i++){ pair&lt;int, int&gt; p = v[i]; for(int j = 0; j &lt; m[p.second].size(); j++){ int next = m[p.second][j].first; if(p.first &lt; qz[next]){ // 只考虑距离比当前结点远的结点 dp[next] += dp[p.second]; dp[next] %= 1000000007; } } } return dp[1]; } }; 题目地址:https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1785. 构成特定和需要添加的最少元素]]></title>
    <url>%2F2021%2F03%2F08%2Fleetcode%201785.%20%E6%9E%84%E6%88%90%E7%89%B9%E5%AE%9A%E5%92%8C%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%9C%80%E5%B0%91%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums ，和两个整数 limit 与 goal 。数组 nums 有一条重要属性：abs(nums[i]) &lt;= limit 。 返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) &lt;= limit 这一属性。 注意，如果 x &gt;= 0 ，那么 abs(x) 等于 x ；否则，等于 -x 。 示例：示例 1： 输入：nums = [1,-1,1], limit = 3, goal = -4输出：2解释：可以将 -2 和 -3 添加到数组中，数组的元素总和变为 1 - 1 + 1 - 2 - 3 = -4 。示例 2： 输入：nums = [1,-10,9,1], limit = 100, goal = 0输出：1 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= limit &lt;= 10^6 -limit &lt;= nums[i] &lt;= limit -10^9 &lt;= goal &lt;= 10^9 分析：将数组中的所有元素的和与goal相减，获得绝对值a。 将a除以3，如果有余数就加1，这就是需要增加的元素数量 代码：class Solution { public: int minElements(vector&lt;int&gt;&amp; nums, int limit, int goal) { long long h = 0; for(int i = 0; i &lt; nums.size(); i++){ h += nums[i]; } long long c = goal - h; if(c == 0){ return 0; } else if(c &gt; 0){ int ret = c / limit; if(c % limit &gt; 0) ret++; return ret; } else{ int ret = (c * -1) / limit; if((c * -1) % limit &gt; 0) ret++; return ret; } } }; 题目地址:https://leetcode-cn.com/problems/minimum-elements-to-add-to-form-a-given-sum/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1784. 检查二进制字符串字段]]></title>
    <url>%2F2021%2F03%2F08%2Fleetcode%201784.%20%E6%A3%80%E6%9F%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[题目：给你一个二进制字符串 s ，该字符串 不含前导零 。 如果 s 最多包含 一个由连续的 ‘1’ 组成的字段 ，返回 true​​​ 。否则，返回 false 。 示例：示例 1： 输入：s = &quot;1001&quot; 输出：false 解释：字符串中的 1 没有形成一个连续字段。 示例 2： 输入：s = &quot;110&quot; 输出：true 提示： 1 &lt;= s.length &lt;= 100 s[i]​​​​ 为 ‘0’ 或 ‘1’ s[0] 为 ‘1’ 分析：只要找到一个数字1前面是0就返回false否则返回true 代码：class Solution { public: bool checkOnesSegment(string s) { int z = 0; int n = 0; for(int i = 1; i &lt; s.size(); i++){ if(s[i] == &apos;1&apos; &amp;&amp; s[i-1] == &apos;0&apos;) return false; } return true; } }; 题目地址:https://leetcode-cn.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5692. 车队 II]]></title>
    <url>%2F2021%2F03%2F01%2Fleetcode%205692.%20%E8%BD%A6%E9%98%9F%20II%2F</url>
    <content type="text"><![CDATA[题目：在一条单车道上有 n 辆车，它们朝着同样的方向行驶。给你一个长度为 n 的数组 cars ，其中 cars[i] = [positioni, speedi] ，它表示： positioni 是第 i 辆车和道路起点之间的距离（单位：米）。题目保证 positioni &lt; positioni+1 。 speedi 是第 i 辆车的初始速度（单位：米/秒）。简单起见，所有车子可以视为在数轴上移动的点。当两辆车占据同一个位置时，我们称它们相遇了。一旦两辆车相遇，它们会合并成一个车队，这个车队里的车有着同样的位置和相同的速度，速度为这个车队里 最慢 一辆车的速度。 请你返回一个数组 answer ，其中 answer[i] 是第 i 辆车与下一辆车相遇的时间（单位：秒），如果这辆车不会与下一辆车相遇，则 answer[i] 为 -1 。答案精度误差需在 10^-5 以内。 示例：示例 1： 输入：cars = [[1,2],[2,1],[4,3],[7,2]] 输出：[1.00000,-1.00000,3.00000,-1.00000] 解释：经过恰好 1 秒以后，第一辆车会与第二辆车相遇，并形成一个 1 m/s 的车队。经过恰好 3 秒以后，第三辆车会与第四辆车相遇，并形成一个 2 m/s 的车队。 示例 2： 输入：cars = [[3,4],[5,4],[6,3],[9,1]] 输出：[2.00000,1.00000,1.50000,-1.00000] 提示： 1 &lt;= cars.length &lt;= 10^5 1 &lt;= positioni, speedi &lt;= 10^6 positioni &lt; positioni+1 分析：第一次车辆相遇一定是相邻的两辆。使用优先队列，将相邻的车辆为一组存入优先队列（格式为：l，追逐的车辆；r，被追逐的车辆；t，需要的时间） 队列头的相遇车辆是当前最先相遇的车辆。 建立一个数组prev，用来保存每一辆车的前面那辆车是什么 建立一个数组d，用来记录当前车辆是否已经录入相遇时间 当车辆相遇时，记录l车辆的相遇时间，更新数组d，此时，往队列中添加l-1辆车和r辆车的相遇时间（如有abc三辆车，当b追上c时a还没有追上b，就相当于a要追上c），更新数组prev。 代码：class Solution { private: struct Node{ int l; int r; double t; friend bool operator &lt; (Node a, Node b){ return a.t &gt; b.t; } }; public: vector&lt;double&gt; getCollisionTimes(vector&lt;vector&lt;int&gt;&gt;&amp; cars) { priority_queue&lt;Node&gt; q; vector&lt;double&gt; ret(cars.size(), -1); vector&lt;int&gt; prev(cars.size(), -1); vector&lt;bool&gt; d(cars.size(), true); for(int i = 1; i &lt; cars.size(); i++){ prev[i] = i-1; Node n; n.l = i-1; n.r = i; if(cars[i-1][1] - cars[i][1] &lt;= 0) n.t = INT_MAX; else n.t = double(cars[i][0] - cars[i-1][0]) / (cars[i-1][1] - cars[i][1]); q.push(n); } while(q.size()){ Node n = q.top(); q.pop(); // 无法追上 if(n.t == INT_MAX){ d[n.l] = false; continue; } // l和r两辆车都没有录入过 if(d[n.l] &amp;&amp; d[n.r]){ d[n.l] = false; ret[n.l] = n.t; if(prev[n.l] == -1){ continue; } Node n1; n1.l = prev[n.l]; n1.r = n.r; prev[n1.r] = prev[n.l]; if(cars[n1.l][1] - cars[n1.r][1] &lt;= 0) n1.t = INT_MAX; else n1.t = double(cars[n1.r][0] - cars[n1.l][0]) / (cars[n1.l][1] - cars[n1.r][1]); q.push(n1); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/car-fleet-ii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5690. 最接近目标价格的甜点成本]]></title>
    <url>%2F2021%2F03%2F01%2Fleetcode%205690.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E4%BB%B7%E6%A0%BC%E7%9A%84%E7%94%9C%E7%82%B9%E6%88%90%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[题目：你打算做甜点，现在需要购买配料。目前共有 n 种冰激凌基料和 m 种配料可供选购。而制作甜点需要遵循以下几条规则： 必须选择 一种 冰激凌基料。 可以添加 一种或多种 配料，也可以不添加任何配料。 每种类型的配料 最多两份 。 给你以下三个输入： baseCosts ，一个长度为 n 的整数数组，其中每个 baseCosts[i] 表示第 i 种冰激凌基料的价格。 toppingCosts，一个长度为 m 的整数数组，其中每个 toppingCosts[i] 表示 一份 第 i 种冰激凌配料的价格。 target ，一个整数，表示你制作甜点的目标价格。 你希望自己做的甜点总成本尽可能接近目标价格 target 。 返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。 示例：示例 1： 输入：baseCosts = [1,7], toppingCosts = [3,4], target = 10 输出：10 解释：考虑下面的方案组合（所有下标均从 0 开始）： - 选择 1 号基料：成本 7 - 选择 1 份 0 号配料：成本 1 x 3 = 3 - 选择 0 份 1 号配料：成本 0 x 4 = 0 总成本：7 + 3 + 0 = 10 。 示例 2： 输入：baseCosts = [2,3], toppingCosts = [4,5,100], target = 18 输出：17 解释：考虑下面的方案组合（所有下标均从 0 开始）： - 选择 1 号基料：成本 3 - 选择 1 份 0 号配料：成本 1 x 4 = 4 - 选择 2 份 1 号配料：成本 2 x 5 = 10 - 选择 0 份 2 号配料：成本 0 x 100 = 0 总成本：3 + 4 + 10 + 0 = 17 。不存在总成本为 18 的甜点制作方案。 示例 3： 输入：baseCosts = [3,10], toppingCosts = [2,5], target = 9 输出：8 解释：可以制作总成本为 8 和 10 的甜点。返回 8 ，因为这是成本更低的方案。 示例 4： 输入：baseCosts = [10], toppingCosts = [1], target = 1 输出：10 解释：注意，你可以选择不添加任何配料，但你必须选择一种基料。 提示： n == baseCosts.length m == toppingCosts.length 1 &lt;= n, m &lt;= 10 1 &lt;= baseCosts[i], toppingCosts[i] &lt;= 10^4 1 &lt;= target &lt;= 10^4 分析：dfs暴力搜索，找出所有配料的组合方式 代码：class Solution { private: vector&lt;int&gt; v; vector&lt;int&gt; t; public: void dfs(int i, int cost){ if(i == t.size()){ v.push_back(cost); return; } dfs(i+1, t[i] + cost); dfs(i+1, cost); } int closestCost(vector&lt;int&gt;&amp; baseCosts, vector&lt;int&gt;&amp; toppingCosts, int target) { for(int i = 0; i &lt; toppingCosts.size(); i++){ t.push_back(toppingCosts[i]); t.push_back(toppingCosts[i]); } dfs(0, 0); int ret = INT_MAX; for(int i = 0; i &lt; baseCosts.size(); i++){ for(int j = 0; j &lt; v.size(); j++){ if(abs(baseCosts[i] + v[j] - target) &lt; abs(target - ret)) ret = baseCosts[i] + v[j]; else if(abs(baseCosts[i] + v[j] - target) == abs(target - ret)) ret = min(baseCosts[i] + v[j], ret); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/closest-dessert-cost/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5689. 统计匹配检索规则的物品数量]]></title>
    <url>%2F2021%2F03%2F01%2Fleetcode%205689.%20%E7%BB%9F%E8%AE%A1%E5%8C%B9%E9%85%8D%E6%A3%80%E7%B4%A2%E8%A7%84%E5%88%99%E7%9A%84%E7%89%A9%E5%93%81%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 items ，其中 items[i] = [typei, colori, namei] ，描述第 i 件物品的类型、颜色以及名称。 另给你一条由两个字符串 ruleKey 和 ruleValue 表示的检索规则。 如果第 i 件物品能满足下述条件之一，则认为该物品与给定的检索规则 匹配 ： ruleKey == “type” 且 ruleValue == typei 。 ruleKey == “color” 且 ruleValue == colori 。 ruleKey == “name” 且 ruleValue == namei 。 统计并返回 匹配检索规则的物品数量 。 示例：示例 1： 输入：items = [[&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;],[&quot;computer&quot;,&quot;silver&quot;,&quot;lenovo&quot;],[&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;]], ruleKey = &quot;color&quot;, ruleValue = &quot;silver&quot; 输出：1 解释：只有一件物品匹配检索规则，这件物品是 [&quot;computer&quot;,&quot;silver&quot;,&quot;lenovo&quot;] 。 示例 2： 输入：items = [[&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;],[&quot;computer&quot;,&quot;silver&quot;,&quot;phone&quot;],[&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;]], ruleKey = &quot;type&quot;, ruleValue = &quot;phone&quot; 输出：2 解释：只有两件物品匹配检索规则，这两件物品分别是 [&quot;phone&quot;,&quot;blue&quot;,&quot;pixel&quot;] 和 [&quot;phone&quot;,&quot;gold&quot;,&quot;iphone&quot;] 。注意，[&quot;computer&quot;,&quot;silver&quot;,&quot;phone&quot;] 未匹配检索规则。 提示： 1 &lt;= items.length &lt;= 104 1 &lt;= typei.length, colori.length, namei.length, ruleValue.length &lt;= 10 ruleKey 等于 “type”、”color” 或 “name” 所有字符串仅由小写字母组成 分析：按照ruleKey的值选择对应的统计方式 代码：class Solution { public: int countMatches(vector&lt;vector&lt;string&gt;&gt;&amp; items, string ruleKey, string ruleValue) { int ret = 0; for(int i = 0; i &lt; items.size(); i++){ if(ruleKey == &quot;type&quot;){ if(items[i][0] == ruleValue) ret++; } else if(ruleKey == &quot;color&quot;){ if(items[i][1] == ruleValue) ret++; } else{ if(items[i][2] == ruleValue) ret++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-items-matching-a-rule/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5691. 通过最少操作次数使数组的和相等]]></title>
    <url>%2F2021%2F03%2F01%2Fleetcode%205691.%20%E9%80%9A%E8%BF%87%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E7%9B%B8%E7%AD%89%2F</url>
    <content type="text"><![CDATA[题目：给你两个长度可能不等的整数数组 nums1 和 nums2 。两个数组中的所有值都在 1 到 6 之间（包含 1 和 6）。 每次操作中，你可以选择 任意 数组中的任意一个整数，将它变成 1 到 6 之间 任意 的值（包含 1 和 6）。 请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。如果无法使两个数组的和相等，请返回 -1 。 示例：示例 1： 输入：nums1 = [1,2,3,4,5,6], nums2 = [1,1,2,2,2,2] 输出：3 解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 - 将 nums2[0] 变为 6 。 nums1 = [1,2,3,4,5,6], nums2 = [6,1,2,2,2,2] 。 - 将 nums1[5] 变为 1 。 nums1 = [1,2,3,4,5,1], nums2 = [6,1,2,2,2,2] 。 - 将 nums1[2] 变为 2 。 nums1 = [1,2,2,4,5,1], nums2 = [6,1,2,2,2,2] 。 示例 2： 输入：nums1 = [1,1,1,1,1,1,1], nums2 = [6] 输出：-1 解释：没有办法减少 nums1 的和或者增加 nums2 的和使二者相等。 示例 3： 输入：nums1 = [6,6], nums2 = [1] 输出：3 解释：你可以通过 3 次操作使 nums1 中所有数的和与 nums2 中所有数的和相等。以下数组下标都从 0 开始。 - 将 nums1[0] 变为 2 。 nums1 = [2,6], nums2 = [1] 。 - 将 nums1[1] 变为 2 。 nums1 = [2,2], nums2 = [1] 。 - 将 nums2[0] 变为 4 。 nums1 = [2,2], nums2 = [4] 。 提示： 1 &lt;= nums1.length, nums2.length &lt;= 105 1 &lt;= nums1[i], nums2[i] &lt;= 6 分析：设a是和比较小的数组，b是和比较大的数组。 将两个数组从小到大排序，方便之后找出最大最小数 每次修改整数两种选择： 6 - a中最小的数 &lt; b中最大的数 - 1， 将a中最小的数修改为6 6 - a中最小的数 &gt; b中最大的数 - 1， 将b中最大的数修改为1 6 - a中最小的数 == b中最大的数 - 1， 随便修改其中任意一个 代码：class Solution { public: int minOperations(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); int n1 = 0; int n2 = 0; for(int i = 0; i &lt; nums1.size(); i++) n1 += nums1[i]; for(int i = 0; i &lt; nums2.size(); i++) n2 += nums2[i]; vector&lt;int&gt; ns1; vector&lt;int&gt; ns2; if(n1 &lt; n2){ ns1 = nums1; ns2 = nums2; } else if(n2 &lt; n1){ ns1 = nums2; ns2 = nums1; int z = n1; n1 = n2; n2 = z; } else{ return 0; } int l = 0; int r = ns2.size()-1; int ret = 0; while(n1 &lt; n2){ if(l &lt; ns1.size() &amp;&amp; r &gt;= 0){ if(6 - ns1[l] &gt; ns2[r] - 1){ n1 = n1 + 6 - ns1[l]; l++; ret++; } else{ n2 = n2 - ns2[r] + 1; r--; ret++; } } else if(l &lt; ns1.size()){ n1 = n1 + 6 - ns1[l]; l++; ret++; } else if(r &gt;= 0){ n2 = n2 - ns2[r] + 1; r--; ret++; } else return -1; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/equal-sum-arrays-with-minimum-number-of-operations/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5688. 由子序列构造的最长回文串的长度]]></title>
    <url>%2F2021%2F02%2F22%2Fleetcode%205688.%20%E7%94%B1%E5%AD%90%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E7%9A%84%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目：给你两个字符串 word1 和 word2 ，请你按下述方法构造一个字符串： 从 word1 中选出某个 非空 子序列 subsequence1 。 从 word2 中选出某个 非空 子序列 subsequence2 。 连接两个子序列 subsequence1 + subsequence2 ，得到字符串。 返回可按上述方法构造的最长 回文串 的 长度 。如果无法构造回文串，返回 0 。 字符串 s 的一个 子序列 是通过从 s 中删除一些（也可能不删除）字符而不更改其余字符的顺序生成的字符串。 回文串 是正着读和反着读结果一致的字符串。 示例：示例 1： 输入：word1 = &quot;cacb&quot;, word2 = &quot;cbba&quot; 输出：5 解释：从 word1 中选出 &quot;ab&quot; ，从 word2 中选出 &quot;cba&quot; ，得到回文串 &quot;abcba&quot; 。 示例 2： 输入：word1 = &quot;ab&quot;, word2 = &quot;ab&quot; 输出：3 解释：从 word1 中选出 &quot;ab&quot; ，从 word2 中选出 &quot;a&quot; ，得到回文串 &quot;aba&quot; 。 示例 3： 输入：word1 = &quot;aa&quot;, word2 = &quot;bb&quot; 输出：0 解释：无法按题面所述方法构造回文串，所以返回 0 。 提示： 1 &lt;= word1.length, word2.length &lt;= 1000 word1 和 word2 由小写英文字母组成 分析：将两个字符串拼在一起组成str，用动态规划可以求出最长回文串，只需要注意回文串的最左边字符位于第一个字符串，最右边字符位于第二个字符串 dp[i][j] 表示第i到第j位字符可以构成的最长回文串 状态转移： str[i] == str[j]：dp[i][j] = dp[i+1][j-1] + 2 str[i] != str[j]: dp[i][j] = max(dp[i+1][j], dp[i][j-1]) 代码：class Solution { public: int longestPalindrome(string word1, string word2) { string str = word1 + word2; int ret = 0; vector&lt;vector&lt;int&gt;&gt; dp(str.size(), vector&lt;int&gt;(str.size(), 0)); for(int i = 0; i &lt; str.size(); i++){ dp[i][i] = 1; } for(int len = 2; len &lt;= str.size(); len++){ for(int i = 0; i + len - 1 &lt; str.size(); i++){ if(str[i] == str[i+len-1]){ dp[i][i+len-1] = dp[i+1][i+len-1-1] + 2; if(dp[i][i+len-1] &gt; ret &amp;&amp; i &lt; word1.size() &amp;&amp; i+len-1 &gt;= word1.size()){ ret = dp[i][i+len-1]; } } else{ dp[i][i+len-1] = max(dp[i+1][i+len-1], dp[i][i+len-1-1]); } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximize-palindrome-length-from-subsequences/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5687. 执行乘法运算的最大分数]]></title>
    <url>%2F2021%2F02%2F22%2Fleetcode%205687.%20%E6%89%A7%E8%A1%8C%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你两个长度分别 n 和 m 的整数数组 nums 和 multipliers ，其中 n &gt;= m ，数组下标 从 1 开始 计数。 初始时，你的分数为 0 。你需要执行恰好 m 步操作。在第 i 步操作（从 1 开始 计数）中，需要： 选择数组 nums 开头处或者末尾处 的整数 x 。 你获得 multipliers[i] * x 分，并累加到你的分数中。 将 x 从数组 nums 中移除。 在执行 m 步操作后，返回 最大 分数。 示例：示例 1： 输入：nums = [1,2,3], multipliers = [3,2,1] 输出：14 解释：一种最优解决方案如下： - 选择末尾处的整数 3 ，[1,2,3] ，得 3 * 3 = 9 分，累加到分数中。 - 选择末尾处的整数 2 ，[1,2] ，得 2 * 2 = 4 分，累加到分数中。 - 选择末尾处的整数 1 ，[1] ，得 1 * 1 = 1 分，累加到分数中。 总分数为 9 + 4 + 1 = 14 。 示例 2： 输入：nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6] 输出：102 解释：一种最优解决方案如下： - 选择开头处的整数 -5 ，[-5,-3,-3,-2,7,1] ，得 -5 * -10 = 50 分，累加到分数中。 - 选择开头处的整数 -3 ，[-3,-3,-2,7,1] ，得 -3 * -5 = 15 分，累加到分数中。 - 选择开头处的整数 -3 ，[-3,-2,7,1] ，得 -3 * 3 = -9 分，累加到分数中。 - 选择末尾处的整数 1 ，[-2,7,1] ，得 1 * 4 = 4 分，累加到分数中。 - 选择末尾处的整数 7 ，[-2,7] ，得 7 * 6 = 42 分，累加到分数中。 总分数为 50 + 15 - 9 + 4 + 42 = 102 。 提示： n == nums.length m == multipliers.length 1 &lt;= m &lt;= 103 m &lt;= n &lt;= 105 -1000 &lt;= nums[i], multipliers[i] &lt;= 1000 分析：动态规划 dp[i][j] 表示左边取i个数，右边取j个数时的最大得分 k表示第k次取数(从1开始) 状态转移： i == 0，取右边：dp[i][k-i] = dp[i][k-i-1] + nums[nums.size()-k+i] * multipliers[k-1] i == k，取左边：dp[i][k-i] = dp[i-1][k-i] + nums[i-1] * multipliers[k-1] 其他情况，比较取左边和取右边那个分值大：dp[i][k-i] = max(dp[i-1][k-i] + nums[i-1] multipliers[k-1], dp[i][k-i-1] + nums[nums.size()-k+i] multipliers[k-1]) 代码：class Solution { public: int maximumScore(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; multipliers) { int s = multipliers.size(); int ret = INT_MIN; vector&lt;vector&lt;int&gt;&gt; dp(s+5, vector&lt;int&gt;(s+5, 0)); for(int i = 1; i &lt;= s; i++){ for(int j = 0; j &lt;= i; j++){ if(j == 0){ dp[j][i-j] = dp[j][i-j-1] + nums[nums.size()-i+j] * multipliers[i-1]; } else if(j == i){ dp[j][i-j] = dp[j-1][i-j] + nums[j-1] * multipliers[i-1]; } else{ dp[j][i-j] = max(dp[j-1][i-j] + nums[j-1] * multipliers[i-1], dp[j][i-j-1] + nums[nums.size()-i+j] * multipliers[i-1]); } } } for(int i = 0; i &lt;= s; i++){ ret = max(ret, dp[i][s-i]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-score-from-performing-multiplication-operations/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5686. 移动所有球到每个盒子所需的最小操作数]]></title>
    <url>%2F2021%2F02%2F22%2Fleetcode%205686.%20%E7%A7%BB%E5%8A%A8%E6%89%80%E6%9C%89%E7%90%83%E5%88%B0%E6%AF%8F%E4%B8%AA%E7%9B%92%E5%AD%90%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：有 n 个盒子。给你一个长度为 n 的二进制字符串 boxes ，其中 boxes[i] 的值为 ‘0’ 表示第 i 个盒子是 空 的，而 boxes[i] 的值为 ‘1’ 表示盒子里有 一个 小球。 在一步操作中，你可以将 一个 小球从某个盒子移动到一个与之相邻的盒子中。第 i 个盒子和第 j 个盒子相邻需满足 abs(i - j) == 1 。注意，操作执行后，某些盒子中可能会存在不止一个小球。 返回一个长度为 n 的数组 answer ，其中 answer[i] 是将所有小球移动到第 i 个盒子所需的 最小 操作数。 每个 answer[i] 都需要根据盒子的 初始状态 进行计算。 示例：示例 1： 输入：boxes = &quot;110&quot; 输出：[1,1,3] 解释：每个盒子对应的最小操作数如下： 1) 第 1 个盒子：将一个小球从第 2 个盒子移动到第 1 个盒子，需要 1 步操作。 2) 第 2 个盒子：将一个小球从第 1 个盒子移动到第 2 个盒子，需要 1 步操作。 3) 第 3 个盒子：将一个小球从第 1 个盒子移动到第 3 个盒子，需要 2 步操作。将一个小球从第 2 个盒子移动到第 3 个盒子，需要 1 步操作。共计 3 步操作。 示例 2： 输入：boxes = &quot;001011&quot; 输出：[11,8,5,4,3,4] 提示： n == boxes.length 1 &lt;= n &lt;= 2000 boxes[i] 为 ‘0’ 或 ‘1’ 分析：以每个盒子为中心，找到每个1的位置与盒子之间的距离并求和 代码：class Solution { public: vector&lt;int&gt; minOperations(string boxes) { vector&lt;int&gt; ret(boxes.size(), 0); for(int i = 0; i &lt; boxes.size(); i++){ for(int l = 0; l &lt; i; l++){ ret[i] += (boxes[l] - &apos;0&apos;) * (i - l); } for(int r = i+1; r &lt; boxes.size(); r++){ ret[i] += (boxes[r] - &apos;0&apos;) * (r - i); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5685. 交替合并字符串]]></title>
    <url>%2F2021%2F02%2F22%2Fleetcode%205685.%20%E4%BA%A4%E6%9B%BF%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你两个字符串 word1 和 word2 。请你从 word1 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。 返回 合并后的字符串 。 示例：示例 1： 输入：word1 = &quot;abc&quot;, word2 = &quot;pqr&quot; 输出：&quot;apbqcr&quot; 解释：字符串合并情况如下所示： word1： a b c word2： p q r 合并后： a p b q c r 示例 2： 输入：word1 = &quot;ab&quot;, word2 = &quot;pqrs&quot; 输出：&quot;apbqrs&quot; 解释：注意，word2 比 word1 长，&quot;rs&quot; 需要追加到合并后字符串的末尾。 word1： a b word2： p q r s 合并后： a p b q r s 示例 3： 输入：word1 = &quot;abcd&quot;, word2 = &quot;pq&quot; 输出：&quot;apbqcd&quot; 解释：注意，word1 比 word2 长，&quot;cd&quot; 需要追加到合并后字符串的末尾。 word1： a b c d word2： p q 合并后： a p b q c d 提示： 1 &lt;= word1.length, word2.length &lt;= 100 word1 和 word2 由小写英文字母组成 分析：按题直接合并即可 代码：class Solution { public: string mergeAlternately(string word1, string word2) { int w1 = 0; int w2 = 0; string str = &quot;&quot;; while(w1 &lt; word1.size() || w2 &lt; word2.size()){ if(w1 &lt; word1.size()){ str += word1[w1]; } if(w2 &lt; word2.size()){ str += word2[w2]; } w1++; w2++; } return str; } }; 题目地址:https://leetcode-cn.com/problems/merge-strings-alternately/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5679. 一个图中连通三元组的最小度数]]></title>
    <url>%2F2021%2F02%2F15%2Fleetcode%205679.%20%E4%B8%80%E4%B8%AA%E5%9B%BE%E4%B8%AD%E8%BF%9E%E9%80%9A%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%BA%A6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个无向图，整数 n 表示图中节点的数目，edges 数组表示图中的边，其中 edges[i] = [ui, vi] ，表示 ui 和 vi 之间有一条无向边。 一个 连通三元组 指的是 三个 节点组成的集合且这三个点之间 两两 有边。 连通三元组的度数 是所有满足此条件的边的数目：一个顶点在三元组内，而另一个顶点不在三元组内。 请你返回所有连通三元组中度数的 最小值 ，如果图中没有连通三元组，那么返回 -1 。 示例：示例 1： 输入：n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]] 输出：3 解释：只有一个三元组 [1,2,3] 。构成度数的边在上图中已被加粗。 示例 2： 输入：n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]] 输出：0 解释：有 3 个三元组： 1) [1,4,3]，度数为 0 。 2) [2,5,6]，度数为 2 。 3) [5,6,7]，度数为 2 。 提示： 2 &lt;= n &lt;= 400 edges[i].length == 2 1 &lt;= edges.length &lt;= n * (n-1) / 2 1 &lt;= ui, vi &lt;= n ui != vi 图中没有重复的边。 分析：400个n，可以暴力解决 直接三重循环，遍历每三个点是否可以构成三元组，若可以构成，三元组的度数为三元组中每个结点的边的数量之和减6 代码：class Solution { public: int minTrioDegree(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { vector&lt;vector&lt;bool&gt;&gt; m(401, vector&lt;bool&gt;(401, false)); vector&lt;int&gt; m1(n+1, 0); int ret = INT_MAX; for(int i = 0; i &lt; edges.size(); i++){ m1[edges[i][0]]++; m1[edges[i][1]]++; m[edges[i][0]][edges[i][1]] = true; m[edges[i][1]][edges[i][0]] = true; } for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ if(m[i][j] != 1) continue; for(int k = 1; k &lt;= n; k++){ if(m[j][k] == 1 &amp;&amp; m[i][k] == 1){ int z = m1[i] + m1[j] + m1[k] - 6; ret = ret &lt; z ? ret : z; } } } } if(ret == INT_MAX) return -1; return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5677. 统计同构子字符串的数目]]></title>
    <url>%2F2021%2F02%2F15%2Fleetcode%205677.%20%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%9E%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s ，返回 s 中 同构子字符串 的数目。由于答案可能很大，只需返回对 109 + 7 取余 后的结果。 同构字符串 的定义为：如果一个字符串中的所有字符都相同，那么该字符串就是同构字符串。 子字符串 是字符串中的一个连续字符序列。 示例：示例 1： 输入：s = &quot;abbcccaa&quot; 输出：13 解释：同构子字符串如下所列： &quot;a&quot; 出现 3 次。 &quot;aa&quot; 出现 1 次。 &quot;b&quot; 出现 2 次。 &quot;bb&quot; 出现 1 次。 &quot;c&quot; 出现 3 次。 &quot;cc&quot; 出现 2 次。 &quot;ccc&quot; 出现 1 次。 3 + 1 + 2 + 1 + 3 + 2 + 1 = 13 示例 2： 输入：s = &quot;xy&quot; 输出：2 解释：同构子字符串是 &quot;x&quot; 和 &quot;y&quot; 。 示例 3： 输入：s = &quot;zzzzz&quot; 输出：15 提示： 1 &lt;= s.length &lt;= 10^5 s 由小写字符串组成 分析：将字符串分割成多个连续相同的字符串, 如： aaabbb 分割成：aaa bbb 这里面有 1（n）个aaa 2（n-1）个aa 3（n-2）个a 1（n）个bbb 2（n-1）个bb 3（n-2）个b 计算同构子字符串方式为（1+n）* n / 2 代码：class Solution { public: int countHomogenous(string s) { if(s.size() == 1) return 1; long long ret = 0; int n = 1; for(int i = 1; i &lt; s.size(); i++){ if(s[i] == s[i-1]){ n++; } else{ ret += (1+n)*n/2; n = 1; } if(i == s.size()-1){ ret += (long long) (1+n)*n/2; n = 1; } ret %= 1000000007; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-number-of-homogenous-substrings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5676. 生成交替二进制字符串的最少操作数]]></title>
    <url>%2F2021%2F02%2F15%2Fleetcode%205676.%20%E7%94%9F%E6%88%90%E4%BA%A4%E6%9B%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个仅由字符 ‘0’ 和 ‘1’ 组成的字符串 s 。一步操作中，你可以将任一 ‘0’ 变成 ‘1’ ，或者将 ‘1’ 变成 ‘0’ 。 交替字符串 定义为：如果字符串中不存在相邻两个字符相等的情况，那么该字符串就是交替字符串。例如，字符串 “010” 是交替字符串，而字符串 “0100” 不是。 返回使 s 变成 交替字符串 所需的 最少 操作数。 示例：示例 1： 输入：s = &quot;0100&quot; 输出：1 解释：如果将最后一个字符变为 &apos;1&apos; ，s 就变成 &quot;0101&quot; ，即符合交替字符串定义。 示例 2： 输入：s = &quot;10&quot; 输出：0 解释：s 已经是交替字符串。 示例 3： 输入：s = &quot;1111&quot; 输出：2 解释：需要 2 步操作得到 &quot;0101&quot; 或 &quot;1010&quot; 。 提示： 1 &lt;= s.length &lt;= 10^4 s[i] 是 ‘0’ 或 ‘1’ 分析：就两种情况，0开头或1开头 遍历后比较哪种需要变动的位数少即可 代码：class Solution { public: int minOperations(string s) { int n1 = 0; int n2 = 0; for(int i = 0; i &lt; s.size(); i++){ if(i % 2 == 0 &amp;&amp; s[i] == &apos;0&apos;){ n1++; } else if(i % 2 == 1 &amp;&amp; s[i] == &apos;1&apos;){ n1++; } if(i % 2 == 0 &amp;&amp; s[i] == &apos;1&apos;){ n2++; } else if(i % 2 == 1 &amp;&amp; s[i] == &apos;0&apos;){ n2++; } } return n1 &lt; n2 ? n1 : n2; } }; 题目地址:https://leetcode-cn.com/problems/minimum-changes-to-make-alternating-binary-string/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5675. 最接近目标值的子序列和]]></title>
    <url>%2F2021%2F02%2F08%2Fleetcode%205675.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 和一个目标值 goal 。 你需要从 nums 中选出一个子序列，使子序列元素总和最接近 goal 。也就是说，如果子序列元素和为 sum ，你需要 最小化绝对差 abs(sum - goal) 。 返回 abs(sum - goal) 可能的 最小值 。 注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。 示例：示例 1： 输入：nums = [5,-7,3,5], goal = 6 输出：0 解释：选择整个数组作为选出的子序列，元素和为 6 。 子序列和与目标值相等，所以绝对差为 0 。 示例 2： 输入：nums = [7,-9,15,-2], goal = -5 输出：1 解释：选出子序列 [7,-9,-2] ，元素和为 -4 。 绝对差为 abs(-4 - (-5)) = abs(1) = 1 ，是可能的最小值。 示例 3： 输入：nums = [1,2,3], goal = -7 输出：7 提示： 1 &lt;= nums.length &lt;= 40 -10^7 &lt;= nums[i] &lt;= 10^7 -10^9 &lt;= goal &lt;= 10^9 分析：将数组分为两半，各自穷举所有子集 遍历一半数组，另外一半数组排序后通过二分找出最合适的值 代码：class Solution { private: vector&lt;int&gt; nl; vector&lt;int&gt; nr; public: void dfs(vector&lt;int&gt;&amp; nums, int i, int n, bool lr){ if(!lr &amp;&amp; nums.size()/2 == i){ nl.push_back(n); return; } else if(lr &amp;&amp; nums.size() == i){ nr.push_back(n); return; } dfs(nums, i+1, n + nums[i], lr); dfs(nums, i+1, n, lr); } int minAbsDifference(vector&lt;int&gt;&amp; nums, int goal) { dfs(nums, 0, 0, false); dfs(nums, nums.size()/2, 0, true); sort(nr.begin(), nr.end()); int ret = INT_MAX; for(int i = 0; i &lt; nl.size(); i++){ int l = 0; int r = nr.size()-1; int g = goal - nl[i]; if(nr[0] &gt; g){ ret = min(abs(nr[0] - g), ret); continue; } if(nr.back() &lt; g){ ret = min(abs(nr.back() - g), ret); continue; } while(l &lt; r){ int m = (l+r)/2; if(nr[m] == g){ return 0; } else if(nr[m] &lt; g){ l = m+1; } else{ r = m; } } ret = min(abs(nr[l] - g), ret); ret = min(abs(nr[l-1] - g), ret); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/closest-subsequence-sum/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5678. 袋子里最少数目的球]]></title>
    <url>%2F2021%2F02%2F08%2Fleetcode%205678.%20%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。 你可以进行如下操作至多 maxOperations 次： 选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。 请你返回进行上述操作后的最小开销。 示例：示例 1： 输入：nums = [9], maxOperations = 2 输出：3 解释： - 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -&gt; [6,3] 。 - 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -&gt; [3,3,3] 。 装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 示例 2： 输入：nums = [2,4,8,2], maxOperations = 4 输出：2 解释： - 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -&gt; [2,4,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -&gt; [2,2,2,4,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -&gt; [2,2,2,2,2,4,2] 。 - 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -&gt; [2,2,2,2,2,2,2,2] 。 装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。 示例 3： 输入：nums = [7,17], maxOperations = 2 输出：7 提示： 1 &lt;= nums.length &lt;= 10^5 &lt;= maxOperations, nums[i] &lt;= 10^9 分析：使用二分查找，下界为1，上界为10^9 如果无法在maxOperations次内将球分到要求数目以下，提高下界 如果当前可行，尝试缩小开销 多次二分直到找到最小开销 代码：class Solution { public: int minimumSize(vector&lt;int&gt;&amp; nums, int maxOperations) { int l = 1; int r = 1000000000; while(l &lt; r){ int m = (l+r)/2; int n = 0; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] == 1) continue; n += (nums[i] - 1) / m; } if(n &gt; maxOperations){ l = m+1; } else{ r = m; } } return l; } }; 题目地址:https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5674. 构造字典序最大的合并字符串]]></title>
    <url>%2F2021%2F02%2F08%2Fleetcode%205674.%20%E6%9E%84%E9%80%A0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%A4%A7%E7%9A%84%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你两个字符串 word1 和 word2 。你需要按下述方式构造一个新字符串 merge ：如果 word1 或 word2 非空，选择 下面选项之一 继续操作： 如果 word1 非空，将 word1 中的第一个字符附加到 merge 的末尾，并将其从 word1 中移除。 例如，word1 = “abc” 且 merge = “dv” ，在执行此选项操作之后，word1 = “bc” ，同时 merge = “dva” 。 如果 word2 非空，将 word2 中的第一个字符附加到 merge 的末尾，并将其从 word2 中移除。 例如，word2 = “abc” 且 merge = “” ，在执行此选项操作之后，word2 = “bc” ，同时 merge = “a” 。 返回你可以构造的字典序 最大 的合并字符串 merge 。 长度相同的两个字符串 a 和 b 比较字典序大小，如果在 a 和 b 出现不同的第一个位置，a 中字符在字母表中的出现顺序位于 b 中相应字符之后，就认为字符串 a 按字典序比字符串 b 更大。例如，”abcd” 按字典序比 “abcc” 更大，因为两个字符串出现不同的第一个位置是第四个字符，而 d 在字母表中的出现顺序位于 c 之后。 示例：示例 1： 输入：word1 = &quot;cabaa&quot;, word2 = &quot;bcaaa&quot; 输出：&quot;cbcabaaaaa&quot; 解释：构造字典序最大的合并字符串，可行的一种方法如下所示： - 从 word1 中取第一个字符：merge = &quot;c&quot;，word1 = &quot;abaa&quot;，word2 = &quot;bcaaa&quot; - 从 word2 中取第一个字符：merge = &quot;cb&quot;，word1 = &quot;abaa&quot;，word2 = &quot;caaa&quot; - 从 word2 中取第一个字符：merge = &quot;cbc&quot;，word1 = &quot;abaa&quot;，word2 = &quot;aaa&quot; - 从 word1 中取第一个字符：merge = &quot;cbca&quot;，word1 = &quot;baa&quot;，word2 = &quot;aaa&quot; - 从 word1 中取第一个字符：merge = &quot;cbcab&quot;，word1 = &quot;aa&quot;，word2 = &quot;aaa&quot; - 将 word1 和 word2 中剩下的 5 个 a 附加到 merge 的末尾。 示例 2： 输入：word1 = &quot;abcabc&quot;, word2 = &quot;abdcaba&quot; 输出：&quot;abdcabcabcaba&quot; 提示： 1 &lt;= word1.length, word2.length &lt;= 3000 word1 和 word2 仅由小写英文组成 分析：如果字符不同，选择大的字符添加；如果字符相同，依次比较，直到遇到不同字符为止，选择大的字符所属的字符串添加 代码：class Solution { public: string largestMerge(string word1, string word2) { int a = 0; int b = 0; while(a &lt; word1.size() &amp;&amp; b &lt; word2.size()){ if(word1[a] &gt; word2[b]){ str = str + word1[a]; a++; } else if(word1[a] &lt; word2[b]){ str = str + word2[b]; b++; } else if(word1[a] == word2[b]){ int a1 = a; int b1 = b; while(a1 &lt; word1.size() &amp;&amp; b1 &lt; word2.size() &amp;&amp; word1[a1] == word2[b1]){ a1++; b1++; } if(a1 &lt; word1.size() &amp;&amp; b1 &lt; word2.size()){ if(word1[a1] &gt; word2[b1]){ str = str + word1[a]; a++; } else{ str = str + word2[b]; b++; } } else if(a1 &lt; word1.size()){ str = str + word1[a]; a++; } else{ str = str + word2[b]; b++; } } } while(a &lt; word1.size()){ str = str + word1[a]; a++; } while(b &lt; word2.size()){ str = str + word2[b]; b++; } return str; } }; 题目地址:https://leetcode-cn.com/problems/largest-merge-of-two-strings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5673. 移除石子的最大得分]]></title>
    <url>%2F2021%2F02%2F08%2Fleetcode%205673.%20%E7%A7%BB%E9%99%A4%E7%9F%B3%E5%AD%90%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目：你正在玩一个单人游戏，面前放置着大小分别为 a​​​​​​、b 和 c​​​​​​ 的 三堆 石子。 每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。当存在 两个或更多 的空堆时，游戏停止。 给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。 示例：示例 1： 输入：a = 2, b = 4, c = 6 输出：6 解释：石子起始状态是 (2, 4, 6) ，最优的一组操作是： - 从第一和第三堆取，石子状态现在是 (1, 4, 5) - 从第一和第三堆取，石子状态现在是 (0, 4, 4) - 从第二和第三堆取，石子状态现在是 (0, 3, 3) - 从第二和第三堆取，石子状态现在是 (0, 2, 2) - 从第二和第三堆取，石子状态现在是 (0, 1, 1) - 从第二和第三堆取，石子状态现在是 (0, 0, 0) 总分：6 分 。 示例 2： 输入：a = 4, b = 4, c = 6 输出：7 解释：石子起始状态是 (4, 4, 6) ，最优的一组操作是： - 从第一和第二堆取，石子状态现在是 (3, 3, 6) - 从第一和第三堆取，石子状态现在是 (2, 3, 5) - 从第一和第三堆取，石子状态现在是 (1, 3, 4) - 从第一和第三堆取，石子状态现在是 (0, 3, 3) - 从第二和第三堆取，石子状态现在是 (0, 2, 2) - 从第二和第三堆取，石子状态现在是 (0, 1, 1) - 从第二和第三堆取，石子状态现在是 (0, 0, 0) 总分：7 分 。 示例 3： 输入：a = 1, b = 8, c = 8 输出：8 解释：最优的一组操作是连续从第二和第三堆取 8 回合，直到将它们取空。 注意，由于第二和第三堆已经空了，游戏结束，不能继续从第一堆中取石子。 提示： 1 &lt;= a, b, c &lt;= 10^5 分析：每次取最大和最小的堆中的石子 还可以分类讨论： 两个堆加起来没有另外一个堆大，分数为两小堆之和 如果三个堆和为奇数，分数为（a+b+c）/ 2，抹去小数（因为会有一个堆留一个石子） 如果三个堆和为奇数，则刚好取完，分数为（a+b+c）/ 2 代码：class Solution { public: int maximumScore(int a, int b, int c) { int aa = min(a, min(b, c)); int ret = 0; int bb; int cc; if(aa == a){ bb = b; cc = c; } else if(aa == b){ bb = a; cc = c; } else if(aa == c){ bb = a; cc = b; } while(bb &gt; 0 &amp;&amp; cc &gt; 0){ ret++; if(aa &gt; 0){ if(bb &gt; cc){ bb--; } else{ cc--; } aa--; } else{ bb--; cc--; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-score-from-removing-stones/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5672. 检查数组是否经排序和轮转得到]]></title>
    <url>%2F2021%2F02%2F08%2Fleetcode%205672.%20%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E7%BB%8F%E6%8E%92%E5%BA%8F%E5%92%8C%E8%BD%AE%E8%BD%AC%E5%BE%97%E5%88%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 nums 。nums 的源数组中，所有元素与 nums 相同，但按非递减顺序排列。 如果 nums 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 true ；否则，返回 false 。 源数组中可能存在 重复项 。 注意：我们称数组 A 在轮转 x 个位置后得到长度相同的数组 B ，当它们满足 A[i] == B[(i+x) % A.length] ，其中 % 为取余运算。 示例：示例 1： 输入：nums = [3,4,5,1,2] 输出：true 解释：[1,2,3,4,5] 为有序的源数组。 可以轮转 x = 3 个位置，使新数组从值为 3 的元素开始：[3,4,5,1,2] 。 示例 2： 输入：nums = [2,1,3,4] 输出：false 解释：源数组无法经轮转得到 nums 。 示例 3： 输入：nums = [1,2,3] 输出：true 解释：[1,2,3] 为有序的源数组。 可以轮转 x = 0 个位置（即不轮转）得到 nums 。 示例 4： 输入：nums = [1,1,1] 输出：true 解释：[1,1,1] 为有序的源数组。 轮转任意个位置都可以得到 nums 。 示例 5： 输入：nums = [2,1] 输出：true 解释：[1,2] 为有序的源数组。 可以轮转 x = 5 个位置，使新数组从值为 2 的元素开始：[2,1] 。 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 分析：轮转后会让数组变成前半段和后半段各按非递减顺序排列，这时只要比一下最后一个数字是否小于第一个数字即可 这道题目还可以直接暴力按每个元素旋转遍历一遍得出答案 代码：class Solution { public: bool check(vector&lt;int&gt;&amp; nums) { if(nums.size() == 1) return true; for(int i = 0; i &lt; nums.size(); i++){ for(int j = 1; j &lt; nums.size(); j++){ if(nums[(i+j-1)%nums.size()] &gt; nums[(i+j)%nums.size()]) break; if(j == nums.size()-1) return true; } } return false; } }; 题目地址:https://leetcode-cn.com/problems/check-if-array-is-sorted-and-rotated/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5666. 回文串分割 IV]]></title>
    <url>%2F2021%2F02%2F01%2Fleetcode%205666.%20%E5%9B%9E%E6%96%87%E4%B8%B2%E5%88%86%E5%89%B2%20IV%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s ，如果可以将它分割成三个 非空 回文子字符串，那么返回 true ，否则返回 false 。 当一个字符串正着读和反着读是一模一样的，就称其为 回文字符串 。 示例：示例 1： 输入：s = &quot;abcbdd&quot; 输出：true 解释：&quot;abcbdd&quot; = &quot;a&quot; + &quot;bcb&quot; + &quot;dd&quot;，三个子字符串都是回文的。 示例 2： 输入：s = &quot;bcbddxy&quot; 输出：false 解释：s 没办法被分割成 3 个回文子字符串。 提示： 3 &lt;= s.length &lt;= 2000 s​​​​​​ 只包含小写英文字母。 分析：dp[i][j] 表示从i到j是否为回文串 双指针遍历，尝试所有分割位置 代码：class Solution { public: bool checkPartitioning(string s) { vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false)); for(int i = 0; i &lt; s.size(); i++){ for(int j = 0; j+i &lt; s.size(); j++){ if(i == 0) dp[j][j+i] = true; else if(i == 1){ if(s[j] == s[j+i]) dp[j][j+i] = true; } else{ if(s[j] == s[j+i] &amp;&amp; dp[j+1][j+i-1]) dp[j][j+i] = true; } } } for(int l = 1; l &lt; s.size(); l++){ if(dp[0][l-1] == false) continue; for(int r = l+1; r &lt; s.size(); r++){ if(dp[l][r-1] &amp;&amp; dp[r][s.size()-1]) return true; } } return false; } }; 题目地址:https://leetcode-cn.com/problems/palindrome-partitioning-iv/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5667. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？]]></title>
    <url>%2F2021%2F02%2F01%2Fleetcode%205667.%20%E4%BD%A0%E8%83%BD%E5%9C%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E9%82%A3%E5%A4%A9%E5%90%83%E5%88%B0%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%B3%96%E6%9E%9C%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。 你按照如下规则进行一场游戏： 你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。 请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。 请你返回得到的数组 answer 。 示例：示例 1： 输入：candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]] 输出：[true,false,true] 提示： 1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。 2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。 3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。 示例 2： 输入：candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]] 输出：[false,true,true,false,false] 提示： 1 &lt;= candiesCount.length &lt;= 105 1 &lt;= candiesCount[i] &lt;= 105 1 &lt;= queries.length &lt;= 105 queries[i].length == 3 0 &lt;= favoriteTypei &lt; candiesCount.length 0 &lt;= favoriteDayi &lt;= 109 1 &lt;= dailyCapi &lt;= 109 分析：前缀和记录糖果数量 求出到目标天数位置可以吃到的最多糖数和最少糖数 判断想要吃的糖的数量是否在最多糖数和最少糖数之间 代码：class Solution { public: vector&lt;bool&gt; canEat(vector&lt;int&gt;&amp; candiesCount, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { vector&lt;long long&gt; v(candiesCount.size(), 0); vector&lt;bool&gt; ret(queries.size(), false); v[0] = candiesCount[0]; for(int i = 1; i &lt; candiesCount.size(); i++){ v[i] = v[i-1] + candiesCount[i]; } for(int i = 0; i &lt; queries.size(); i++){ long long num = queries[i][1]+1; int l = 0; int r = v.size()-1; while(l &lt; r){ int m = (l+r)/2; if(v[m] &gt;= num){ r = m; } else{ l = m+1; } } if(l &gt; queries[i][0] || num &gt; v.back()){ continue; } num = (long long) (queries[i][1]+1) * queries[i][2]; l = 0; r = v.size()-1; while(l &lt; r){ int m = (l+r)/2; if(v[m] &gt;= num){ r = m; } else{ l = m+1; } } if(l &gt;= queries[i][0]){ ret[i] = true; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5665. 从相邻元素对还原数组]]></title>
    <url>%2F2021%2F02%2F01%2Fleetcode%205665.%20%E4%BB%8E%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%AF%B9%E8%BF%98%E5%8E%9F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。 给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。 题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。 返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。 示例：示例 1： 输入：adjacentPairs = [[2,1],[3,4],[3,2]] 输出：[1,2,3,4] 解释：数组的所有相邻元素对都在 adjacentPairs 中。 特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。 示例 2： 输入：adjacentPairs = [[4,-2],[1,4],[-3,1]] 输出：[-2,4,1,-3] 解释：数组中可能存在负数。 另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。 示例 3： 输入：adjacentPairs = [[100000,-100000]] 输出：[100000,-100000] 提示： nums.length == n adjacentPairs.length == n - 1 adjacentPairs[i].length == 2 2 &lt;= n &lt;= 105 -105 &lt;= nums[i], ui, vi &lt;= 105 题目数据保证存在一些以 adjacentPairs 作为元素对的数组 nums 分析：使用map存储每个数相邻的两个数（有两个数相邻只有一个） 找出其中一个相邻只有一个的数，以这个数为数组的头，依次得出整个数组 代码：class Solution { public: vector&lt;int&gt; restoreArray(vector&lt;vector&lt;int&gt;&gt;&amp; adjacentPairs) { map&lt;int, vector&lt;int&gt;&gt; m; vector&lt;int&gt; ret; for(int i = 0; i &lt; adjacentPairs.size(); i++){ m[adjacentPairs[i][0]].push_back(adjacentPairs[i][1]); m[adjacentPairs[i][1]].push_back(adjacentPairs[i][0]); } for(auto a = m.begin(); a != m.end(); a++){ if(a-&gt;second.size() == 1){ ret.push_back(a-&gt;first); ret.push_back(m[a-&gt;first][0]); break; } } while(m[ret.back()].size() == 2){ if(m[ret.back()][0] == ret[ret.size()-2]){ ret.push_back(m[ret.back()][1]); } else{ ret.push_back(m[ret.back()][0]); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5654. 盒子中小球的最大数量]]></title>
    <url>%2F2021%2F02%2F01%2Fleetcode%205654.%20%E7%9B%92%E5%AD%90%E4%B8%AD%E5%B0%8F%E7%90%83%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：你在一家生产小球的玩具厂工作，有 n 个小球，编号从 lowLimit 开始，到 highLimit 结束（包括 lowLimit 和 highLimit ，即 n == highLimit - lowLimit + 1）。另有无限数量的盒子，编号从 1 到 infinity 。 你的工作是将每个小球放入盒子中，其中盒子的编号应当等于小球编号上每位数字的和。例如，编号 321 的小球应当放入编号 3 + 2 + 1 = 6 的盒子，而编号 10 的小球应当放入编号 1 + 0 = 1 的盒子。 给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。如果有多个盒子都满足放有最多小球，只需返回其中任一盒子的小球数量。 示例：示例 1： 输入：lowLimit = 1, highLimit = 10 输出：2 解释： 盒子编号：1 2 3 4 5 6 7 8 9 10 11 ... 小球数量：2 1 1 1 1 1 1 1 1 0 0 ... 编号 1 的盒子放有最多小球，小球数量为 2 。 示例 2： 输入：lowLimit = 5, highLimit = 15 输出：2 解释： 盒子编号：1 2 3 4 5 6 7 8 9 10 11 ... 小球数量：1 1 1 1 2 2 1 1 1 0 0 ... 编号 5 和 6 的盒子放有最多小球，每个盒子中的小球数量都是 2 。 示例 3： 输入：lowLimit = 19, highLimit = 28 输出：2 解释： 盒子编号：1 2 3 4 5 6 7 8 9 10 11 12 ... 小球数量：0 1 1 1 1 1 1 1 1 2 0 0 ... 编号 10 的盒子放有最多小球，小球数量为 2 。 提示： 1 &lt;= lowLimit &lt;= highLimit &lt;= 105 分析：直接遍历所有编号，使用map存储各盒子放的球的数量。最后遍历得出最多的盒子放的数量即可 代码：class Solution { public: int countBalls(int lowLimit, int highLimit) { map&lt;int, int&gt; m; for(int i = lowLimit; i &lt;= highLimit; i++){ int z = 0; int j = i; while(j &gt; 0){ z = z + j % 10; j /= 10; } m[z]++; } int ret = 0; for(auto a = m.begin(); a != m.end(); a++){ ret = max(ret, a-&gt;second); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-balls-in-a-box/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5664. 放置盒子]]></title>
    <url>%2F2021%2F01%2F25%2Fleetcode%205664.%20%E6%94%BE%E7%BD%AE%E7%9B%92%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目：有一个立方体房间，其长度、宽度和高度都等于 n 个单位。请你在房间里放置 n 个盒子，每个盒子都是一个单位边长的立方体。放置规则如下： 你可以把盒子放在地板上的任何地方。 如果盒子 x 需要放置在盒子 y 的顶部，那么盒子 y 竖直的四个侧面都 必须 与另一个盒子或墙相邻。 给你一个整数 n ，返回接触地面的盒子的 最少 可能数量。 示例：示例 1： 输入：n = 3 输出：3 解释：上图是 3 个盒子的摆放位置。 这些盒子放在房间的一角，对应左侧位置。 示例 2： 输入：n = 4 输出：3 解释：上图是 3 个盒子的摆放位置。 这些盒子放在房间的一角，对应左侧位置。 示例 3： 输入：n = 10 输出：6 解释：上图是 10 个盒子的摆放位置。 这些盒子放在房间的一角，对应后方位置。 提示： 1 &lt;= n &lt;= 109 分析：每次在最底部加一个盒子可以多放的盒子数量有一个规律 1 1 1 2，1 1 2，1 1 1 2，1 2，1 1 3，2，1 2，1 1 直接照着规律写代码即可 代码：class Solution { public: int minimumBoxes(int n) { int ret = 1; for(int sum = 1, x = 1; sum &lt; n; x++){ for(int i = 0; i &lt;= x &amp;&amp; sum &lt; n; i++){ sum += i+1; ret += 1; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/building-boxes/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2021%2F01%2F25%2Fleetcode%205663.%20%E6%89%BE%E5%87%BA%E7%AC%AC%20K%20%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%E5%9D%90%E6%A0%87%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。 矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &lt;= i &lt;= a &lt; m 且 0 &lt;= j &lt;= b &lt; n 的元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。 请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数） 示例：示例 1： 输入：matrix = [[5,2],[1,6]], k = 1 输出：7 解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。 示例 2： 输入：matrix = [[5,2],[1,6]], k = 2 输出：5 解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。 示例 3： 输入：matrix = [[5,2],[1,6]], k = 3 输出：4 解释：坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。 示例 4： 输入：matrix = [[5,2],[1,6]], k = 4 输出：0 解释：坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。 提示： m == matrix.length n == matrix[i].length 1 &lt;= m, n &lt;= 1000 0 &lt;= matrix[i][j] &lt;= 106 1 &lt;= k &lt;= m * n 分析：动态规划 dp[i][j]，表示以第i行第j列为右下角的异或值 维护一个当前行前缀异或 dp[i][j] = dp[i-1][j] ^ 当前行到j-1的异或值 代码：bool bj(int a, int b){ return a &gt; b; } class Solution { public: int kthLargestValue(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) { int m = matrix.size(); int n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; v(m, vector&lt;int&gt;(n, 0)); vector&lt;int&gt; ret; ret.push_back(matrix[0][0]); v[0][0] = matrix[0][0]; for(int i = 1; i &lt; n; i++){ v[0][i] = matrix[0][i] ^ v[0][i-1]; ret.push_back(v[0][i]); } for(int i = 1; i &lt; m; i++){ int z = 0; for(int j = 0; j &lt; n; j++){ if(j == 0){ v[i][j] = v[i-1][j] ^ matrix[i][j]; z = matrix[i][j]; ret.push_back(v[i][j]); } else{ z = z ^ matrix[i][j]; v[i][j] = v[i-1][j] ^ z; ret.push_back(v[i][j]); } } } sort(ret.begin(), ret.end(), bj); return ret[k-1]; } }; 题目地址:https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5662. 满足三条件之一需改变的最少字符数]]></title>
    <url>%2F2021%2F01%2F25%2Fleetcode%205662.%20%E6%BB%A1%E8%B6%B3%E4%B8%89%E6%9D%A1%E4%BB%B6%E4%B9%8B%E4%B8%80%E9%9C%80%E6%94%B9%E5%8F%98%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你两个字符串 a 和 b ，二者均由小写字母组成。一步操作中，你可以将 a 或 b 中的 任一字符 改变为 任一小写字母 。 操作的最终目标是满足下列三个条件 之一 ： a 中的 每个字母 在字母表中 严格小于 b 中的 每个字母 。 b 中的 每个字母 在字母表中 严格小于 a 中的 每个字母 。 a 和 b 都 由 同一个 字母组成。 返回达成目标所需的 最少 操作数。 示例：示例 1： 输入：a = &quot;aba&quot;, b = &quot;caa&quot; 输出：2 解释：满足每个条件的最佳方案分别是： 1) 将 b 变为 &quot;ccc&quot;，2 次操作，满足 a 中的每个字母都小于 b 中的每个字母； 2) 将 a 变为 &quot;bbb&quot; 并将 b 变为 &quot;aaa&quot;，3 次操作，满足 b 中的每个字母都小于 a 中的每个字母； 3) 将 a 变为 &quot;aaa&quot; 并将 b 变为 &quot;aaa&quot;，2 次操作，满足 a 和 b 由同一个字母组成。 最佳的方案只需要 2 次操作（满足条件 1 或者条件 3）。 示例 2： 输入：a = &quot;dabadd&quot;, b = &quot;cda&quot; 输出：3 解释：满足条件 1 的最佳方案是将 b 变为 &quot;eee&quot; 。 提示： 1 &lt;= a.length, b.length &lt;= 105 a 和 b 只由小写字母组成 分析：遍历统计两个字符中每个字母的个数 对每个字母i来说 满足条件1就是将a中大于i的字母全部修改为”a”，将b中所有小于等于i的字母全部修改为”z” 满足条件2就是将a中小于等于i的字母全部修改为”z”，将b中所有大于i的字母全部修改为”a” 条件3就是a和b中除了i以外的字母数量 代码：class Solution { public: int minCharacters(string a, string b) { int ret = INT_MAX; vector&lt;int&gt; a1(26, 0); vector&lt;int&gt; b1(26, 0); for(int i = 0; i &lt; a.size(); i++){ a1[a[i]-&apos;a&apos;]++; } for(int i = 0; i &lt; b.size(); i++){ b1[b[i]-&apos;a&apos;]++; } vector&lt;int&gt; a2 = a1; vector&lt;int&gt; b2 = b1; for(int i = 1; i &lt; 26; i++){ a2[i] = a2[i-1] + a2[i]; b2[i] = b2[i-1] + b2[i]; ret = min(int(a.size() + b.size() - b1[i] - a1[i]), ret); } for(int i = 0; i &lt; 25; i++){ ret = min(ret, a2[i] + b2[25] - b2[i]); ret = min(ret, b2[i] + a2[25] - a2[i]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5661. 替换隐藏数字得到的最晚时间]]></title>
    <url>%2F2021%2F01%2F25%2Fleetcode%205661.%20%E6%9B%BF%E6%8D%A2%E9%9A%90%E8%97%8F%E6%95%B0%E5%AD%97%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E6%99%9A%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。 有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。 替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。 示例：示例 1： 输入：time = &quot;2?:?0&quot; 输出：&quot;23:50&quot; 解释：以数字 &apos;2&apos; 开头的最晚一小时是 23 ，以 &apos;0&apos; 结尾的最晚一分钟是 50 。 示例 2： 输入：time = &quot;0?:3?&quot; 输出：&quot;09:39&quot; 示例 3： 输入：time = &quot;1?:22&quot; 输出：&quot;19:22&quot; 提示： time 的格式为 hh:mm 题目数据保证你可以由输入的字符串生成有效的时间 分析：if else 分情况讨论即可 代码：class Solution { public: string maximumTime(string time) { string ret = time; if(time[0] == &apos;?&apos; &amp;&amp; time[1] == &apos;?&apos;){ ret[0] = &apos;2&apos;; ret[1] = &apos;3&apos;; } else if(time[0] == &apos;?&apos;){ if(time[1] &lt; &apos;4&apos;){ ret[0] = &apos;2&apos;; } else{ ret[0] = &apos;1&apos;; } } else if(time[1] == &apos;?&apos;){ if(time[0] == &apos;2&apos;){ ret[1] = &apos;3&apos;; } else{ ret[1] = &apos;9&apos;; } } if(time[3] == &apos;?&apos;){ ret[3] = &apos;5&apos;; } if(time[4] == &apos;?&apos;){ ret[4] = &apos;9&apos;; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1728. 猫和老鼠 II]]></title>
    <url>%2F2021%2F01%2F18%2Fleetcode%201728.%20%E7%8C%AB%E5%92%8C%E8%80%81%E9%BC%A0%20II%2F</url>
    <content type="text"><![CDATA[题目：一只猫和一只老鼠在玩一个叫做猫和老鼠的游戏。 它们所处的环境设定是一个 rows x cols 的方格 grid ，其中每个格子可能是一堵墙、一块地板、一位玩家（猫或者老鼠）或者食物。 玩家由字符 ‘C’ （代表猫）和 ‘M’ （代表老鼠）表示。 地板由字符 ‘.’ 表示，玩家可以通过这个格子。墙用字符 ‘#’ 表示，玩家不能通过这个格子。食物用字符 ‘F’ 表示，玩家可以通过这个格子。字符 ‘C’ ， ‘M’ 和 ‘F’ 在 grid 中都只会出现一次。 猫和老鼠按照如下规则移动： 老鼠 先移动 ，然后两名玩家轮流移动。 每一次操作时，猫和老鼠可以跳到上下左右四个方向之一的格子，他们不能跳过墙也不能跳出 grid 。 catJump 和 mouseJump 是猫和老鼠分别跳一次能到达的最远距离，它们也可以跳小于最大距离的长度。 它们可以停留在原地。 老鼠可以跳跃过猫的位置。 游戏有 4 种方式会结束： 如果猫跟老鼠处在相同的位置，那么猫获胜。 如果猫先到达食物，那么猫获胜。 如果老鼠先到达食物，那么老鼠获胜。 如果老鼠不能在 1000 次操作以内到达食物，那么猫获胜。 给你 rows x cols 的矩阵 grid 和两个整数 catJump 和 mouseJump ，双方都采取最优策略，如果老鼠获胜，那么请你返回 true ，否则返回 false 。 示例：示例 1： 输入：grid = [&quot;####F&quot;,&quot;#C...&quot;,&quot;M....&quot;], catJump = 1, mouseJump = 2 输出：true 解释：猫无法抓到老鼠，也没法比老鼠先到达食物。 示例 2： 输入：grid = [&quot;M.C...F&quot;], catJump = 1, mouseJump = 4 输出：true 示例 3： 输入：grid = [&quot;M.C...F&quot;], catJump = 1, mouseJump = 3 输出：false 示例 4： 输入：grid = [&quot;C...#&quot;,&quot;...#F&quot;,&quot;....#&quot;,&quot;M....&quot;], catJump = 2, mouseJump = 5 输出：false 示例 5： 输入：grid = [&quot;.M...&quot;,&quot;..#..&quot;,&quot;#..#.&quot;,&quot;C#.#.&quot;,&quot;...#F&quot;], catJump = 3, mouseJump = 1 输出：true 提示： rows == grid.length cols = grid[i].length 1 &lt;= rows, cols &lt;= 8 grid[i][j] 只包含字符 ‘C’ ，’M’ ，’F’ ，’.’ 和 ‘#’ 。 grid 中只包含一个 ‘C’ ，’M’ 和 ‘F’ 。 1 &lt;= catJump, mouseJump &lt;= 8 分析：主要理清楚一个思路，老鼠无法走重复的格子。因为，只要老鼠可以走回原来的格子，猫也一定可以。所以问题就变成了怎么让老鼠在最多64步走到食物 dp[8][8][8][8][128] // 分别为 猫的x坐标，猫的y坐标，老鼠的x坐标，老鼠的y坐标，当前的步数（应为最多进行64个回合，所以最多128步），存储的值为吃到食物还需要的步数 然后就是博弈问题了，详见代码 代码：class Solution { private: int n, m; int cj, mj; vector&lt;string&gt; g; int dx[4] = {0, -1, 0, 1}; int dy[4] = {1, 0, -1, 0}; int dp[8][8][8][8][128]; const int INF = 10000; public: int dfs(int cx, int cy, int mx, int my, int step){ if(step &gt;= 128) return INF; // 当步数大于等于128时，就表示老鼠输了 if(cx == mx &amp;&amp; cy == my) return INF; // 当猫和老鼠在同一个位置时，表示老鼠输了 if(g[cx][cy] == &apos;F&apos;) return INF; // 当猫走到食物时，表示老鼠输了 if(g[mx][my] == &apos;F&apos;) return 0; // 当老鼠走到食物时，表示老鼠赢了，返回吃到食物需要的步数，也就是0 if(dp[cx][cy][mx][my][step] != -1) return dp[cx][cy][mx][my][step]; // 当已经计算过的情况出现时，直接返回 int ans, ret; if(step % 2 == 0) ans = INF; // ans在当前为老鼠的回合时，默认值为一个大数 else ans = 0; // ans在当前为猫的回合时，默认值为0 for(int i = 0; i &lt; 4; i++){ // 四个方向 for(int j = 0; j &lt;= (step%2 == 0 ? mj : cj); j++){ // 能走的步数 int x, y; if(step%2 == 0) x = mx, y = my; else x = cx, y = cy; x += dx[i]*j; y += dy[i]*j; if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) break; // 如果走到边，退出当前循环 if(g[x][y] == &apos;#&apos;) break; // 如果走到墙，退出当前循环 if(step%2 == 0) ret = dfs(cx, cy, x, y, step+1); // 为老鼠时的参数 else ret = dfs(x, y, mx, my, step+1); // 为猫时的参数 if(step%2 == 0) ans = min(ret+1, ans); // 为老鼠时的返回值尽量选择吃到食物的步数尽量小的 else ans = max(ret, ans); // 为猫时的返回值尽量选择让老鼠吃到食物的步骤尽可能多的 } } dp[cx][cy][mx][my][step] = ans; return ans; } bool canMouseWin(vector&lt;string&gt;&amp; grid, int catJump, int mouseJump) { n = grid.size(); m = grid[0].size(); cj = catJump; mj = mouseJump; g = grid; memset(dp, -1, sizeof(dp)); int cx, cy, mx, my; for(int i = 0; i &lt; n; i++){ // 找到猫和老鼠的起点 for(int j = 0; j &lt; m; j++){ if(grid[i][j] == &apos;C&apos;){ cx = i; cy = j; } if(grid[i][j] == &apos;M&apos;){ mx = i; my = j; } } } int res = dfs(cx, cy, mx, my, 0); // 如果需要的步数小于等于1000的话，返回true（实际只要老鼠能吃到食物，就一定在64回合内） if(res &lt;= 1000) return true; else return false; } }; 题目地址:https://leetcode-cn.com/problems/cat-and-mouse-ii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1727. 重新排列后的最大子矩阵]]></title>
    <url>%2F2021%2F01%2F18%2Fleetcode%201727.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目：给你一个二进制矩阵 matrix ，它的大小为 m x n ，你可以将 matrix 中的 列 按任意顺序重新排列。 请你返回最优方案下将 matrix 重新排列后，全是 1 的子矩阵面积。 示例：示例 1： 输入：matrix = [[0,0,1],[1,1,1],[1,0,1]] 输出：4 解释：你可以按照上图方式重新排列矩阵的每一列。 最大的全 1 子矩阵是上图中加粗的部分，面积为 4 。 示例 2： 输入：matrix = [[1,0,1,0,1]] 输出：3 解释：你可以按照上图方式重新排列矩阵的每一列。 最大的全 1 子矩阵是上图中加粗的部分，面积为 3 。 示例 3： 输入：matrix = [[1,1,0],[1,0,1]] 输出：2 解释：由于你只能整列整列重新排布，所以没有比面积为 2 更大的全 1 子矩形。 示例 4： 输入：matrix = [[0,0],[0,0]] 输出：0 解释：由于矩阵中没有 1 ，没有任何全 1 的子矩阵，所以面积为 0 。 提示： m == matrix.length n == matrix[i].length 1 &lt;= m * n &lt;= 105 matrix[i][j] 要么是 0 ，要么是 1 。 分析：预处理数组，计算以当前点为底，上方有多少连续的1 遍历每一行，对每一行进行排序，计算每个矩阵大小，每次更新结果即可 代码：bool bj(int a, int b){ return a &gt; b; } class Solution { public: int largestSubmatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int x = matrix.size(); int y = matrix[0].size(); int ret = 0; vector&lt;vector&lt;int&gt;&gt; v(x, vector&lt;int&gt;(y, 0)); for(int j = 0; j &lt; y; j++){ v[0][j] = matrix[0][j]; } for(int i = 1; i &lt; x; i++){ for(int j = 0; j &lt; y; j++){ if(matrix[i][j] == 1){ v[i][j] = v[i-1][j]+1; } } } for(int i = 0; i &lt; x; i++){ sort(v[i].begin(), v[i].end(), bj); } for(int i = x-1; i &gt;= 0; i--){ for(int j = 0; j &lt; y; j++){ ret = max(ret, v[i][j] * (j+1)); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/largest-submatrix-with-rearrangements/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1726. 同积元组]]></title>
    <url>%2F2021%2F01%2F18%2Fleetcode%201726.%20%E5%90%8C%E7%A7%AF%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个由 不同 正整数组成的数组 nums ，请你返回满足 a b = c d 的元组 (a, b, c, d) 的数量。其中 a、b、c 和 d 都是 nums 中的元素，且 a != b != c != d 。 示例：示例 1： 输入：nums = [2,3,4,6] 输出：8 解释：存在 8 个满足题意的元组： (2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3) (3,4,2,6) , (3,4,2,6) , (3,4,6,2) , (4,3,6,2) 示例 2： 输入：nums = [1,2,4,5,10] 输出：16 解释：存在 16 个满足题意的元组： (1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2) (2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1) (2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,4,5) (4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2) 示例 3： 输入：nums = [2,3,4,6,8,12] 输出：40 示例 4： 输入：nums = [2,3,5,7] 输出：0 提示： 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 104 nums 中的所有元素 互不相同 分析：哈希 使用一个map存储所有两个正整数相乘得到的数的个数（a b和b a算两个） 再度遍历两个数相乘的所有可能，使用ret记录元组数量 详细见代码 代码：class Solution { public: int tupleSameProduct(vector&lt;int&gt;&amp; nums) { unordered_map&lt;int, int&gt; m; // 存储每个积出现的次数 int ret = 0; // 记录每个积出现的次数 for(int i = 0; i &lt; nums.size(); i++){ for(int j = 0; j &lt; nums.size(); j++){ if(i == j) continue; m[nums[i] * nums[j]]++; } } for(int i = 0; i &lt; nums.size(); i++){ for(int j = 0; j &lt; nums.size(); j++){ if(i == j) continue; // 减二的原因，假设当前为a和b，之前统计时会记录a*b和b*a各一次，而这两次需要被排除 ret += m[nums[i] * nums[j]] - 2; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/tuple-with-same-product/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1725. 可以形成最大正方形的矩形数目]]></title>
    <url>%2F2021%2F01%2F18%2Fleetcode%201725.%20%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 rectangles ，其中 rectangles[i] = [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。 如果存在 k 同时满足 k &lt;= li 和 k &lt;= wi ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。 设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。 返回可以切出边长为 maxLen 的正方形的矩形 数目 。 示例：示例 1： 输入：rectangles = [[5,8],[3,9],[5,12],[16,5]] 输出：3 解释：能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。 最大正方形的边长为 5 ，可以由 3 个矩形切分得到。 示例 2： 输入：rectangles = [[2,3],[3,7],[4,3],[3,7]] 输出：3 提示： 1 &lt;= rectangles.length &lt;= 1000 rectangles[i].length == 2 1 &lt;= li, wi &lt;= 109 li != wi 分析：使用两个变量，一个表示最大的边长，一个表示最大边长的数量 遍历每个正方形，只需要关注最短的边即可 代码：class Solution { public: int countGoodRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) { int max_num = 0; int max_long = 0; for(int i = 0; i &lt; rectangles.size(); i++){ int a = min(rectangles[i][0], rectangles[i][1]); if(a &gt; max_long){ max_long = a; max_num = 1; } else if(a == max_long){ max_num++; } } return max_num; } }; 题目地址:https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1723. 完成所有工作的最短时间]]></title>
    <url>%2F2021%2F01%2F11%2Fleetcode%201723.%20%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。 请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。 返回分配方案中尽可能 最小 的 最大工作时间 。 示例：示例 1： 输入：jobs = [3,2,3], k = 3 输出：3 解释：给每位工人分配一项工作，最大工作时间是 3 。 示例 2： 输入：jobs = [1,2,4,7,8], k = 2 输出：11 解释：按下述方式分配工作： 1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11） 2 号工人：4、7（工作时间 = 4 + 7 = 11） 最大工作时间是 11 。 提示： 1 &lt;= k &lt;= jobs.length &lt;= 12 1 &lt;= jobs[i] &lt;= 10^7 分析：状压dp dp[state] 原型应该是dp[k][state]，k个工人时已经工作状态为state时的最小最大工作时 代码：class Solution { public: int minimumTimeRequired(vector&lt;int&gt;&amp; jobs, int k) { int n = jobs.size(); vector&lt;int&gt; dp(1&lt;&lt;n, -1); // 原型应该是dp[k][state]，k个工人时已经工作state的最小最大工作时 vector&lt;int&gt; sum(1&lt;&lt;n, 0); // 预处理各个状态需要的工作时长 dp[0] = 0; // 初始化sum for(int i = 0; i &lt; (1&lt;&lt;n); i++){ for(int j = 0; j &lt; n; j++){ if(((1 &lt;&lt; j) &amp; i) != 0){ sum[i] += jobs[j]; } } } for(int k1 = 0; k1 &lt; k; k1++){ // 当前工人数量为k1，每次加一个工人 // 要以--的形式遍历，不能以++的方式遍历，否则会导致重复使用一个工人 for(int ojob = (1&lt;&lt;n)-1; ojob &gt;= 0; ojob--){ if(dp[ojob] == -1) continue; // 如果当前工作状态为-1，表示不存在 int w = (~ojob) &amp; (1&lt;&lt;n)-1; // 获得未完成的工作状态 for(int j = w; j &gt; 0; j = (j-1) &amp; w){ int njob = j | ojob; // 新的工作状态 if(dp[njob] == -1 || dp[njob] &gt; max(dp[ojob], sum[j])) dp[njob] = max(dp[ojob], sum[j]); // 取新的工作时长和旧的工人中最长的工作时长的最大值 } } } return dp[(1&lt;&lt;n)-1]; } }; 题目地址:https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1722. 执行交换操作后的最小汉明距离]]></title>
    <url>%2F2021%2F01%2F11%2Fleetcode%201722.%20%E6%89%A7%E8%A1%8C%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题目：给你两个整数数组 source 和 target ，长度都是 n 。还有一个数组 allowedSwaps ，其中每个 allowedSwaps[i] = [ai, bi] 表示你可以交换数组 source 中下标为 ai 和 bi（下标从 0 开始）的两个元素。注意，你可以按 任意 顺序 多次 交换一对特定下标指向的元素。 相同长度的两个数组 source 和 target 间的 汉明距离 是元素不同的下标数量。形式上，其值等于满足 source[i] != target[i] （下标从 0 开始）的下标 i（0 &lt;= i &lt;= n-1）的数量。 在对数组 source 执行 任意 数量的交换操作后，返回 source 和 target 间的 最小汉明距离 。 示例：示例 1： 输入：source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]] 输出：1 解释：source 可以按下述方式转换： - 交换下标 0 和 1 指向的元素：source = [2,1,3,4] - 交换下标 2 和 3 指向的元素：source = [2,1,4,3] source 和 target 间的汉明距离是 1 ，二者有 1 处元素不同，在下标 3 。 示例 2： 输入：source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = [] 输出：2 解释：不能对 source 执行交换操作。 source 和 target 间的汉明距离是 2 ，二者有 2 处元素不同，在下标 1 和下标 2 。 示例 3： 输入：source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]] 输出：0 提示： n == source.length == target.length 1 &lt;= n &lt;= 105 1 &lt;= source[i], target[i] &lt;= 105 0 &lt;= allowedSwaps.length &lt;= 105 allowedSwaps[i].length == 2 0 &lt;= ai, bi &lt;= n - 1 ai != bi 分析：使用并查集记录互相联通的位置 确定每个元素的根结点，使用两个map存储source和target中对应每个根结点的元素 比较两个map中不同的元素即可 代码：class Solution { private: vector&lt;int&gt; father; public: int find(int root){ // 找根节点并且将途中所有的结点的父节点都指向根结点 int son, tmp; son = root; while(root != father[root]) root = father[root]; while(son != root) { tmp = father[son]; father[son] = root; son = tmp; } return root; } void join(int root1, int root2) // 合并 { int x, y; x = find(root1); y = find(root2); if(x != y) father[x] = y; } int minimumHammingDistance(vector&lt;int&gt;&amp; source, vector&lt;int&gt;&amp; target, vector&lt;vector&lt;int&gt;&gt;&amp; allowedSwaps) { int n = source.size(); map&lt;int, vector&lt;int&gt;&gt; m1; map&lt;int, vector&lt;int&gt;&gt; m2; int ret = 0; for(int i = 0; i &lt; n; i++){ // 初始化，每个父节点指向自己 father.push_back(i); } for(int i = 0; i &lt; allowedSwaps.size(); i++){ // 将连通的结点合并 join(allowedSwaps[i][0], allowedSwaps[i][1]); } for(int i = 0; i &lt; n; i++){ // 使用map记录两个数组中连通的结点 m1[find(i)].push_back(source[i]); m2[find(i)].push_back(target[i]); } // 统计两个数组中不同的元素数量 for(auto a = m1.begin(), b = m2.begin(); a != m1.end(); a++, b++){ map&lt;int, int&gt; ma; for(int i = 0; i &lt; a-&gt;second.size(); i++){ ma[a-&gt;second[i]]++; } for(int i = 0; i &lt; b-&gt;second.size(); i++){ if(ma[b-&gt;second[i]] &gt; 0){ ma[b-&gt;second[i]]--; } else{ ret++; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimize-hamming-distance-after-swap-operations/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1721. 交换链表中的节点]]></title>
    <url>%2F2021%2F01%2F11%2Fleetcode%201721.%20%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：给你链表的头节点 head 和一个整数 k 。 交换 链表正数第 k 个节点和倒数第 k 个节点的值后，返回链表的头节点（链表 从 1 开始索引） 示例：示例 1： 输入：head = [1,2,3,4,5], k = 2 输出：[1,4,3,2,5] 示例 2： 输入：head = [7,9,6,6,7,8,3,0,9,5], k = 5 输出：[7,9,6,6,8,7,3,0,9,5] 示例 3： 输入：head = [1], k = 1 输出：[1] 示例 4： 输入：head = [1,2], k = 1 输出：[2,1] 示例 5： 输入：head = [1,2,3], k = 2 输出：[1,2,3] 提示： 链表中节点的数目是 n 1 &lt;= k &lt;= n &lt;= 105 0 &lt;= Node.val &lt;= 100 分析：使用双指针可以找到倒数第k个结点，交换两个节点的值即可 代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapNodes(ListNode* head, int k) { ListNode* l = head; ListNode* r = head; ListNode* a = head; for(int i = 0; i &lt; k; i++){ r = r-&gt;next; } for(int i = 1; i &lt; k; i++){ a = a-&gt;next; } while(r != NULL){ l = l-&gt;next; r = r-&gt;next; } int v = l-&gt;val; l-&gt;val = a-&gt;val; a-&gt;val = v; return head; } }; 题目地址:https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1720. 解码异或后的数组]]></title>
    <url>%2F2021%2F01%2F11%2Fleetcode%201720.%20%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：未知 整数数组 arr 由 n 个非负整数组成。 经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。 给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。 请解码返回原数组 arr 。可以证明答案存在并且是唯一的。 示例：示例 1： 输入：encoded = [1,2,3], first = 1 输出：[1,0,2,1] 解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3] 示例 2： 输入：encoded = [6,2,7,3], first = 4 输出：[4,2,0,7,4] 提示： 2 &lt;= n &lt;= 104 encoded.length == n - 1 0 &lt;= encoded[i] &lt;= 105 0 &lt;= first &lt;= 105 分析：反向异或即可 代码：class Solution { public: vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encoded, int first) { vector&lt;int&gt; ret{first}; for(int i = 0; i &lt; encoded.size(); i++){ ret.push_back(ret.back() ^ encoded[i]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/decode-xored-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1713. 得到子序列的最少操作次数]]></title>
    <url>%2F2021%2F01%2F04%2Fleetcode%201713.%20%E5%BE%97%E5%88%B0%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 target ，包含若干 互不相同 的整数，以及另一个整数数组 arr ，arr 可能 包含重复元素。 每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。 请你返回 最少 操作次数，使得 target 成为 arr 的一个子序列。 一个数组的 子序列 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。 示例：示例 1： 输入：target = [5,1,3], arr = [9,4,2,3,4] 输出：2 解释：你可以添加 5 和 1 ，使得 arr 变为 [5,9,4,1,2,3,4] ，target 为 arr 的子序列。 示例 2： 输入：target = [6,4,8,1,3,2], arr = [4,7,6,2,3,8,6,1] 输出：3 提示： 1 &lt;= target.length, arr.length &lt;= 105 1 &lt;= target[i], arr[i] &lt;= 109 target 不包含任何重复元素。 分析：可以转换成最长上升子序列，比如： target：6,4,8,1,3,2 arr： 4,7,6,2,3,8,6,1 new： 1 0 5 4 2 0 3 之后使用贪心和dp的方式解决最长上升子序列 遇到比dp数组末尾大的值直接push，否则通过二分找到第一个大于当前数的值替换。 比如： 1 0 5 4 2 0 3 第一次：1 第二次：0 第三次：0 5 第四次：0 4 第五次：0 2 第六次：0 2 第七次：0 2 3 之后将需要的序列长度减去现有的子序列长度即可 代码：class Solution { public: int minOperations(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) { map&lt;int, int&gt; m; for(int i = 0; i &lt; target.size(); i++) m[target[i]] = i; vector&lt;int&gt; v; for(int i = 0; i &lt; arr.size(); i++) if(m.count(arr[i]) == 1) v.push_back(m[arr[i]]); vector&lt;int&gt; dp{v[0]}; for(int i = 1; i &lt; v.size(); i++){ if(dp.back() &lt; v[i]){ dp.push_back(v[i]); } else{ int l = 0; int r = dp.size()-1; while(l &lt; r){ int mid = (l+r)/2; if(dp[mid] &lt; v[i]){ l = mid+1; } else{ r = mid; } } dp[l] = v[i]; } } return target.size() - dp.size(); } }; 题目地址:https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1712. 将数组分成三个子数组的方案数]]></title>
    <url>%2F2021%2F01%2F04%2Fleetcode%201712.%20%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E4%B8%89%E4%B8%AA%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：我们称一个分割整数数组的方案是 好的 ，当它满足： 数组被分成三个 非空 连续子数组，从左至右分别命名为 left ， mid ， right 。 left 中元素和小于等于 mid 中元素和，mid 中元素和小于等于 right 中元素和。 给你一个 非负 整数数组 nums ，请你返回 好的 分割 nums 方案数目。由于答案可能会很大，请你将结果对 109 + 7 取余后返回。 示例：示例 1： 输入：nums = [1,1,1] 输出：1 解释：唯一一种好的分割方案是将 nums 分成 [1] [1] [1] 。 示例 2： 输入：nums = [1,2,2,2,5,0] 输出：3 解释：nums 总共有 3 种好的分割方案： [1] [2] [2,2,5,0] [1] [2,2] [2,5,0] [1,2] [2,2] [5,0] 示例 3： 输入：nums = [3,2,1] 输出：0 解释：没有好的分割方案。 提示： 3 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 104 分析：前缀和，二分搜索 遍历，先确定一个边界，之后通过二分，找到另一个边界的最大和最小位置，相减得出另一边界位置可能的方案数 代码：class Solution { public: int waysToSplit(vector&lt;int&gt;&amp; nums) { long long ret = 0; vector&lt;int&gt; v(nums.size(), 0); // 前缀和 v[0] = nums[0]; for(int i = 1; i &lt; nums.size(); i++){ v[i] = v[i-1] + nums[i]; } for(int i = 0; i &lt; nums.size(); i++){ if(v[i]*3 &gt; v[nums.size()-1]) break; // 初步判断当left为v[i]时是否可行 int l = i+1; int r = nums.size()-2; while(l &lt;= r){ // 找右边界 int m = (l+r)/2; if(v[m] - v[i] &lt;= v[nums.size()-1] - v[m]){ l = m+1; } else{ r = m-1; } } int ll = i+1; int rr = nums.size()-2; while(ll &lt;= rr){ // 找左边界 int m = (ll+rr)/2; if(v[i] &lt;= v[m] - v[i]){ rr = m-1; } else{ ll = m+1; } } ret += l - ll; ret %= 1000000007; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/ways-to-split-array-into-three-subarrays/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1711. 大餐计数]]></title>
    <url>%2F2021%2F01%2F04%2Fleetcode%201711.%20%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。 你可以搭配 任意 两道餐品做一顿大餐。 给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i​​​​​​​​​​​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。 注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。 示例：示例 1： 输入：deliciousness = [1,3,5,7,9] 输出：4 解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。 它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。 示例 2： 输入：deliciousness = [1,1,1,3,3,3,7] 输出：15 解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。 提示： 1 &lt;= deliciousness.length &lt;= 105 0 &lt;= deliciousness[i] &lt;= 220 分析：将餐品按美味程度排序，并且转换成二维数组v[i][j]，i表示第i道菜，j有两种取值：0时表示美味程度，1时表示有多少道此美味程度的菜 遍历2的幂，使用双指针找到相加为2的幂的菜，将两种菜的数量相乘即可得到有多少种组合当时，如果两个指针指向同一美味程度的菜，计算有多少种两两组合的方式即可 代码：class Solution { public: int countPairs(vector&lt;int&gt;&amp; deliciousness) { sort(deliciousness.begin(), deliciousness.end()); vector&lt;int&gt; v; vector&lt;vector&lt;int&gt;&gt; v1; v1.push_back(vector&lt;int&gt;{deliciousness[0], 1}); long long ret = 0; v.push_back(1); for(int i = 1, z = 2; i &lt;= 21; i++){ v.push_back(z); z *= 2; } for(int i = 1; i &lt; deliciousness.size(); i++){ if(deliciousness[i] == deliciousness[i-1]){ v1[v1.size()-1][1]++; } else{ v1.push_back(vector&lt;int&gt;{deliciousness[i], 1}); } } for(int i = 0; i &lt; v.size(); i++){ int l = 0; int r = v1.size()-1; while(l &lt; r){ if(v1[l][0] + v1[r][0] == v[i]){ ret += v1[l][1] * v1[r][1]; l++; } else if(v1[l][0] + v1[r][0] &lt; v[i]){ l++; } else{ r--; } } if(v1[l][0] + v1[l][0] == v[i] &amp;&amp; v1[l][1] &gt;= 2){ ret += (long long)(v1[l][1]-1) * v1[l][1] / 2; } ret %= 1000000007; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-good-meals/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1710. 卡车上的最大单元数]]></title>
    <url>%2F2021%2F01%2F04%2Fleetcode%201710.%20%E5%8D%A1%E8%BD%A6%E4%B8%8A%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8D%95%E5%85%83%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：请你将一些箱子装在 一辆卡车 上。给你一个二维数组 boxTypes ，其中 boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi] ： numberOfBoxesi 是类型 i 的箱子的数量。 numberOfUnitsPerBoxi 是类型 i 每个箱子可以装载的单元数量。 整数 truckSize 表示卡车上可以装载 箱子 的 最大数量 。只要箱子数量不超过 truckSize ，你就可以选择任意箱子装到卡车上。 返回卡车可以装载 单元 的 最大 总数。 示例：示例 1： 输入：boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4 输出：8 解释：箱子的情况如下： - 1 个第一类的箱子，里面含 3 个单元。 - 2 个第二类的箱子，每个里面含 2 个单元。 - 3 个第三类的箱子，每个里面含 1 个单元。 可以选择第一类和第二类的所有箱子，以及第三类的一个箱子。 单元总数 = (1 * 3) + (2 * 2) + (1 * 1) = 8 示例 2： 输入：boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10 输出：91 提示： 1 &lt;= boxTypes.length &lt;= 1000 1 &lt;= numberOfBoxesi, numberOfUnitsPerBoxi &lt;= 1000 1 &lt;= truckSize &lt;= 106 分析：优先装入可装单元较多的箱子 代码：bool bj(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ return a[1] &gt; b[1]; } class Solution { public: int maximumUnits(vector&lt;vector&lt;int&gt;&gt;&amp; boxTypes, int truckSize) { int ret = 0; sort(boxTypes.begin(), boxTypes.end(), bj); for(int i = 0; i &lt; boxTypes.size(); i++){ if(truckSize &gt;= boxTypes[i][0]){ ret += boxTypes[i][1] * boxTypes[i][0]; truckSize -= boxTypes[i][0]; } else{ ret += boxTypes[i][1] * truckSize; break; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-units-on-a-truck/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5640. 与数组中元素的最大异或值]]></title>
    <url>%2F2020%2F12%2F28%2Fleetcode%205640.%20%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。 第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] &lt;= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。 返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。 示例：示例 1： 输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]] 输出：[3,3,7] 解释： 1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。 2) 1 XOR 2 = 3. 3) 5 XOR 2 = 7. 示例 2： 输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]] 输出：[15,-1,5] 提示： 1 &lt;= nums.length, queries.length &lt;= 105 queries[i].length == 2 0 &lt;= nums[j], xi, mi &lt;= 109 分析：字典树，离线思维 将queries按mi从小到大排序 nums去重从小到大排序 遍历queries，每次构建比当前mi小的字典树 为了让异或后的结果最大，当前位为0时选择1的分支（如果没有1，继续选择0）；当前位为1时选择0的分支（如果没有0，继续选择1） 代码：bool bj(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ return a[1] &lt; b[1]; } class Solution { private: struct node{ node* l; node* r; node(){ l = NULL; r = NULL; } }; node* root; public: void insert(int a){ node* n = root; for(int i = 29; i &gt;= 0; i--){ int z = (1 &lt;&lt; i &amp; a) ? 1 : 0; if(z){ if(n-&gt;r == NULL) n-&gt;r = new node; n = n-&gt;r; } else{ if(n-&gt;l == NULL) n-&gt;l = new node; n = n-&gt;l; } } } int search(int a){ node* n = root; int ret = 0; for(int i = 29; i &gt;= 0; i--){ int z = (1 &lt;&lt; i &amp; a) ? 1 : 0; if(z){ if(n-&gt;l != NULL){ ret += (1 &lt;&lt; i); n = n-&gt;l; } else{ n = n-&gt;r; } } else{ if(n-&gt;r != NULL){ ret += (1 &lt;&lt; i); n = n-&gt;r; } else{ n = n-&gt;l; } } } return ret; } vector&lt;int&gt; maximizeXor(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { root = new node; for(int i = 0; i &lt; queries.size(); i++) queries[i].push_back(i); set&lt;int&gt; s(nums.begin(), nums.end()); nums.assign(s.begin(),s.end()); sort(queries.begin(), queries.end(), bj); int j = 0; vector&lt;int&gt; ret(queries.size(), -1); for(int i = 0; i &lt; queries.size(); i++){ for(; j &lt; nums.size() &amp;&amp; nums[j] &lt;= queries[i][1]; j++){ insert(nums[j]); } if(j == 0){ continue; } ret[queries[i][2]] = search(queries[i][0]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5210. 球会落何处]]></title>
    <url>%2F2020%2F12%2F28%2Fleetcode%205210.%20%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84%2F</url>
    <content type="text"><![CDATA[题目：用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。 箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。 将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。 将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。 在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 “V” 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。 返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。 示例：示例 1： 输入：grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]] 输出：[1,-1,-1,-1,-1] 解释：示例如图： b0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。 b1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。 b2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。 b3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 &quot;V&quot; 形里。 b4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 &quot;V&quot; 形里。 示例 2： 输入：grid = [[-1]] 输出：[-1] 解释：球被卡在箱子左侧边上。 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 100 grid[i][j] 为 1 或 -1 分析：使用dfs 有几种情况 左挡板 左侧为墙或右挡板，卡住 左侧为左挡板，进入下一行左边一个格子 右挡板 右侧为墙或左挡板，卡住 右侧为右挡板，进入下一行右边一个格子 代码：class Solution { public: int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y){ if(x == grid.size()) return y; if(grid[x][y] == 1){ if(y+1 == grid[0].size()) return -1; if(grid[x][y+1] == -1) return -1; int a = dfs(grid, x+1, y+1); if(a &gt; -1) return a; else return -1; } else{ if(y-1 == -1) return -1; if(grid[x][y-1] == 1) return -1; int a = dfs(grid, x+1, y-1); if(a &gt; -1) return a; else return -1; } } vector&lt;int&gt; findBall(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { vector&lt;int&gt; ret; for(int i = 0; i &lt; grid[0].size(); i++){ ret.push_back(dfs(grid, 0, i)); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/where-will-the-ball-fall/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5638. 吃苹果的最大数目]]></title>
    <url>%2F2020%2F12%2F28%2Fleetcode%205638.%20%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。 你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。 给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。 示例：示例 1： 输入：apples = [1,2,3,5,2], days = [3,2,1,4,2] 输出：7 解释：你可以吃掉 7 个苹果： - 第一天，你吃掉第一天长出来的苹果。 - 第二天，你吃掉一个第二天长出来的苹果。 - 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。 - 第四天到第七天，你吃的都是第四天长出来的苹果。 示例 2： 输入：apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2] 输出：5 解释：你可以吃掉 5 个苹果： - 第一天到第三天，你吃的都是第一天长出来的苹果。 - 第四天和第五天不吃苹果。 - 第六天和第七天，你吃的都是第六天长出来的苹果。 提示： apples.length == n days.length == n 1 &lt;= n &lt;= 2 * 104 0 &lt;= apples[i], days[i] &lt;= 2 * 104只有在 apples[i] = 0 时，days[i] = 0 才成立 分析：优先队列，最早吃快腐烂的苹果 代码：class Solution { public: int eatenApples(vector&lt;int&gt;&amp; apples, vector&lt;int&gt;&amp; days) { priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt; &gt; q; int ret = 0; for(int i = 0; i &lt; apples.size() || q.size() &gt; 0; i++){ if(i &lt; apples.size()){ if(apples[i] &gt; 0){ pair&lt;int, int&gt; a(i + days[i], apples[i]); q.push(a); } } while(q.size() &gt; 0 &amp;&amp; q.top().first &lt;= i) q.pop(); if(q.size() == 0) continue; if(q.size() &gt; 0){ ret++; } if(q.top().second &gt; 1){ pair&lt;int, int&gt; a = q.top(); a.second--; q.pop(); q.push(a); } else{ q.pop(); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5637. 判断字符串的两半是否相似]]></title>
    <url>%2F2020%2F12%2F28%2Fleetcode%205637.%20%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E5%8D%8A%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BC%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个偶数长度的字符串 s 。将其拆分成长度相同的两半，前一半为 a ，后一半为 b 。 两个字符串 相似 的前提是它们都含有相同数目的元音（’a’，’e’，’i’，’o’，’u’，’A’，’E’，’I’，’O’，’U’）。注意，s 可能同时含有大写和小写字母。 如果 a 和 b 相似，返回 true ；否则，返回 false 。 示例：示例 1： 输入：s = &quot;book&quot; 输出：true 解释：a = &quot;bo&quot; 且 b = &quot;ok&quot; 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。 示例 2： 输入：s = &quot;textbook&quot; 输出：false 解释：a = &quot;text&quot; 且 b = &quot;book&quot; 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。 注意，元音 o 在 b 中出现两次，记为 2 个。 示例 3： 输入：s = &quot;MerryChristmas&quot; 输出：false 示例 4： 输入：s = &quot;AbCdEfGh&quot; 输出：true 提示： 2 &lt;= s.length &lt;= 1000 s.length 是偶数 s 由 大写和小写 字母组成 分析：直接按照题目分成两段遍历 代码：class Solution { public: bool halvesAreAlike(string s) { vector&lt;char&gt; v{&apos;a&apos;, &apos;e&apos;, &apos;i&apos;, &apos;o&apos;, &apos;u&apos;, &apos;A&apos;, &apos;E&apos;, &apos;I&apos;, &apos;O&apos;, &apos;U&apos;}; int l = 0; int r = 0; for(int i = 0; i &lt; s.size()/2; i++){ for(int j = 0; j &lt; v.size(); j++){ if(v[j] == s[i]) l++; } } for(int i = s.size()/2; i &lt; s.size(); i++){ for(int j = 0; j &lt; v.size(); j++){ if(v[j] == s[i]) r++; } } if(l == r) return true; return false; } }; 题目地址:https://leetcode-cn.com/problems/determine-if-string-halves-are-alike/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5632. 检查边长度限制的路径是否存在]]></title>
    <url>%2F2020%2F12%2F21%2Fleetcode%205632.%20%E6%A3%80%E6%9F%A5%E8%BE%B9%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%2F</url>
    <content type="text"><![CDATA[题目：给你一个 n 个点组成的无向图边集 edgeList ，其中 edgeList[i] = [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边。请注意，两个点之间可能有 超过一条边 。 给你一个查询数组queries ，其中 queries[j] = [pj, qj, limitj] ，你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径，且这条路径上的每一条边都 严格小于 limitj 。 请你返回一个 布尔数组 answer ，其中 answer.length == queries.length ，当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false 。 示例：示例 1： 输入：n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]] 输出：[false,true] 解释：上图为给定的输入数据。注意到 0 和 1 之间有两条重边，分别为 2 和 16 。 对于第一个查询，0 和 1 之间没有小于 2 的边，所以我们返回 false 。 对于第二个查询，有一条路径（0 -&gt; 1 -&gt; 2）两条边都小于 5 ，所以这个查询我们返回 true 。 示例 2： 输入：n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]] 输出：[true,false] 解释：上图为给定数据。 提示： 2 &lt;= n &lt;= 105 1 &lt;= edgeList.length, queries.length &lt;= 105 edgeList[i].length == 3 queries[j].length == 3 0 &lt;= ui, vi, pj, qj &lt;= n - 1 ui != vi pj != qj 1 &lt;= disi, limitj &lt;= 109 两个点之间可能有 多条 边。 分析：离线思维和并查集 按距离从小到大排序edgeList和queries数组 遍历queries数组，每遍历到一个新的距离时，将小于此距离的路径添加到并查集中即可 代码：bool bj(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ return a[2] &lt; b[2]; } class Solution { private: vector&lt;int&gt; f; public: int find(int x){ if(f[x] == x) return x; else{ f[x] = find(f[x]); } return f[x]; } void merge(int a, int b){ int fa=find(a),fb=find(b); if(fa!=fb) f[fa]=fb; } vector&lt;bool&gt; distanceLimitedPathsExist(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edgeList, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { for(int i = 0; i &lt; n; i++){ f.push_back(i); } for(int i = 0; i &lt; queries.size(); i++){ queries[i].push_back(i); } vector&lt;bool&gt; ret(queries.size(), false); sort(queries.begin(), queries.end(), bj); sort(edgeList.begin(), edgeList.end(), bj); int j = 0; for(int i = 0; i &lt; queries.size(); i++){ while(j &lt; edgeList.size() &amp;&amp; edgeList[j][2] &lt; queries[i][2]){ merge(edgeList[j][0], edgeList[j][1]); j++; } if(find(queries[i][0]) == find(queries[i][1])){ ret[queries[i][3]] = true; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/checking-existence-of-edge-length-limited-paths/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5631. 跳跃游戏 VI]]></title>
    <url>%2F2020%2F12%2F21%2Fleetcode%205631.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20VI%2F</url>
    <content type="text"><![CDATA[题目：给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。 一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。 你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。 请你返回你能得到的 最大得分 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/jump-game-vi著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 示例：示例 1： 输入：nums = [1,-1,-2,4,-7,3], k = 2 输出：7 解释：你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。 示例 2： 输入：nums = [10,-5,-2,4,0,3], k = 3 输出：17 解释：你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。 示例 3： 输入：nums = [1,-5,-20,4,-1,3,-6,-3], k = 2 输出：0 提示： 1 &lt;= nums.length, k &lt;= 105 -104 &lt;= nums[i] &lt;= 104 分析：比赛时偷鸡过了 使用动态规划 dp[i] = dp[j] + nums[i] j取i-k到i-1之间的值，遇到正数就退出循环（这里应该用优先队列来维护i-k到i-1之间的值） 他人代码：https://leetcode-cn.com/problems/jump-game-vi/solution/tiao-yue-you-xi-vi-by-zerotrac2-r1kq/ 代码：class Solution { public: int maxResult(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; dp(nums.size(), INT_MIN); dp[0] = nums[0]; for(int i = 0; i &lt; nums.size(); i++){ for(int j = i-1; j &gt;= 0 &amp;&amp; j+k &gt;= i; j--){ if(nums[j] &gt;= 0){ dp[i] = dp[j] + nums[i]; break; } else{ dp[i] = max(dp[i], dp[j] + nums[i]); } } } return dp[nums.size()-1]; } }; 题目地址:https://leetcode-cn.com/problems/jump-game-vi/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5630. 删除子数组的最大得分]]></title>
    <url>%2F2020%2F12%2F21%2Fleetcode%205630.%20%E5%88%A0%E9%99%A4%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目：给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和 。 返回 只删除一个 子数组可获得的 最大得分 。 如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],…,a[r] ，那么它就是 a 的一个子数组。 示例：示例 1： 输入：nums = [4,2,4,5,6] 输出：17 解释：最优子数组是 [2,4,5,6] 示例 2： 输入：nums = [5,2,1,2,5,2,1,2,5] 输出：8 解释：最优子数组是 [5,2,1] 或 [1,2,5] 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 104 分析：滑动窗口，使用map存储窗口内数字出现的次数，记录窗口移动时的最大得分 代码：class Solution { public: int maximumUniqueSubarray(vector&lt;int&gt;&amp; nums) { int l = 0; int r = 0; map&lt;int, int&gt; m; int n = 0; int ma = 0; for(; r &lt; nums.size(); r++){ if(m[nums[r]] == 0){ m[nums[r]]++; n += nums[r]; ma = max(ma, n); } else{ m[nums[l]]--; n -= nums[l]; l++; r--; } } return ma; } }; 题目地址:https://leetcode-cn.com/problems/maximum-erasure-value/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2020%2F12%2F21%2Fleetcode%205629.%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串形式的电话号码 number 。number 由数字、空格 ‘ ‘、和破折号 ‘-‘ 组成。 请你按下述方式重新格式化电话号码。 首先，删除 所有的空格和破折号。 其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块： 2 个数字：单个含 2 个数字的块。 3 个数字：单个含 3 个数字的块。 4 个数字：两个分别含 2 个数字的块。 最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。 返回格式化后的电话号码。 示例：示例 1： 输入：number = &quot;1-23-45 6&quot; 输出：&quot;123-456&quot; 解释：数字是 &quot;123456&quot; 步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 &quot;123&quot; 。 步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 &quot;456&quot; 。 连接这些块后得到 &quot;123-456&quot; 。 示例 2： 输入：number = &quot;123 4-567&quot; 输出：&quot;123-45-67&quot; 解释：数字是 &quot;1234567&quot;. 步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 &quot;123&quot; 。 步骤 2：剩下 4 个数字，所以将它们分成两个含 2 个数字的块。这 2 块分别是 &quot;45&quot; 和 &quot;67&quot; 。 连接这些块后得到 &quot;123-45-67&quot; 。 示例 3： 输入：number = &quot;123 4-5678&quot; 输出：&quot;123-456-78&quot; 解释：数字是 &quot;12345678&quot; 。 步骤 1：第 1 个块 &quot;123&quot; 。 步骤 2：第 2 个块 &quot;456&quot; 。 步骤 3：剩下 2 个数字，将它们放入单个含 2 个数字的块。第 3 个块是 &quot;78&quot; 。 连接这些块后得到 &quot;123-456-78&quot; 。 示例 4： 输入：number = &quot;12&quot; 输出：&quot;12&quot; 示例 5： 输入：number = &quot;--17-5 229 35-39475 &quot; 输出：&quot;175-229-353-94-75&quot; 提示： 2 &lt;= number.length &lt;= 100 number 由数字和字符 ‘-‘ 及 ‘ ‘ 组成。 number 中至少含 2 个数字。 分析：两种情况 一种余0或2，直接按三个数字加一个‘-’ 一种余1，将倒数第二位和第三位互换 代码：class Solution { public: string reformatNumber(string number) { string s = &quot;&quot;; string ret = &quot;&quot;; for(int i = 0; i &lt; number.size(); i++){ if(number[i] &gt;= &apos;0&apos; &amp;&amp; number[i] &lt;= &apos;9&apos;){ s += number[i]; } } if(s.size() % 3 == 0 || s.size() % 3 == 2){ for(int i = 0, z = 0; i &lt; s.size(); i++){ if(z == 3){ ret += &quot;-&quot;; z = 0; } ret += s[i]; z++; } } if(s.size() % 3 == 1){ for(int i = 0, z = 0; i &lt; s.size(); i++){ if(z == 3){ ret += &quot;-&quot;; z = 0; } ret += s[i]; z++; } ret[ret.size() - 2] = ret[ret.size() - 3]; ret[ret.size() - 3] = &apos;-&apos;; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/reformat-phone-number/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[提取qq聊天记录]]></title>
    <url>%2F2020%2F12%2F14%2F%E6%8F%90%E5%8F%96qq%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[小米手机导出备份数据 打开设置-更多设置-备份和重置-本地备份-输入密码-新建备份-去掉两个钩-打开软件程序-勾选QQ-确定-开始备份 手机连接电脑 打开地址\MIUI\backup\AllBackup[时间] 将 QQ(com.tencent.mobileqq).bak 拷贝到电脑 使用7-zip将这个文件解压出来 打开地址\com.tencent.mobileqq\db 里面有一个qq号名字的db文件，数据就在里面 com.tencent.mobileqq\dp\slowtable_你的QQ.db 里面好像有较早的聊天记录，但是好像无法获取其中内容（无法打开） 解密密钥 记事本打开之前提取的文件中 \com.tencent.mobileqq\f\kc 里面就是密钥 提取 打开网址：https://github.com/roadwide/qqmessageoutput 下载 q.py 文件 (不知道为什么我需要改一部分代码) 或直接复制（已经改过代码） from _overlapped import NULL import hashlib import sqlite3 import time class QQoutput(): # 初始化解密key，并连接sqlite3数据库 def __init__(self, db, key): self.key = key # 解密用的密钥 self.c = sqlite3.connect(db).cursor() # 解密数据，针对不同数据用不同的方法 def fix(self, data, mode): # msgdata mode=0 # other mode=1 if (mode == 0): rowbyte = [] # 这么做是为了解决汉字的utf-8是三字节 # 添加 # 遇到data为空时（遇到图片），直接跳过这一段数据 if data is None: return 1 for i in range(0, len(data)): rowbyte.append(data[i] ^ ord(self.key[i % len(self.key)])) rowbyte = bytes(rowbyte) try: msg = rowbyte.decode(encoding=&apos;utf-8&apos;) except: msg = NULL return msg elif (mode == 1): str = &apos;&apos; try: j = 0 for i in range(0, len(data)): # 获取unicode码 unicode = ord(data[i]) # 如果大于ffff 处理emoji if (unicode &gt; 0xffff): # 分为2个10位二进制与两个密码进行异或 code = unicode ^ ((ord(self.key[i+j % len(self.key)])&lt;&lt;10) + ord(self.key[i+j+1 % len(self.key)])) str += chr(code) j = j + 1 else: str += chr(ord(data[i]) ^ ord(self.key[i+j % len(self.key)])) except: str = NULL return str # 获得聊天记录 def message(self, num, mode): # mode=1 friend # mode=2 troop num = str(num).encode(&apos;utf-8&apos;) md5num = hashlib.md5(num).hexdigest().upper() if (mode == 1): execute = &quot;select msgData,senderuin,time from mr_friend_{md5num}_New&quot;.format(md5num=md5num) elif (mode == 2): execute = &quot;select msgData,senderuin,time from mr_troop_{md5num}_New&quot;.format(md5num=md5num) else: print(&quot;error mode&quot;) exit(1) cursor = self.c.execute(execute) allmsg = [] for row in cursor: msgdata, uin, ltime = row[0], row[1], time.localtime(row[2]) sendtime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, ltime) msg = self.fix(msgdata, 0) # 添加 # 如果传入的数据无法解密，直接跳过这一段 if msg == 1: continue senderuin = self.fix(uin, 1) print([sendtime, senderuin, msg]) allmsg.append([sendtime, senderuin, msg]) return allmsg # 输出到文件 # 导出聊天记录 def output(self, num, mode): file = str(num) + &quot;.html&quot; f2 = open(file, &apos;w&apos;, encoding=&quot;utf-8&quot;) f2.write(&quot;&lt;head&gt;&lt;meta http-equiv=\&quot;Content-Type\&quot; content=\&quot;text/html; charset=utf-8\&quot; /&gt;&lt;/head&gt;&quot;) allmsg = self.message(num, mode) for msg in allmsg: try: f2.write(&quot;&lt;font color=\&quot;blue\&quot;&gt;&quot;) f2.write(msg[0]) f2.write(&quot;&lt;/font&gt;-----&lt;font color=\&quot;green\&quot;&gt;&quot;) f2.write(msg[1]) f2.write(&quot;&lt;/font&gt;&lt;/br&gt;&quot;) f2.write(msg[2]) f2.write(&quot;&lt;/br&gt;&lt;/br&gt;&quot;) except: pass # 获得所有好友昵称，备注，QQ等数据,包括临时会话的人以及一些不知道哪来的人 def getAllMyFriends(self): FriendsData = [] # uin-QQ号，remark-备注，name-昵称 execute = &quot;select uin,remark,name from Friends&quot; cursor = self.c.execute(execute) with open(&quot;FriendsData.txt&quot;, &quot;w+&quot;, encoding=&quot;utf-8&quot;) as f: for i in cursor: uin, remark, name = i[0], i[1], i[2] decode_uin = self.fix(uin, 1) decode_remark = self.fix(remark, 1) decode_name = self.fix(name, 1) print(&quot;QQ:{}\t备注:{}\t昵称:{}&quot;.format(decode_uin, decode_remark, decode_name), file=f) FriendsData.append([decode_uin, decode_remark, decode_name]) return FriendsData # config # 储存QQ聊天信息的db文件，以你的QQ号命名 dbfile = &apos;123456.db&apos; # 解密的key key = &apos;&apos; # 导出模式，1是好友，2是群 mode = 1 # 导出的聊天对象 yourfriendqq = 123456 # 初始化 q = QQoutput(dbfile, key) # 获得所有好友的个人资料 q.getAllMyFriends() # 导出聊天记录 q.output(yourfriendqq, mode) 资料：https://github.com/roadwide/qqmessageoutputhttps://www.cnblogs.com/roadwide/p/11220211.htmlhttps://github.com/ctem049/qqmessageoutputhttps://www.bilibili.com/video/BV1sv411v7Sa?from=search&amp;seid=414199683261432003https://www.bilibili.com/video/BV1Zt411N7nB?from=search&amp;seid=11369948482329514013 (软件收费)]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5245. 堆叠长方体的最大高度]]></title>
    <url>%2F2020%2F12%2F14%2Fleetcode%205245.%20%E5%A0%86%E5%8F%A0%E9%95%BF%E6%96%B9%E4%BD%93%E7%9A%84%E6%9C%80%E5%A4%A7%E9%AB%98%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目：给你 n 个长方体 cuboids ，其中第 i 个长方体的长宽高表示为 cuboids[i] = [widthi, lengthi, heighti]（下标从 0 开始）。请你从 cuboids 选出一个 子集 ，并将它们堆叠起来。 如果 widthi &lt;= widthj 且 lengthi &lt;= lengthj 且 heighti &lt;= heightj ，你就可以将长方体 i 堆叠在长方体 j 上。你可以通过旋转把长方体的长宽高重新排列，以将它放在另一个长方体上。 返回 堆叠长方体 cuboids 可以得到的 最大高度 。 示例：示例 1： 输入：cuboids = [[50,45,20],[95,37,53],[45,23,12]] 输出：190 解释： 第 1 个长方体放在底部，53x37 的一面朝下，高度为 95 。 第 0 个长方体放在中间，45x20 的一面朝下，高度为 50 。 第 2 个长方体放在上面，23x12 的一面朝下，高度为 45 。 总高度是 95 + 50 + 45 = 190 。 示例 2： 输入：cuboids = [[38,25,45],[76,35,3]] 输出：76 解释： 无法将任何长方体放在另一个上面。 选择第 1 个长方体然后旋转它，使 35x3 的一面朝下，其高度为 76 。 示例 3： 输入：cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]] 输出：102 解释： 重新排列长方体后，可以看到所有长方体的尺寸都相同。 你可以把 11x7 的一面朝下，这样它们的高度就是 17 。 堆叠长方体的最大高度为 6 * 17 = 102 。 提示： n == cuboids.length 1 &lt;= n &lt;= 100 1 &lt;= widthi, lengthi, heighti &lt;= 100 分析：使用记忆化递归 先对每一个长方体长宽高从大到小排序 递归对每一块长方体向上尝试堆叠，使用map记录以每一块长方体为结尾时可以达到的最高高度 代码：bool bj(int a, int b){ return a &gt; b; } class Solution { private: map&lt;vector&lt;int&gt;, int&gt; m; public: int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; cuboids, int z){ int ma = cuboids[z][0]; // 以z号长方体为底的最大高度 if(m.count(cuboids[z]) == 1) return m[cuboids[z]]; // 如果已经计算过直接返回 for(int i = 0; i &lt; cuboids.size(); i++){ // 尝试堆叠每一块长方体 if(i == z) continue; if(cuboids[i][0] &lt;= cuboids[z][0] &amp;&amp; cuboids[i][1] &lt;= cuboids[z][1] &amp;&amp; cuboids[i][2] &lt;= cuboids[z][2]){ int c = cuboids[z][0]; int x = cuboids[z][0]; cuboids[z][0] = 1000; // 为了防止重复使用方块 x += dfs(cuboids, i); cuboids[z][0] = c; ma = max(x, ma); } } m[cuboids[z]] = ma; // 记录以z为底的最高高度 return ma; } int maxHeight(vector&lt;vector&lt;int&gt;&gt;&amp; cuboids) { int ret = 0; // 对每一个长方体长宽高从大到小排序 for(int i = 0; i &lt; cuboids.size(); i++){ sort(cuboids[i].begin(), cuboids[i].end(), bj); } // 递归对每一块长方体向上尝试堆叠 for(int i = 0; i &lt; cuboids.size(); i++){ ret = max(ret, dfs(cuboids, i)); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-height-by-stacking-cuboids/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5627. 石子游戏 VII]]></title>
    <url>%2F2020%2F12%2F14%2Fleetcode%205627.%20%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%20VII%2F</url>
    <content type="text"><![CDATA[题目：石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，爱丽丝先开始 。 有 n 块石子排成一排。每个玩家的回合中，可以从行中 移除 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 和 相等的得分。当没有石头可移除时，得分较高者获胜。 鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 减小得分的差值 。爱丽丝的目标是最大限度地 扩大得分的差值 。 给你一个整数数组 stones ，其中 stones[i] 表示 从左边开始 的第 i 个石头的值，如果爱丽丝和鲍勃都 发挥出最佳水平 ，请返回他们 得分的差值 。 示例：示例 1： 输入：stones = [5,3,1,4,2] 输出：6 解释： - 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。 - 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。 - 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。 - 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。 - 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。 得分的差值 18 - 12 = 6 。 示例 2： 输入：stones = [7,90,5,1,100,10,10,2] 输出：122 提示： n == stones.length 2 &lt;= n &lt;= 1000 1 &lt;= stones[i] &lt;= 1000 分析：记忆化递归 先计算区间和 使用递归来模拟取石头的过程，期间使用一个n*n的二维数组存储已经计算过的值 或者使用dp：https://leetcode-cn.com/problems/stone-game-vii/solution/c-qu-jian-dp-si-lu-zheng-li-guo-cheng-by-3h0l/ 代码：class Solution { private: vector&lt;vector&lt;int&gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; m1; public: int dfs(int l, int r){ if(l == r) return 0; if(m[l][r] == 0){ // 未计算过 // 当前可以取得的值-下一个人可以领先的分值 int a = m1[l+1][r] - dfs(l+1, r); int b = m1[l][r-1] - dfs(l, r-1); m[l][r] = max(a, b); return m[l][r]; } else{ return m[l][r]; } } int stoneGameVII(vector&lt;int&gt;&amp; stones) { m = vector&lt;vector&lt;int&gt;&gt;(stones.size(), vector&lt;int&gt;(stones.size(), 0)); m1 = vector&lt;vector&lt;int&gt;&gt;(stones.size(), vector&lt;int&gt;(stones.size(), 0)); for(int i = 0; i &lt; stones.size(); i++){ int z = 0; for(int j = i; j &lt; stones.size(); j++){ z += stones[j]; m1[i][j] = z; } } return dfs(0, stones.size()-1); } }; 题目地址:https://leetcode-cn.com/problems/stone-game-vii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2020%2F12%2F14%2Fleetcode%205626.%20%E5%8D%81-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：如果一个十进制数字不含任何前导零，且每一位上的数字不是 0 就是 1 ，那么该数字就是一个 十-二进制数 。例如，101 和 1100 都是 十-二进制数，而 112 和 3001 不是。 给你一个表示十进制整数的字符串 n ，返回和为 n 的 十-二进制数 的最少数目。 示例：示例 1： 输入：n = &quot;32&quot; 输出：3 解释：10 + 11 + 11 = 32 示例 2： 输入：n = &quot;82734&quot; 输出：8 示例 3： 输入：n = &quot;27346209830709182346&quot; 输出：9 提示： 1 &lt;= n.length &lt;= 10^5 n 仅由数字组成 n 不含任何前导零并总是表示正整数 分析：找出字符串中最大数字即可 代码：class Solution { public: int minPartitions(string n) { int ret = 0; for(int i = 0; i &lt; n.size(); i++){ ret = max(n[i] - &apos;0&apos;, ret); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5625. 比赛中的配对次数]]></title>
    <url>%2F2020%2F12%2F14%2Fleetcode%205625.%20%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E9%85%8D%E5%AF%B9%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制： 如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n / 2 场比赛，且产生 n / 2 支队伍进入下一轮。 如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) / 2 场比赛，且产生 (n - 1) / 2 + 1 支队伍进入下一轮。 返回在比赛中进行的配对次数，直到决出获胜队伍为止。 示例：示例 1： 输入：n = 7 输出：6 解释：比赛详情： - 第 1 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。 - 第 2 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。 - 第 3 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。 总配对次数 = 3 + 2 + 1 = 6 示例 2： 输入：n = 14 输出：13 解释：比赛详情： - 第 1 轮：队伍数 = 14 ，配对次数 = 7 ，7 支队伍晋级。 - 第 2 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。 - 第 3 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。 - 第 4 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。 总配对次数 = 7 + 3 + 2 + 1 = 13 提示： 1 &lt;= n &lt;= 200 分析：直接按两种情况计算 还有一种方法，关注淘汰人数，每淘汰一个进行一场比赛，只剩一个人，进行n-1场 代码：class Solution { public: int numberOfMatches(int n) { int ret = 0; while(n &gt; 1){ if(n % 2 == 0){ ret += n/2; n/=2; } else{ ret += n/2; n = n/2+1; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-of-matches-in-tournament/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5619. 最小不兼容性]]></title>
    <url>%2F2020%2F12%2F07%2Fleetcode%205619.%20%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%85%BC%E5%AE%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums​​​ 和一个整数 k 。你需要将这个数组划分到 k 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。 一个子集的 不兼容性 是该子集里面最大值和最小值的差。 请你返回将数组分成 k 个子集后，各子集 不兼容性 的 和 的 最小值 ，如果无法分成分成 k 个子集，返回 -1 。 子集的定义是数组中一些数字的集合，对数字顺序没有要求。 示例：示例 1： 输入：nums = [1,2,1,4], k = 2 输出：4 解释：最优的分配是 [1,2] 和 [1,4] 。 不兼容性和为 (2-1) + (4-1) = 4 。 注意到 [1,1] 和 [2,4] 可以得到更小的和，但是第一个集合有 2 个相同的元素，所以不可行。 示例 2： 输入：nums = [6,3,8,1,3,1,2,2], k = 4 输出：6 解释：最优的子集分配为 [1,2]，[2,3]，[6,8] 和 [1,3] 。 不兼容性和为 (2-1) + (3-2) + (8-6) + (3-1) = 6 。 示例 3： 输入：nums = [5,3,3,6,3,3], k = 3 输出：-1 解释：没办法将这些数字分配到 3 个子集且满足每个子集里没有相同数字。 提示： 1 &lt;= k &lt;= nums.length &lt;= 16 nums.length 能被 k 整除。 1 &lt;= nums[i] &lt;= nums.length 分析：状态压缩dp 用一个nums.size()位的二进制数存储一个状态，为1的位表示已经使用过 dp[i] 表示状态为i的不兼容性的和的最小值 预处理所有位数为nums.size()/k的可行不兼容性存储到数组m中 当dp[i]没有计算过时 dp[i] = dp[i - j] + m[j]; j 为i的子集 当dp[i]计算过时 dp[i] = min(dp[i], dp[i - j] + m[j]); 参考了https://leetcode-cn.com/problems/minimum-incompatibility/solution/zui-xiao-bu-jian-rong-xing-by-zerotrac2-rwje/ 代码：class Solution { public: int minimumIncompatibility(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; dp(1 &lt;&lt; nums.size(), -1); dp[0] = 0; vector&lt;int&gt; m(1 &lt;&lt; nums.size(), -1); for(int sub = 0; sub &lt; (1 &lt;&lt; nums.size()); sub++){ if(__builtin_popcount(sub) == nums.size()/k){ unordered_map&lt;int, int&gt; m1; bool b = true; for(int j = 0; j &lt; nums.size(); j++){ if(sub &amp; (1 &lt;&lt; j)){ m1[nums[j]]++; if(m1[nums[j]] &gt; 1) b = false; } } if(b){ int ma = 0; int mi = 20; for(auto a = m1.begin(); a != m1.end(); a++){ if(a-&gt;first &gt; ma) ma = a-&gt;first; if(a-&gt;first &lt; mi) mi = a-&gt;first; } m[sub] = ma-mi; } } } for(int i = 1; i &lt; (1&lt;&lt;nums.size()); i++){ // 判断 i 是否有 n/k 倍数个 1 if(__builtin_popcount(i) % (nums.size() / k) == 0){ // 枚举子集 for(int j = i; j &gt; 0; j = (j-1) &amp; i){ if(m[j] &gt;= 0 &amp;&amp; dp[i - j] != -1){ if(dp[i] == -1){ dp[i] = dp[i - j] + m[j]; } else{ dp[i] = min(dp[i], dp[i - j] + m[j]); } } } } } return dp[(1&lt;&lt;nums.size())-1]; } }; 题目地址:https://leetcode-cn.com/problems/minimum-incompatibility/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5620. 连接连续二进制数字]]></title>
    <url>%2F2020%2F12%2F07%2Fleetcode%205620.%20%E8%BF%9E%E6%8E%A5%E8%BF%9E%E7%BB%AD%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n ，请你将 1 到 n 的二进制表示连接起来，并返回连接结果对应的 十进制 数字对 109 + 7 取余的结果。 示例：示例 1： 输入：n = 1 输出：1 解释：二进制的 &quot;1&quot; 对应着十进制的 1 。 示例 2： 输入：n = 3 输出：27 解释：二进制下，1，2 和 3 分别对应 &quot;1&quot; ，&quot;10&quot; 和 &quot;11&quot; 。 将它们依次连接，我们得到 &quot;11011&quot; ，对应着十进制的 27 。 示例 3： 输入：n = 12 输出：505379714 解释：连接结果为 &quot;1101110010111011110001001101010111100&quot; 。 对应的十进制数字为 118505380540 。 对 109 + 7 取余后，结果为 505379714 。 提示： 1 &lt;= n &lt;= 105 分析：可以从最大的数字开始遍历，将当前数字通过取余的方式得出每一位的值，当遍历到下一个数字时，二进制的位数不清空。 代码：class Solution { public: int concatenatedBinary(int n){ long w = 1; // 用来记录二进制第几位所表达的值 long ret = 0; for(; n &gt; 0; n--){ int i = n; while(i &gt; 0){ int a = i % 2; i /= 2; ret += a*w; ret %= 1000000007; w *= 2; w %= 1000000007; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5618. K 和数对的最大数目]]></title>
    <url>%2F2020%2F12%2F07%2Fleetcode%205618.%20K%20%E5%92%8C%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 和一个整数 k 。 每一步操作中，你需要从数组中选出和为 k 的两个整数，并将它们移出数组。 返回你可以对数组执行的最大操作数。 示例：示例 1： 输入：nums = [1,2,3,4], k = 5 输出：2 解释：开始时 nums = [1,2,3,4]： - 移出 1 和 4 ，之后 nums = [2,3] - 移出 2 和 3 ，之后 nums = [] 不再有和为 5 的数对，因此最多执行 2 次操作。 示例 2： 输入：nums = [3,1,3,4,3], k = 6 输出：1 解释：开始时 nums = [3,1,3,4,3]： - 移出前两个 3 ，之后nums = [1,4,3] 不再有和为 6 的数对，因此最多执行 1 次操作。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 109 1 &lt;= k &lt;= 109 分析：排序后使用双指针即可 代码：class Solution { public: int maxOperations(vector&lt;int&gt;&amp; nums, int k) { sort(nums.begin(), nums.end()); int ret = 0; int l = 0; int r = nums.size()-1; while(l &lt; r){ int a = nums[l]; int b = nums[r]; if(a+b == k){ ret++; l++; r--; } else if(a+b &gt; k){ r--; } else if(a+b &lt; k){ l++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/max-number-of-k-sum-pairs/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5617. 设计 Goal 解析器]]></title>
    <url>%2F2020%2F12%2F07%2Fleetcode%205617.%20%E8%AE%BE%E8%AE%A1%20Goal%20%E8%A7%A3%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目：请你设计一个可以解释字符串 command 的 Goal 解析器 。command 由 “G”、”()” 和/或 “(al)” 按某种顺序组成。Goal 解析器会将 “G” 解释为字符串 “G”、”()” 解释为字符串 “o” ，”(al)” 解释为字符串 “al” 。然后，按原顺序将经解释得到的字符串连接成一个字符串。 给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。 示例：示例 1： 输入：command = &quot;G()(al)&quot; 输出：&quot;Goal&quot; 解释：Goal 解析器解释命令的步骤如下所示： G -&gt; G () -&gt; o (al) -&gt; al 最后连接得到的结果是 &quot;Goal&quot; 示例 2： 输入：command = &quot;G()()()()(al)&quot; 输出：&quot;Gooooal&quot; 示例 3： 输入：command = &quot;(al)G(al)()()G&quot; 输出：&quot;alGalooG&quot; 提示： 1 &lt;= command.length &lt;= 100 command 由 “G”、”()” 和/或 “(al)” 按某种顺序组成 分析：直接替换即可 代码：class Solution { public: string interpret(string command) { string str = &quot;&quot;; for(int i = 0; i &lt; command.size(); i++){ if(command[i] == &apos;G&apos;) str += &apos;G&apos;; else if(command[i] == &apos;(&apos;){ if(command[i+1] == &apos;)&apos;) str += &quot;o&quot;; else str += &quot;al&quot;; } } return str; } }; 题目地址:https://leetcode-cn.com/problems/goal-parser-interpretation/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5607. 生成平衡数组的方案数]]></title>
    <url>%2F2020%2F12%2F05%2Fleetcode%205607.%20%E7%94%9F%E6%88%90%E5%B9%B3%E8%A1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 。你需要选择 恰好 一个下标（下标从 0 开始）并删除对应的元素。请注意剩下元素的下标可能会因为删除操作而发生改变。 比方说，如果 nums = [6,1,7,4,1] ，那么： 选择删除下标 1 ，剩下的数组为 nums = [6,7,4,1] 。 选择删除下标 2 ，剩下的数组为 nums = [6,1,4,1] 。 选择删除下标 4 ，剩下的数组为 nums = [6,1,7,4] 。 如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。 请你返回删除操作后，剩下的数组 nums 是 平衡数组 的 方案数 。 示例：示例 1： 输入：nums = [2,1,6,4] 输出：1 解释： 删除下标 0 ：[1,6,4] -&gt; 偶数元素下标为：1 + 4 = 5 。奇数元素下标为：6 。不平衡。 删除下标 1 ：[2,6,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：6 。平衡。 删除下标 2 ：[2,1,4] -&gt; 偶数元素下标为：2 + 4 = 6 。奇数元素下标为：1 。不平衡。 删除下标 3 ：[2,1,6] -&gt; 偶数元素下标为：2 + 6 = 8 。奇数元素下标为：1 。不平衡。 只有一种让剩余数组成为平衡数组的方案。 示例 2： 输入：nums = [1,1,1] 输出：3 解释：你可以删除任意元素，剩余数组都是平衡数组。 示例 3： 输入：nums = [1,2,3] 输出：0 解释：不管删除哪个元素，剩下数组都不是平衡数组。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 104 分析：删除一位的数相当于去掉这一位的数，然后将之后的奇数和偶数对调 代码：class Solution { public: int waysToMakeFair(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; v1; vector&lt;int&gt; v2; int a1 = 0; int a2 = 0; int ret = 0; if(nums.size() == 1) return 1; if(nums.size() == 2) return 0; for(int i = 0; i &lt; nums.size(); i++){ if(i%2 == 0) v1.push_back(a1 += nums[i]); else v2.push_back(a2 += nums[i]); } for(int i = 0; i &lt; v1.size(); i++){ int z1 = i-1 &gt;= 0 ? v1[i-1] : 0; int z2 = i-1 &gt;= 0 ? v2[i-1] : 0; z1 += v2[v2.size()-1] - (i-1 &gt;= 0 ? v2[i-1] : 0); z2 += v1[v1.size()-1] - v1[i]; if(z1 == z2) ret++; } for(int i = 0; i &lt; v2.size(); i++){ int z1 = v1[i]; int z2 = i-1 &gt;= 0 ? v2[i-1] : 0; z1 += v2[v2.size()-1] - v2[i]; z2 += v1[v1.size()-1] - v1[i]; if(z1 == z2) ret++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/ways-to-make-a-fair-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1675. 数组的最小偏移量]]></title>
    <url>%2F2020%2F11%2F30%2Fleetcode%201675.%20%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%81%8F%E7%A7%BB%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：给你一个由 n 个正整数组成的数组 nums 。 你可以对数组的任意元素执行任意次数的两类操作： 如果元素是 偶数 ，除以 2 例如，如果数组是 [1,2,3,4] ，那么你可以对最后一个元素执行此操作，使其变成 [1,2,3,2] 如果元素是 奇数 ，乘上 2 例如，如果数组是 [1,2,3,4] ，那么你可以对第一个元素执行此操作，使其变成 [2,2,3,4] 数组的 偏移量 是数组中任意两个元素之间的 最大差值 。 返回数组在执行某些操作之后可以拥有的 最小偏移量 。 示例：示例 1： 输入：nums = [1,2,3,4] 输出：1 解释：你可以将数组转换为 [1,2,3,2]，然后转换成 [2,2,3,2]，偏移量是 3 - 2 = 1 示例 2： 输入：nums = [4,1,5,20,3] 输出：3 解释：两次操作后，你可以将数组转换为 [4,2,5,5,3]，偏移量是 5 - 2 = 3 示例 3： 输入：nums = [2,10,8] 输出：3 提示： n == nums.length 2 &lt;= n &lt;= 105 1 &lt;= nums[i] &lt;= 109 分析：先将所有的奇数乘2转换成偶数 使用优先队列，每次将最大的数/2重新入队列，中途记录各种情况下最小偏移量（因为只有最大的数/2才可以缩小偏移量） 代码：class Solution { public: int minimumDeviation(vector&lt;int&gt;&amp; nums) { priority_queue&lt;int&gt; q; int mi = INT_MAX; int ret = INT_MAX; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] % 2 == 0){ q.push(nums[i]); mi = min(mi, nums[i]); } else{ q.push(nums[i]*2); mi = min(mi, nums[i]*2); } } while(q.top() % 2 == 0){ int z = q.top()/2; q.push(z); mi = min(mi, z); q.pop(); if(q.top() - mi &lt; ret) ret = q.top() - mi; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimize-deviation-in-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1674. 使数组互补的最少操作次数]]></title>
    <url>%2F2020%2F11%2F30%2Fleetcode%201674.%20%E4%BD%BF%E6%95%B0%E7%BB%84%E4%BA%92%E8%A1%A5%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个长度为 偶数 n 的整数数组 nums 和一个整数 limit 。每一次操作，你可以将 nums 中的任何整数替换为 1 到 limit 之间的另一个整数。 如果对于所有下标 i（下标从 0 开始），nums[i] + nums[n - 1 - i] 都等于同一个数，则数组 nums 是 互补的 。例如，数组 [1,2,3,4] 是互补的，因为对于所有下标 i ，nums[i] + nums[n - 1 - i] = 5 。 返回使数组 互补 的 最少 操作次数。 示例：示例 1： 输入：nums = [1,2,4,3], limit = 4 输出：1 解释：经过 1 次操作，你可以将数组 nums 变成 [1,2,2,3]（加粗元素是变更的数字）： nums[0] + nums[3] = 1 + 3 = 4. nums[1] + nums[2] = 2 + 2 = 4. nums[2] + nums[1] = 2 + 2 = 4. nums[3] + nums[0] = 3 + 1 = 4. 对于每个 i ，nums[i] + nums[n-1-i] = 4 ，所以 nums 是互补的。 示例 2： 输入：nums = [1,2,2,1], limit = 2 输出：2 解释：经过 2 次操作，你可以将数组 nums 变成 [2,2,2,2] 。你不能将任何数字变更为 3 ，因为 3 &gt; limit 。 示例 3： 输入：nums = [1,2,1,2], limit = 2 输出：0 解释：nums 已经是互补的。 提示： n == nums.length 2 &lt;= n &lt;= 105 1 &lt;= nums[i] &lt;= limit &lt;= 105 n 是偶数。 分析：每一对数要修改成另一个值有一个点和三个区间，比如： 2和4，limit为5 小于3时需要修改2次 大于9时需要修改2次 大于等于3，小于等于9时需要修改1次 为6时需要修改0次 使用差分数组，可以使用一个大小为 limit * 2+1 的差分数组存储所有的可能 差分数组 原数组为 1，1，2，2，1，1 差分数组为 1，0，1，0，-1，-1 代码：class Solution { public: int minMoves(vector&lt;int&gt;&amp; nums, int limit) { vector&lt;int&gt; v(limit * 2+2, 0); vector&lt;int&gt; v1(limit * 2+2, 0); // 建立差分数组 for(int i = 0; i &lt; nums.size()/2; i++){ int a = nums[i]; int b = nums[nums.size()-1-i]; v1[a+b] += 1; if(a &gt; b) swap(a, b); v[0] += 2; v[a+1] -= 1; v[b+limit+1] += 1; } // 将差分数组还原成普通数组 for(int i = 1; i &lt; v.size(); i++) v[i] = v[i-1] + v[i]; int ret = nums.size(); // 遍历，找到最小的操作次数 for(int i = 2; i &lt; v.size()-1; i++) ret = min(ret, v[i]-v1[i]); return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-moves-to-make-array-complementary/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1673. 找出最具竞争力的子序列]]></title>
    <url>%2F2020%2F11%2F30%2Fleetcode%201673.%20%E6%89%BE%E5%87%BA%E6%9C%80%E5%85%B7%E7%AB%9E%E4%BA%89%E5%8A%9B%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。 数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。 在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。 示例：示例 1： 输入：nums = [3,5,2,6], k = 2 输出：[2,6] 解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。 示例 2： 输入：nums = [2,4,3,3,5,4,9,6], k = 4 输出：[2,3,3,4] 提示： 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 109 1 &lt;= k &lt;= nums.length 分析：维护一个单调栈，从左到右遍历数组。 当前元素小于栈顶元素时，只要剩下的数组长度加上栈中长度大于k，就循环出栈，直到栈顶元素小于当前元素再入栈 当前元素大于栈顶元素时，直接入栈即可 代码：class Solution { public: vector&lt;int&gt; mostCompetitive(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; v; for(int i = 0; i &lt; nums.size(); i++){ while(v.size() &gt; 0 &amp;&amp; v[v.size()-1] &gt; nums[i] &amp;&amp; k &lt; nums.size()-i){ v.pop_back(); k++; } if(k &gt; 0){ v.push_back(nums[i]); k--; } } return v; } }; 题目地址:https://leetcode-cn.com/problems/find-the-most-competitive-subsequence/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1672. 最富有客户的资产总量]]></title>
    <url>%2F2020%2F11%2F30%2Fleetcode%201672.%20%E6%9C%80%E5%AF%8C%E6%9C%89%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E4%BA%A7%E6%80%BB%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第 i​​​​​​​​​​​​ 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。 客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。 示例：示例 1： 输入：accounts = [[1,2,3],[3,2,1]] 输出：6 解释： 第 1 位客户的资产总量 = 1 + 2 + 3 = 6 第 2 位客户的资产总量 = 3 + 2 + 1 = 6 两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。 示例 2： 输入：accounts = [[1,5],[7,3],[3,5]] 输出：10 解释： 第 1 位客户的资产总量 = 6 第 2 位客户的资产总量 = 10 第 3 位客户的资产总量 = 8 第 2 位客户是最富有的，资产总量是 10 示例 3： 输入：accounts = [[2,8,7],[7,1,3],[1,9,5]] 输出：17 提示： m == accounts.length n == accounts[i].length 1 &lt;= m, n &lt;= 50 1 &lt;= accounts[i][j] &lt;= 100 分析：直接遍历将同个客户的资产相加，比较即可 代码：class Solution { public: int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) { int ret = 0; for(int i = 0; i &lt; accounts.size(); i++){ int z = 0; for(int j = 0; j &lt; accounts[0].size(); j++){ z += accounts[i][j]; } ret = max(ret, z); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/richest-customer-wealth/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5608. 完成所有任务的最少初始能量]]></title>
    <url>%2F2020%2F11%2F23%2Fleetcode%205608.%20%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%9D%E5%A7%8B%E8%83%BD%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：给你一个任务数组 tasks ，其中 tasks[i] = [actuali, minimumi] ： actuali 是完成第 i 个任务 需要耗费 的实际能量。 minimumi 是开始第 i 个任务前需要达到的最低能量。 比方说，如果任务为 [10, 12] 且你当前的能量为 11 ，那么你不能开始这个任务。如果你当前的能量为 13 ，你可以完成这个任务，且完成它后剩余能量为 3 。 你可以按照 任意顺序 完成任务。 请你返回完成所有任务的 最少 初始能量。 示例：示例 1： 输入：tasks = [[1,2],[2,4],[4,8]] 输出：8 解释： 一开始有 8 能量，我们按照如下顺序完成任务： - 完成第 3 个任务，剩余能量为 8 - 4 = 4 。 - 完成第 2 个任务，剩余能量为 4 - 2 = 2 。 - 完成第 1 个任务，剩余能量为 2 - 1 = 1 。 注意到尽管我们有能量剩余，但是如果一开始只有 7 能量是不能完成所有任务的，因为我们无法开始第 3 个任务。 示例 2： 输入：tasks = [[1,3],[2,4],[10,11],[10,12],[8,9]] 输出：32 解释： 一开始有 32 能量，我们按照如下顺序完成任务： - 完成第 1 个任务，剩余能量为 32 - 1 = 31 。 - 完成第 2 个任务，剩余能量为 31 - 2 = 29 。 - 完成第 3 个任务，剩余能量为 29 - 10 = 19 。 - 完成第 4 个任务，剩余能量为 19 - 10 = 9 。 - 完成第 5 个任务，剩余能量为 9 - 8 = 1 。 示例 3： 输入：tasks = [[1,7],[2,8],[3,9],[4,10],[5,11],[6,12]] 输出：27 解释： 一开始有 27 能量，我们按照如下顺序完成任务： - 完成第 5 个任务，剩余能量为 27 - 5 = 22 。 - 完成第 2 个任务，剩余能量为 22 - 2 = 20 。 - 完成第 3 个任务，剩余能量为 20 - 3 = 17 。 - 完成第 1 个任务，剩余能量为 17 - 1 = 16 。 - 完成第 4 个任务，剩余能量为 16 - 4 = 12 。 - 完成第 6 个任务，剩余能量为 12 - 6 = 6 。 提示： 1 &lt;= tasks.length &lt;= 105 1 &lt;= actual​i &lt;= minimumi &lt;= 104 分析：使用二分找到可以合适的能量，重点在于如何判断这些能量是否够用 按minimum - actual从大到小排序（做题时全靠直觉。。。），再按顺序完成任务即可 理由是 minimum - actual 越大，剩下的能量就越多，相反 minimum - actual 越小，剩下的能量就越少，所以将 minimum - actual 小的放到最后完成 代码：bool bj(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ return a[1] - a[0] &gt; b[1] - b[0]; } class Solution { public: int minimumEffort(vector&lt;vector&lt;int&gt;&gt;&amp; tasks) { int l = 0; int r = 1000000000; sort(tasks.begin(), tasks.end(), bj); while(l &lt; r){ int m = (l+r)/2; int z = m; for(int i = 0; i &lt; tasks.size(); i++){ if(z &gt;= tasks[i][1]){ z -= tasks[i][0]; } else{ l = m+1; break; } } if(l != m+1) r = m; } return r; } }; 题目地址:https://leetcode-cn.com/problems/minimum-initial-energy-to-finish-tasks/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5606. 具有给定数值的最小字符串]]></title>
    <url>%2F2020%2F11%2F23%2Fleetcode%205606.%20%E5%85%B7%E6%9C%89%E7%BB%99%E5%AE%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：小写字符 的 数值 是它在字母表中的位置（从 1 开始），因此 a 的数值为 1 ，b 的数值为 2 ，c 的数值为 3 ，以此类推。 字符串由若干小写字符组成，字符串的数值 为各字符的数值之和。例如，字符串 “abe” 的数值等于 1 + 2 + 5 = 8 。 给你两个整数 n 和 k 。返回 长度 等于 n 且 数值 等于 k 的 字典序最小 的字符串。 注意，如果字符串 x 在字典排序中位于 y 之前，就认为 x 字典序比 y 小，有以下两种情况： x 是 y 的一个前缀； 如果 i 是 x[i] != y[i] 的第一个位置，且 x[i] 在字母表中的位置比 y[i] 靠前。 示例：示例 1： 输入：n = 3, k = 27 输出：&quot;aay&quot; 解释：字符串的数值为 1 + 1 + 25 = 27，它是数值满足要求且长度等于 3 字典序最小的字符串。 示例 2： 输入：n = 5, k = 73 输出：&quot;aaszz&quot; 提示： 1 &lt;= n &lt;= 105 n &lt;= k &lt;= 26 * n 分析：只要在前面尽可能的多的放a，字典序就会小，所以只要保证之后的空位可以放下数值够到k的字符即可 代码：class Solution { public: string getSmallestString(int n, int k) { string s = &quot;&quot;; for(int i = 0; i &lt; n; i++){ if((n-i-1)*26 &gt;= k-1){ s += &apos;a&apos;; k--; } else{ s += &apos;a&apos; + (k - (n-i-1) * 26 - 1); k -= k - (n-i-1) * 26; } } return s; } }; 题目地址:https://leetcode-cn.com/problems/smallest-string-with-a-given-numeric-value/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5605. 检查两个字符串数组是否相等]]></title>
    <url>%2F2020%2F11%2F23%2Fleetcode%205605.%20%E6%A3%80%E6%9F%A5%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%2F</url>
    <content type="text"><![CDATA[题目：给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。 数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。 示例：示例 1： 输入：word1 = [&quot;ab&quot;, &quot;c&quot;], word2 = [&quot;a&quot;, &quot;bc&quot;] 输出：true 解释： word1 表示的字符串为 &quot;ab&quot; + &quot;c&quot; -&gt; &quot;abc&quot; word2 表示的字符串为 &quot;a&quot; + &quot;bc&quot; -&gt; &quot;abc&quot; 两个字符串相同，返回 true 示例 2： 输入：word1 = [&quot;a&quot;, &quot;cb&quot;], word2 = [&quot;ab&quot;, &quot;c&quot;] 输出：false 示例 3： 输入：word1 = [&quot;abc&quot;, &quot;d&quot;, &quot;defg&quot;], word2 = [&quot;abcddefg&quot;] 输出：true 提示： 1 &lt;= word1.length, word2.length &lt;= 103 1 &lt;= word1[i].length, word2[i].length &lt;= 103 1 &lt;= sum(word1[i].length), sum(word2[i].length) &lt;= 103 word1[i] 和 word2[i] 由小写字母组成 分析：直接将这两组字符串分别组成两个字符串，比较即可 代码：class Solution { public: bool arrayStringsAreEqual(vector&lt;string&gt;&amp; word1, vector&lt;string&gt;&amp; word2) { string str1 = &quot;&quot;; string str2 = &quot;&quot;; for(int i = 0; i &lt; word1.size(); i++){ str1 += word1[i]; } for(int i = 0; i &lt; word2.size(); i++){ str2 += word2[i]; } return str1 == str2; } }; 题目地址:https://leetcode-cn.com/problems/check-if-two-string-arrays-are-equivalent/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5604. 最大化网格幸福感]]></title>
    <url>%2F2020%2F11%2F16%2Fleetcode%205604.%20%E6%9C%80%E5%A4%A7%E5%8C%96%E7%BD%91%E6%A0%BC%E5%B9%B8%E7%A6%8F%E6%84%9F%2F</url>
    <content type="text"><![CDATA[题目：给你四个整数 m、n、introvertsCount 和 extrovertsCount 。有一个 m x n 网格，和两种类型的人：内向的人和外向的人。总共有 introvertsCount 个内向的人和 extrovertsCount 个外向的人。 请你决定网格中应当居住多少人，并为每个人分配一个网格单元。 注意，不必 让所有人都生活在网格中。 每个人的 幸福感 计算如下： 内向的人 开始 时有 120 个幸福感，但每存在一个邻居（内向的或外向的）他都会 失去 30 个幸福感。 外向的人 开始 时有 40 个幸福感，每存在一个邻居（内向的或外向的）他都会 得到 20 个幸福感。 邻居是指居住在一个人所在单元的上、下、左、右四个直接相邻的单元中的其他人。 网格幸福感 是每个人幸福感的 总和 。 返回 最大可能的网格幸福感 。 示例：示例 1： 输入：m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2 输出：240 解释：假设网格坐标 (row, column) 从 1 开始编号。 将内向的人放置在单元 (1,1) ，将外向的人放置在单元 (1,3) 和 (2,3) 。 - 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (0 * 30)（0 位邻居）= 120 - 位于 (1,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60 - 位于 (2,3) 的外向的人的幸福感：40（初始幸福感）+ (1 * 20)（1 位邻居）= 60 网格幸福感为：120 + 60 + 60 = 240 上图展示该示例对应网格中每个人的幸福感。内向的人在浅绿色单元中，而外向的人在浅紫色单元中。 示例 2： 输入：m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1 输出：260 解释：将内向的人放置在单元 (1,1) 和 (3,1) ，将外向的人放置在单元 (2,1) 。 - 位于 (1,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90 - 位于 (2,1) 的外向的人的幸福感：40（初始幸福感）+ (2 * 20)（2 位邻居）= 80 - 位于 (3,1) 的内向的人的幸福感：120（初始幸福感）- (1 * 30)（1 位邻居）= 90 网格幸福感为 90 + 80 + 90 = 260 示例 3： 输入：m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0 输出：240 提示： 1 &lt;= m, n &lt;= 5 0 &lt;= introvertsCount, extrovertsCount &lt;= min(m * n, 6) 分析：使用状压dp 可以用3进制的数来表示每行中每一位的状态，0没人，1内向的人，2外向的人 dp[a][b][c][d], 表示第a行，还有b个内向的人，还有c个内向的人，第a行的状态为d 两行之间的幸福感变化可以先预处理 代码：class Solution { int base[6]; // 用来存储3的0-5次方的结果 public: int get(int a, int b){ // 获取三进制情况下第b位的值 a = a % base[b+1]; return a / base[b]; } int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) { base[0] = 1; for(int i = 1; i &lt;= 5; i++) base[i] = base[i-1]*3; // 第一维：行数；第二维：还剩的内向的人数；第三维：还剩的外向的人数；第四维：行的压缩状态 int dp[m+2][introvertsCount+1][extrovertsCount+1][base[n]]; memset(dp, -1, sizeof(dp)); dp[0][0][0][0] = 0; // 先预处理 int mov[base[n]][base[n]]; // 幸福感变化 int movin[base[n]][base[n]]; // 内向的人数变化 int movex[base[n]][base[n]]; // 外向的人数变化 // 预处理 for(int i = 0; i &lt; base[n]; i++){ for(int j = 0; j &lt; base[n]; j++){ mov[i][j] = movin[i][j] = movex[i][j] = 0; for(int k = 0; k &lt; n; k++){ if(get(j, k) == 0) continue; if(get(i, k) == 1) mov[i][j] -= 30; if(get(i, k) == 2) mov[i][j] += 20; if(get(j, k) == 1){ movin[i][j]++; mov[i][j] += 120; if(get(i, k) &gt; 0) mov[i][j] -= 30; if(k &gt; 0 &amp;&amp; get(j, k-1) &gt; 0) mov[i][j] -= 30; if(k &lt; n-1 &amp;&amp; get(j, k+1) &gt; 0) mov[i][j] -= 30; } if(get(j, k) == 2){ movex[i][j]++; mov[i][j] += 40; if(get(i, k) &gt; 0) mov[i][j] += 20; if(k &gt; 0 &amp;&amp; get(j, k-1) &gt; 0) mov[i][j] += 20; if(k &lt; n-1 &amp;&amp; get(j, k+1) &gt; 0) mov[i][j] += 20; } } } } // dp for(int i = 1; i &lt;= m; i++){ for(int in = 0; in &lt;= introvertsCount; in++){ for(int ex = 0; ex &lt;= extrovertsCount; ex++){ for(int o = 0; o &lt; base[n]; o++){ // 如果原始状态不存在，就不需要继续了 if(dp[i-1][in][ex][o] == -1) continue; // 遍历所有状态 for(int n1 = 0; n1 &lt; base[n]; n1++){ int deltain = movin[o][n1]; int deltaex = movex[o][n1]; int delta = mov[o][n1]; // 判断这个状态是否超出限制人数 if(in + deltain &lt;= introvertsCount &amp;&amp; ex + deltaex &lt;= extrovertsCount){ // 状态转移 dp[i][in+deltain][ex+deltaex][n1] = max(dp[i][in+deltain][ex+deltaex][n1], dp[i-1][in][ex][o] + delta); } } } } } } int ans = 0; // 结果从所有遍历到最后一行的答案中找 for(int i = 0; i &lt; base[n]; i++){ for(int in = 0; in &lt;= introvertsCount; in++){ for(int ex = 0; ex &lt;= extrovertsCount; ex++){ ans = max(ans, dp[m][in][ex][i]); } } } return ans; } }; 题目地址:https://leetcode-cn.com/problems/maximize-grid-happiness/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5602. 将 x 减到 0 的最小操作数]]></title>
    <url>%2F2020%2F11%2F16%2Fleetcode%205602.%20%E5%B0%86%20x%20%E5%87%8F%E5%88%B0%200%20%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。 如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。 示例：示例 1： 输入：nums = [1,1,4,2,3], x = 5 输出：2 解释：最佳解决方案是移除后两个元素，将 x 减到 0 。 示例 2： 输入：nums = [5,6,7,8,9], x = 4 输出：-1 示例 3： 输入：nums = [3,2,20,1,1,3], x = 10 输出：5 解释：最佳解决方案是移除后三个元素和前两个元素（总共 5 次操作），将 x 减到 0 。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 104 1 &lt;= x &lt;= 109 分析：因为只能取最左边或最右边，所以我们可以一开始从左边全部取完，这时l == nums.size()，r == nums.size()，然后有几种可能 当前值大于x，l–，更新值 当前值小于x，r++，更新值 当前值等于x，更新最小操作数，l–，更新值 代码：class Solution { public: int minOperations(vector&lt;int&gt;&amp; nums, int x) { int l = nums.size(); int r = nums.size(); int h = 0; int m = INT_MAX; int z = nums.size(); for(int i = 0; i &lt; nums.size(); i++){ h += nums[i]; } if(h &lt; x) return -1; while(1){ if(h &gt; x){ l--; if(l &lt; 0) break; h -= nums[l]; z--; } if(h &lt; x){ r--; if(r &lt; 0) break; h += nums[r]; z++; } if(h == x){ l--; m = min(m, z); if(l &lt; 0) break; z--; h -= nums[l]; } } if(m == INT_MAX) return -1; return m; } }; 题目地址:https://leetcode-cn.com/problems/minimum-operations-to-reduce-x-to-zero/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5603. 确定两个字符串是否接近]]></title>
    <url>%2F2020%2F11%2F16%2Fleetcode%205603.%20%E7%A1%AE%E5%AE%9A%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E6%8E%A5%E8%BF%91%2F</url>
    <content type="text"><![CDATA[题目：如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ： 操作 1：交换任意两个 现有 字符。 例如，abcde -&gt; aecdb 操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。 例如，aacabb -&gt; bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ） 你可以根据需要对任意一个字符串多次使用这两种操作。 给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。 示例：示例 1： 输入：word1 = &quot;abc&quot;, word2 = &quot;bca&quot; 输出：true 解释：2 次操作从 word1 获得 word2 。 执行操作 1：&quot;abc&quot; -&gt; &quot;acb&quot; 执行操作 1：&quot;acb&quot; -&gt; &quot;bca&quot; 示例 2： 输入：word1 = &quot;a&quot;, word2 = &quot;aa&quot; 输出：false 解释：不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。 示例 3： 输入：word1 = &quot;cabbba&quot;, word2 = &quot;abbccc&quot; 输出：true 解释：3 次操作从 word1 获得 word2 。 执行操作 1：&quot;cabbba&quot; -&gt; &quot;caabbb&quot; 执行操作 2：&quot;caabbb&quot; -&gt; &quot;baaccc&quot; 执行操作 2：&quot;baaccc&quot; -&gt; &quot;abbccc&quot; 示例 4： 输入：word1 = &quot;cabbba&quot;, word2 = &quot;aabbss&quot; 输出：false 解释：不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。 提示： 1 &lt;= word1.length, word2.length &lt;= 105 word1 和 word2 仅包含小写英文字母 分析：因为不限交换次数，所以顺序无关紧要，那么需要注意的就两点 两个字符串中出现的字符是否相同 不考虑具体字符的情况下，各个字符出现的个数是否可以对应上 代码：class Solution { public: bool closeStrings(string word1, string word2) { if(word1.size() != word2.size()) return false; vector&lt;int&gt; w1(26, 0); vector&lt;int&gt; w2(26, 0); for(int i = 0; i &lt; word1.size(); i++){ w1[word1[i] - &apos;a&apos;]++; w2[word2[i] - &apos;a&apos;]++; } for(int i = 0; i &lt; 26; i++){ if((w1[i] &gt; 0 &amp;&amp; w2[i] == 0) || (w1[i] == 0 &amp;&amp; w2[i] &gt; 0)) return false; } for(int i = 0; i &lt; 26; i++){ bool b = true; for(int j = 0; j &lt; 26; j++){ if(w1[i] == w2[j]){ w2[j] = 0; b = false; break; } } if(b) return false; } return true; } }; 题目地址:https://leetcode-cn.com/problems/determine-if-two-strings-are-close/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5601. 设计有序流]]></title>
    <url>%2F2020%2F11%2F16%2Fleetcode%205601.%20%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81%2F</url>
    <content type="text"><![CDATA[题目：有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。 设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。 实现 OrderedStream 类： OrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。 String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后： 如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个 id + 1 。 否则，返回一个空列表。 示例：输入 [&quot;OrderedStream&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;, &quot;insert&quot;] [[5], [3, &quot;ccccc&quot;], [1, &quot;aaaaa&quot;], [2, &quot;bbbbb&quot;], [5, &quot;eeeee&quot;], [4, &quot;ddddd&quot;]] 输出 [null, [], [&quot;aaaaa&quot;], [&quot;bbbbb&quot;, &quot;ccccc&quot;], [], [&quot;ddddd&quot;, &quot;eeeee&quot;]] 解释 OrderedStream os= new OrderedStream(5); os.insert(3, &quot;ccccc&quot;); // 插入 (3, &quot;ccccc&quot;)，返回 [] os.insert(1, &quot;aaaaa&quot;); // 插入 (1, &quot;aaaaa&quot;)，返回 [&quot;aaaaa&quot;] os.insert(2, &quot;bbbbb&quot;); // 插入 (2, &quot;bbbbb&quot;)，返回 [&quot;bbbbb&quot;, &quot;ccccc&quot;] os.insert(5, &quot;eeeee&quot;); // 插入 (5, &quot;eeeee&quot;)，返回 [] os.insert(4, &quot;ddddd&quot;); // 插入 (4, &quot;ddddd&quot;)，返回 [&quot;ddddd&quot;, &quot;eeeee&quot;] 提示： 1 &lt;= n &lt;= 1000 1 &lt;= id &lt;= n value.length == 5 value 仅由小写字母组成 每次调用 insert 都会使用一个唯一的 id 恰好调用 n 次 insert 分析：用一个map存储接收到的值，用一个int记录已经输出到第几个值。每次输入时循环输出连续的值 代码：class OrderedStream { map&lt;int, string&gt; m; int i; int N; public: OrderedStream(int n) { i = 1; N = n; } vector&lt;string&gt; insert(int id, string value) { m[id] = value; vector&lt;string&gt; ret; while(i &lt;= N){ if(m.count(i) != 0){ ret.push_back(m[i]); i++; } else break; } return ret; } }; /** * Your OrderedStream object will be instantiated and called as such: * OrderedStream* obj = new OrderedStream(n); * vector&lt;string&gt; param_1 = obj-&gt;insert(id,value); */ 题目地址:https://leetcode-cn.com/problems/design-an-ordered-stream/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1649. 通过指令创建有序数组]]></title>
    <url>%2F2020%2F11%2F09%2Fleetcode%201649.%20%E9%80%9A%E8%BF%87%E6%8C%87%E4%BB%A4%E5%88%9B%E5%BB%BA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 instructions ，你需要根据 instructions 中的元素创建一个有序数组。一开始你有一个空的数组 nums ，你需要 从左到右 遍历 instructions 中的元素，将它们依次插入 nums 数组中。每一次插入操作的 代价 是以下两者的 较小值 ： nums 中 严格小于 instructions[i] 的数字数目。 nums 中 严格大于 instructions[i] 的数字数目。 比方说，如果要将 3 插入到 nums = [1,2,3,5] ，那么插入操作的 代价 为 min(2, 1) (元素 1 和 2 小于 3 ，元素 5 大于 3 ），插入后 nums 变成 [1,2,3,3,5] 。 请你返回将 instructions 中所有元素依次插入 nums 后的 总最小代价 。由于答案会很大，请将它对 109 + 7 取余 后返回。 示例：示例 1： 输入：instructions = [1,5,6,2] 输出：1 解释：一开始 nums = [] 。 插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。 插入 5 ，代价为 min(1, 0) = 0 ，现在 nums = [1,5] 。 插入 6 ，代价为 min(2, 0) = 0 ，现在 nums = [1,5,6] 。 插入 2 ，代价为 min(1, 2) = 1 ，现在 nums = [1,2,5,6] 。 总代价为 0 + 0 + 0 + 1 = 1 。 示例 2: 输入：instructions = [1,2,3,6,5,4] 输出：3 解释：一开始 nums = [] 。 插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。 插入 2 ，代价为 min(1, 0) = 0 ，现在 nums = [1,2] 。 插入 3 ，代价为 min(2, 0) = 0 ，现在 nums = [1,2,3] 。 插入 6 ，代价为 min(3, 0) = 0 ，现在 nums = [1,2,3,6] 。 插入 5 ，代价为 min(3, 1) = 1 ，现在 nums = [1,2,3,5,6] 。 插入 4 ，代价为 min(3, 2) = 2 ，现在 nums = [1,2,3,4,5,6] 。 总代价为 0 + 0 + 0 + 0 + 1 + 2 = 3 。 示例 3： 输入：instructions = [1,3,3,3,2,4,2,1,2] 输出：4 解释：一开始 nums = [] 。 插入 1 ，代价为 min(0, 0) = 0 ，现在 nums = [1] 。 插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3] 。 插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3] 。 插入 3 ，代价为 min(1, 0) = 0 ，现在 nums = [1,3,3,3] 。 插入 2 ，代价为 min(1, 3) = 1 ，现在 nums = [1,2,3,3,3] 。 插入 4 ，代价为 min(5, 0) = 0 ，现在 nums = [1,2,3,3,3,4] 。 ​​​​​插入 2 ，代价为 min(1, 4) = 1 ，现在 nums = [1,2,2,3,3,3,4] 。 插入 1 ，代价为 min(0, 6) = 0 ，现在 nums = [1,1,2,2,3,3,3,4] 。 插入 2 ，代价为 min(2, 4) = 2 ，现在 nums = [1,1,2,2,2,3,3,3,4] 。 总代价为 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4 。 提示： 1 &lt;= instructions.length &lt;= 105 1 &lt;= instructions[i] &lt;= 105 分析：使用树状数组 nums 中 严格小于 instructions[i] 的数字数目，就是当前数的前缀和减去当前数的个数 nums 中 严格大于 instructions[i] 的数字数目，就是所有的数减去当前数的前缀和 代码：public: int lowbit(int x){ return x&amp;-x; } void update(int a, int value){ for(; a &lt; 100001; a += lowbit(a)) tree[a] += value; } int ask(int a){ int ans = 0; for(; a; a -= lowbit(a)) ans += tree[a]; return ans; } int createSortedArray(vector&lt;int&gt;&amp; instructions) { tree = vector&lt;int&gt;(100001, 0); long ans = 0; for(int i = 0; i &lt; instructions.size(); i++){ int l = ask(instructions[i]) - m[instructions[i]]; int r = sum - l - m[instructions[i]]; update(instructions[i], 1); ans += min(l, r); ans = ans % 1000000007; sum += 1; m[instructions[i]]++; } return ans; } }; 题目地址:https://leetcode-cn.com/problems/create-sorted-array-through-instructions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5563. 销售价值减少的颜色球]]></title>
    <url>%2F2020%2F11%2F09%2Fleetcode%205563.%20%E9%94%80%E5%94%AE%E4%BB%B7%E5%80%BC%E5%87%8F%E5%B0%91%E7%9A%84%E9%A2%9C%E8%89%B2%E7%90%83%2F</url>
    <content type="text"><![CDATA[题目：你有一些球的库存 inventory ，里面包含着不同颜色的球。一个顾客想要 任意颜色 总数为 orders 的球。 这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的 同色球 的数目。比方说还剩下 6 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 6 。这笔交易以后，只剩下 5 个黄球了，所以下一个黄球的价值为 5 （也就是球的价值随着顾客购买同色球是递减的） 给你整数数组 inventory ，其中 inventory[i] 表示第 i 种颜色球一开始的数目。同时给你整数 orders ，表示顾客总共想买的球数目。你可以按照 任意顺序 卖球。 请你返回卖了 orders 个球以后 最大 总价值之和。由于答案可能会很大，请你返回答案对 109 + 7 取余数 的结果。 示例：示例 1： 输入：inventory = [2,5], orders = 4 输出：14 解释：卖 1 个第一种颜色的球（价值为 2 )，卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。 最大总和为 2 + 5 + 4 + 3 = 14 。 示例 2： 输入：inventory = [3,5], orders = 6 输出：19 解释：卖 2 个第一种颜色的球（价值为 3 + 2），卖 4 个第二种颜色的球（价值为 5 + 4 + 3 + 2）。 最大总和为 3 + 2 + 5 + 4 + 3 + 2 = 19 。 示例 3： 输入：inventory = [2,8,4,10,6], orders = 20 输出：110 示例 4： 输入：inventory = [1000000000], orders = 1000000000 输出：21 解释：卖 1000000000 次第一种颜色的球，总价值为 500000000500000000 。 500000000500000000 对 109 + 7 取余为 21 。 提示： 1 &lt;= inventory.length &lt;= 105 1 &lt;= inventory[i] &lt;= 109 1 &lt;= orders &lt;= min(sum(inventory[i]), 109) 分析：先按每种颜色球的个数排序 每次只考虑最多的球和第二多的球之间相差的个数 有两种情况 如果最多的球和第二多的球之间相差的个数小于要取的个数，那么，返回值加上这些多的球所表示的值 如果最多的球和第二多的球之间相差的个数大于要取的个数，计算取完后还剩的球的个数（平均取），然后根据取完后的值和取之前的值计算出取出的球所表示的值 代码：bool bj(int a, int b){ return a &gt; b; } class Solution { public: long long js(int a, int b){ return (long long)(a + b) * (a-b+1) / 2; } int maxProfit(vector&lt;int&gt;&amp; inventory, int orders) { inventory.push_back(0); sort(inventory.begin(), inventory.end(), bj); long long ret = 0; int ys = 1; // 最多的球的有多少种颜色 while(orders &gt; 0){ for(int i = ys; i &lt; inventory.size(); i++){ ys = i; if(inventory[i] != inventory[i-1]) break; } if((inventory[ys-1] - inventory[ys]) * ys &lt;= orders){ orders -= (inventory[ys-1] - inventory[ys]) * ys; ret += js(inventory[ys-1], inventory[ys]+1) * ys; ret %= 1000000007; for(int i = ys-1; i &gt;= 0; i--){ inventory[i] = inventory[i+1]; } } else{ long long q = (long long)inventory[ys-1] * ys - orders; // 还留下的球的数量 orders = 0; int d = q % ys; // 球给出去后比别的颜色球多一个的数量 int s = q / ys; // 球给出去后每个颜色还剩的数量 for(int i = 0; i &lt; ys; i++){ if(d &gt; 0){ ret += js(inventory[i], s+2); d--; } else{ ret += js(inventory[i], s+1); } ret %= 1000000007; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/sell-diminishing-valued-colored-balls/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5562. 字符频次唯一的最小删除次数]]></title>
    <url>%2F2020%2F11%2F09%2Fleetcode%205562.%20%E5%AD%97%E7%AC%A6%E9%A2%91%E6%AC%A1%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：如果字符串 s 中 不存在 两个不同字符 频次 相同的情况，就称 s 是 优质字符串 。 给你一个字符串 s，返回使 s 成为 优质字符串 需要删除的 最小 字符数。 字符串中字符的 频次 是该字符在字符串中的出现次数。例如，在字符串 “aab” 中，’a’ 的频次是 2，而 ‘b’ 的频次是 1 。 示例：示例 1： 输入：s = &quot;aab&quot; 输出：0 解释：s 已经是优质字符串。 示例 2： 输入：s = &quot;aaabbbcc&quot; 输出：2 解释：可以删除两个 &apos;b&apos; , 得到优质字符串 &quot;aaabcc&quot; 。 另一种方式是删除一个 &apos;b&apos; 和一个 &apos;c&apos; ，得到优质字符串 &quot;aaabbc&quot; 。 示例 3： 输入：s = &quot;ceabaacb&quot; 输出：2 解释：可以删除两个 &apos;c&apos; 得到优质字符串 &quot;eabaab&quot; 。 注意，只需要关注结果字符串中仍然存在的字符。（即，频次为 0 的字符会忽略不计。） 提示： 1 &lt;= s.length &lt;= 10^5 s 仅含小写英文字母 分析：贪心 统计每个字符出现次数 遍历各字符出现次数，同时使用map存储已经出现过的字符数量，遇到重复的就一个个往下减，直到不重复为止 代码：class Solution { public: int minDeletions(string s) { vector&lt;int&gt; v(26, 0); map&lt;int, int&gt; m; int ret = 0; for(int i = 0; i &lt; s.size(); i++){ v[s[i]-&apos;a&apos;]++; } sort(v.begin(), v.end()); for(int i = 0; i &lt; 26; i++){ if(v[i] == 0) continue; if(m.count(v[i]) == 0){ m[v[i]] = 1; } else{ for(int j = v[i]-1; j &gt;= 0; j--){ ret++; if(m.count(j) == 0){ m[j] = 1; break; } } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-deletions-to-make-character-frequencies-unique/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5561. 获取生成数组中的最大值]]></title>
    <url>%2F2020%2F11%2F09%2Fleetcode%205561.%20%E8%8E%B7%E5%8F%96%E7%94%9F%E6%88%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ： nums[0] = 0 nums[1] = 1 当 2 &lt;= 2 i &lt;= n 时，nums[2 i] = nums[i] 当 2 &lt;= 2 i + 1 &lt;= n 时，nums[2 i + 1] = nums[i] + nums[i + 1] 返回生成数组 nums 中的 最大 值。 示例：示例 1： 输入：n = 7 输出：3 解释：根据规则： nums[0] = 0 nums[1] = 1 nums[(1 * 2) = 2] = nums[1] = 1 nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2 nums[(2 * 2) = 4] = nums[2] = 1 nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3 nums[(3 * 2) = 6] = nums[3] = 2 nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3 因此，nums = [0,1,1,2,1,3,2,3]，最大值 3 示例 2： 输入：n = 2 输出：1 解释：根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1 示例 3： 输入：n = 3 输出：2 解释：根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2 提示： 0 &lt;= n &lt;= 100 分析：翻译一下题目 如果i是偶数，那么num[i] = num[i/2] 如果i是奇数，那么num[i] = num[i/2] + num[i/2+1] 直接遍历即可 代码：class Solution { public: int getMaximumGenerated(int n) { vector&lt;int&gt; v(n+1, 0); if(n == 0) return 0; if(n == 1) return 1; v[0] = 0; v[1] = 1; int m = 1; for(int i = 2; i &lt;= n; i++){ if(i%2 == 0){ v[i] = v[i/2]; } else{ v[i] = v[i/2] + v[i/2+1]; } m = max(m, v[i]); //cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;; } return m; } }; 题目地址:https://leetcode-cn.com/problems/get-maximum-in-generated-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5600. 第 K 条最小指令]]></title>
    <url>%2F2020%2F11%2F02%2Fleetcode%205600.%20%E7%AC%AC%20K%20%E6%9D%A1%E6%9C%80%E5%B0%8F%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[题目：Bob 站在单元格 (0, 0) ，想要前往目的地 destination ：(row, column) 。他只能向 右 或向 下 走。你可以为 Bob 提供导航 指令 来帮助他到达目的地 destination 。 指令 用字符串表示，其中每个字符： ‘H’ ，意味着水平向右移动 ‘V’ ，意味着竖直向下移动 能够为 Bob 导航到目的地 destination 的指令可以有多种，例如，如果目的地 destination 是 (2, 3)，”HHHVV” 和 “HVHVH” 都是有效 指令 。 然而，Bob 很挑剔。因为他的幸运数字是 k，他想要遵循 按字典序排列后的第 k 条最小指令 的导航前往目的地 destination 。k 的编号 从 1 开始 。 给你一个整数数组 destination 和一个整数 k ，请你返回可以为 Bob 提供前往目的地 destination 导航的 按字典序排列后的第 k 条最小指令 。 示例：示例 1： 输入：destination = [2,3], k = 1 输出：&quot;HHHVV&quot; 解释：能前往 (2, 3) 的所有导航指令 按字典序排列后 如下所示： [&quot;HHHVV&quot;, &quot;HHVHV&quot;, &quot;HHVVH&quot;, &quot;HVHHV&quot;, &quot;HVHVH&quot;, &quot;HVVHH&quot;, &quot;VHHHV&quot;, &quot;VHHVH&quot;, &quot;VHVHH&quot;, &quot;VVHHH&quot;]. 示例 2： 输入：destination = [2,3], k = 2 输出：&quot;HHVHV&quot; 示例 3： 输入：destination = [2,3], k = 3 输出：&quot;HHVVH&quot; 提示： destination.length == 2 1 &lt;= row, column &lt;= 15 1 &lt;= k &lt;= nCr(row + column, row)，其中 nCr(a, b) 表示组合数，即从 a 个物品中选 b 个物品的不同方案数。 分析：先计算出各种条件下的组合数，比如有 h 个 H， v 个 V，那么就相当于在 h + v 个空里 填入 h 个 H，剩下填入 V。 用comb[i][j] 表示 i 个空填入 j 个 h 。 然后类似于二分 计算出第一位为 H 的字符串最多有comb[h+v-1][h-1]种，所以k如果大于comb[h+v-1][h-1]，那么第一位一定为 V ，否则为 H，以此类推，直到 H 全部用完，最后全部填入 V 代码：class Solution { public: string kthSmallestPath(vector&lt;int&gt;&amp; destination, int k) { int h = destination[1]; int v = destination[0]; vector&lt;vector&lt;int&gt;&gt; comb(h + v, vector&lt;int&gt;(h)); comb[0][0] = 1; for(int i = 1; i &lt; h+v; i++){ comb[i][0] = 1; for(int j = 1; j &lt;= i &amp;&amp; j &lt; h; j++){ comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j]; } } string str = &quot;&quot;; for(int i = 0, imax = h + v; i &lt; imax; i++){ if(h &gt; 0){ int o = comb[h+v-1][h-1]; if(k &gt; o){ str += &apos;V&apos;; v--; k -= o; } else{ str += &apos;H&apos;; h--; } } else{ str += &apos;V&apos;; v--; } } return str; } }; 题目地址:https://leetcode-cn.com/problems/kth-smallest-instructions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5556. 可以到达的最远建筑]]></title>
    <url>%2F2020%2F11%2F02%2Fleetcode%205556.%20%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 heights ，表示建筑物的高度。另有一些砖块 bricks 和梯子 ladders 。 你从建筑物 0 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。 当从建筑物 i 移动到建筑物 i+1（下标 从 0 开始 ）时： 如果当前建筑物的高度 大于或等于 下一建筑物的高度，则不需要梯子或砖块 如果当前建筑的高度 小于 下一个建筑的高度，您可以使用 一架梯子 或 (h[i+1] - h[i]) 个砖块 如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 从 0 开始 ）。 示例：示例 1： 输入：heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1 输出：4 解释：从建筑物 0 出发，你可以按此方案完成旅程： - 不使用砖块或梯子到达建筑物 1 ，因为 4 &gt;= 2 - 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 &lt; 7 - 不使用砖块或梯子到达建筑物 3 ，因为 7 &gt;= 6 - 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 &lt; 9 无法越过建筑物 4 ，因为没有更多砖块或梯子。 示例 2： 输入：heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2 输出：7 示例 3： 输入：heights = [14,3,19,3], bricks = 17, ladders = 0 输出：3 提示： 1 &lt;= heights.length &lt;= 105 1 &lt;= heights[i] &lt;= 106 0 &lt;= bricks &lt;= 109 0 &lt;= ladders &lt;= heights.length 分析：使用贪心 先全部使用砖块到达可以到达的位置，然后用梯子替换使用砖头最多的地方（梯子也可以用在最新的高度上），以此类推，直到用完梯子并且砖头也不够用为止 代码：class Solution { public: int furthestBuilding(vector&lt;int&gt;&amp; heights, int bricks, int ladders) { multiset&lt;int&gt; v; for(int i = 1; i &lt; heights.size(); i++){ if(heights[i] &gt; heights[i-1]){ int g = heights[i] - heights[i-1]; if(bricks &gt;= g){ bricks -= g; v.insert(g); } else if(ladders &gt; 0){ if(v.size() &gt; 0){ auto a = v.end(); a--; if(*a &lt; g){ ladders--; continue; } bricks += *(a); v.erase(a); ladders--; i--; } else{ ladders--; } } else return i-1; } } return heights.size()-1; } }; 题目地址:https://leetcode-cn.com/problems/furthest-building-you-can-reach/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5555. 统计字典序元音字符串的数目]]></title>
    <url>%2F2020%2F11%2F02%2Fleetcode%205555.%20%E7%BB%9F%E8%AE%A1%E5%AD%97%E5%85%B8%E5%BA%8F%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。 字符串 s 按 字典序排列 需要满足：对于所有有效的 i，s[i] 在字母表中的位置总是与 s[i+1] 相同或在 s[i+1] 之前。 示例：示例 1： 输入：n = 1 输出：5 解释：仅由元音组成的 5 个字典序字符串为 [&quot;a&quot;,&quot;e&quot;,&quot;i&quot;,&quot;o&quot;,&quot;u&quot;] 示例 2： 输入：n = 2 输出：15 解释：仅由元音组成的 15 个字典序字符串为 [&quot;aa&quot;,&quot;ae&quot;,&quot;ai&quot;,&quot;ao&quot;,&quot;au&quot;,&quot;ee&quot;,&quot;ei&quot;,&quot;eo&quot;,&quot;eu&quot;,&quot;ii&quot;,&quot;io&quot;,&quot;iu&quot;,&quot;oo&quot;,&quot;ou&quot;,&quot;uu&quot;] 注意，&quot;ea&quot; 不是符合题意的字符串，因为 &apos;e&apos; 在字母表中的位置比 &apos;a&apos; 靠后 示例 3： 输入：n = 33 输出：66045 提示： 1 &lt;= n &lt;= 50 分析：类似于动态规划，但只需要用到最后一层即可 a[0] 为可以以a开头的字符串数量 接下来以此类推 代码：class Solution { public: int countVowelStrings(int n) { vector&lt;vector&lt;int&gt;&gt; v(1, vector&lt;int&gt;{5, 4, 3, 2, 1}); for(int i = 1; i &lt; n; i++){ vector&lt;int&gt; a(5); a[0] = v[i-1][0] + v[i-1][1] + v[i-1][2] + v[i-1][3] + v[i-1][4]; a[1] = v[i-1][1] + v[i-1][2] + v[i-1][3] + v[i-1][4]; a[2] = v[i-1][2] + v[i-1][3] + v[i-1][4]; a[3] = v[i-1][3] + v[i-1][4]; a[4] = v[i-1][4]; v.push_back(a); } return v[n-1][0]; } }; 题目地址:https://leetcode-cn.com/problems/count-sorted-vowel-strings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5554. 能否连接形成数组]]></title>
    <url>%2F2020%2F11%2F02%2Fleetcode%205554.%20%E8%83%BD%E5%90%A6%E8%BF%9E%E6%8E%A5%E5%BD%A2%E6%88%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 arr ，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组 pieces，其中的整数也 互不相同 。请你以 任意顺序 连接 pieces 中的数组以形成 arr 。但是，不允许 对每个数组 pieces[i] 中的整数重新排序。 如果可以连接 pieces 中的数组形成 arr ，返回 true ；否则，返回 false 。 示例：示例 1： 输入：arr = [85], pieces = [[85]] 输出：true 示例 2： 输入：arr = [15,88], pieces = [[88],[15]] 输出：true 解释：依次连接 [15] 和 [88] 示例 3： 输入：arr = [49,18,16], pieces = [[16,18,49]] 输出：false 解释：即便数字相符，也不能重新排列 pieces[0] 示例 4： 输入：arr = [91,4,64,78], pieces = [[78],[4,64],[91]] 输出：true 解释：依次连接 [91]、[4,64] 和 [78] 示例 5： 输入：arr = [1,3,5,7], pieces = [[2,4,6,8]] 输出：false 提示： 1 &lt;= pieces.length &lt;= arr.length &lt;= 100 sum(pieces[i].length) == arr.length 1 &lt;= pieces[i].length &lt;= arr.length 1 &lt;= arr[i], pieces[i][j] &lt;= 100 arr 中的整数 互不相同 pieces 中的整数 互不相同（也就是说，如果将 pieces 扁平化成一维数组，数组中的所有整数互不相同） 分析：直接遍历，两个for循环 代码：class Solution { public: bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) { for(int i = 0; i &lt; arr.size(); i++){ bool b = false; for(int j = 0; j &lt; pieces.size(); j++){ for(int k = 0; k &lt; pieces[j].size(); k++){ if(arr[i+k] != pieces[j][k]) break; else if(k == pieces[j].size()-1){ i = i+k; b = true; } } if(b) break; } if(!b) return false; } return true; } }; 题目地址:https://leetcode-cn.com/problems/check-array-formation-through-concatenation/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5548. 最小体力消耗路径]]></title>
    <url>%2F2020%2F10%2F26%2Fleetcode%205548.%20%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目：你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。 一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。 请你返回从左上角走到右下角的最小 体力消耗值 。 示例：示例 1： 输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。 这条路径比路径 [1,2,2,2,5] 更优，因为另一条路劲差值最大值为 3 。 示例 2： 输入：heights = [[1,2,3],[3,8,4],[5,3,5]] 输出：1 解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。 示例 3： 输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]] 输出：0 解释：上图所示路径不需要消耗任何体力。 提示： rows == heights.length columns == heights[i].length 1 &lt;= rows, columns &lt;= 100 1 &lt;= heights[i][j] &lt;= 106 分析：使用二分来找到合适的高度差绝对值m（只走高度差为m的格子），中途可以使用dfs来判断是否连通 代码：class Solution { vector&lt;vector&lt;int&gt;&gt; h; int a; int b; vector&lt;vector&lt;int&gt;&gt; dir = {{1,0},{0,1},{0,-1},{-1,0}}; public: bool dfs(int x, int y, int z, vector&lt;vector&lt;bool&gt;&gt;&amp; m){ m[x][y] = 1; if(x == a-1 &amp;&amp; y == b-1){ return true; } if(x + 1 &lt; a &amp;&amp; abs(h[x+1][y] - h[x][y]) &lt;= z &amp;&amp; m[x+1][y] == 0){ if(dfs(x+1, y, z, m)) return true; } if(x - 1 &gt;= 0 &amp;&amp; abs(h[x-1][y] - h[x][y]) &lt;= z &amp;&amp; m[x-1][y] == 0){ if(dfs(x-1, y, z, m)) return true; } if(y + 1 &lt; b &amp;&amp; abs(h[x][y+1] - h[x][y]) &lt;= z &amp;&amp; m[x][y+1] == 0){ if(dfs(x, y+1, z, m)) return true; } if(y - 1 &gt;= 0 &amp;&amp; abs(h[x][y-1] - h[x][y]) &lt;= z &amp;&amp; m[x][y-1] == 0){ if(dfs(x, y-1, z, m)) return true; } return false; } int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) { h = heights; a = h.size(); b = h[0].size(); int l = 0; int r = 1e6; int ret = 0; while(l &lt; r){ vector&lt;vector&lt;bool&gt;&gt; m(a, vector&lt;bool&gt;(b, false)); int mi = (l+r)/2; bool b = dfs(0, 0, mi, m); if(b){ r = mi; } else l = mi+1; } return r; } }; 题目地址:https://leetcode-cn.com/problems/path-with-minimum-effort/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5547. 等差子数组]]></title>
    <url>%2F2020%2F10%2F26%2Fleetcode%205547.%20%E7%AD%89%E5%B7%AE%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：如果一个数列由至少两个元素组成，且每两个连续元素之间的差值都相同，那么这个序列就是 等差数列 。更正式地，数列 s 是等差数列，只需要满足：对于每个有效的 i ， s[i+1] - s[i] == s[1] - s[0] 都成立。 例如，下面这些都是 等差数列 ： 1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 下面的数列 不是等差数列 ： 1, 1, 2, 5, 7 给你一个由 n 个整数组成的数组 nums，和两个由 m 个整数组成的数组 l 和 r，后两个数组表示 m 组范围查询，其中第 i 个查询对应范围 [l[i], r[i]] 。所有数组的下标都是 从 0 开始 的。 返回 boolean 元素构成的答案列表 answer 。如果子数组 nums[l[i]], nums[l[i]+1], … , nums[r[i]] 可以 重新排列 形成 等差数列 ，answer[i] 的值就是 true；否则answer[i] 的值就是 false 。 示例：示例 1： 输入：nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5] 输出：[true,false,true] 解释： 第 0 个查询，对应子数组 [4,6,5] 。可以重新排列为等差数列 [6,5,4] 。 第 1 个查询，对应子数组 [4,6,5,9] 。无法重新排列形成等差数列。 第 2 个查询，对应子数组 [5,9,3,7] 。可以重新排列为等差数列 [3,5,7,9] 。 示例 2： 输入：nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10] 输出：[false,true,false,false,true,true] 提示： n == nums.length m == l.length m == r.length 2 &lt;= n &lt;= 500 1 &lt;= m &lt;= 500 0 &lt;= l[i] &lt; r[i] &lt; n -105 &lt;= nums[i] &lt;= 105 分析：直接暴力对每一段区间排序，遍历是否为等差数列 代码：class Solution { public: vector&lt;bool&gt; checkArithmeticSubarrays(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; l, vector&lt;int&gt;&amp; r) { vector&lt;bool&gt; ret; for(int i = 0; i &lt; l.size(); i++){ vector&lt;int&gt; n; n.assign(nums.begin()+l[i], nums.begin()+r[i]+1); sort(n.begin(), n.end()); int z = n[1] - n[0]; bool b = true; for(int j = 1; j &lt; n.size(); j++){ if(n[j] - n[j-1] != z){ b = false; break; } } ret.push_back(b); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/arithmetic-subarrays/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5546. 按键持续时间最长的键]]></title>
    <url>%2F2020%2F10%2F26%2Fleetcode%205546.%20%E6%8C%89%E9%94%AE%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E6%9C%80%E9%95%BF%E7%9A%84%E9%94%AE%2F</url>
    <content type="text"><![CDATA[题目：LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。 给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。 测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。 注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。 请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。 示例：示例 1： 输入：releaseTimes = [9,29,49,50], keysPressed = &quot;cbcd&quot; 输出：&quot;c&quot; 解释：按键顺序和持续时间如下： 按下 &apos;c&apos; ，持续时间 9（时间 0 按下，时间 9 松开） 按下 &apos;b&apos; ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开） 按下 &apos;c&apos; ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开） 按下 &apos;d&apos; ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开） 按键持续时间最长的键是 &apos;b&apos; 和 &apos;c&apos;（第二次按下时），持续时间都是 20 &apos;c&apos; 按字母顺序排列比 &apos;b&apos; 大，所以答案是 &apos;c&apos; 示例 2： 输入：releaseTimes = [12,23,36,46,62], keysPressed = &quot;spuda&quot; 输出：&quot;a&quot; 解释：按键顺序和持续时间如下： 按下 &apos;s&apos; ，持续时间 12 按下 &apos;p&apos; ，持续时间 23 - 12 = 11 按下 &apos;u&apos; ，持续时间 36 - 23 = 13 按下 &apos;d&apos; ，持续时间 46 - 36 = 10 按下 &apos;a&apos; ，持续时间 62 - 46 = 16 按键持续时间最长的键是 &apos;a&apos; ，持续时间 16 提示： releaseTimes.length == n keysPressed.length == n 2 &lt;= n &lt;= 1000 0 &lt;= releaseTimes[i] &lt;= 109 releaseTimes[i] &lt; releaseTimes[i+1] keysPressed 仅由小写英文字母组成 分析：一次遍历，遇到间隔大的字母就更新，如果间隔相等，比较一下字母大小再更新 代码：class Solution { public: char slowestKey(vector&lt;int&gt;&amp; releaseTimes, string keysPressed) { int m = releaseTimes[0]; int ret = keysPressed[0]; for(int i = 1; i &lt; releaseTimes.size(); i++){ if(releaseTimes[i] - releaseTimes[i-1] &gt; m){ m = releaseTimes[i] - releaseTimes[i-1]; ret = keysPressed[i]; } if(releaseTimes[i] - releaseTimes[i-1] == m){ ret = keysPressed[i] &gt; ret ? keysPressed[i] : ret; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/slowest-key/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5526. 最多可达成的换楼请求数目]]></title>
    <url>%2F2020%2F09%2F27%2Fleetcode%205526.%20%E6%9C%80%E5%A4%9A%E5%8F%AF%E8%BE%BE%E6%88%90%E7%9A%84%E6%8D%A2%E6%A5%BC%E8%AF%B7%E6%B1%82%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：我们有 n 栋楼，编号从 0 到 n - 1 。每栋楼有若干员工。由于现在是换楼的季节，部分员工想要换一栋楼居住。 给你一个数组 requests ，其中 requests[i] = [fromi, toi] ，表示一个员工请求从编号为 fromi 的楼搬到编号为 toi 的楼。 一开始 所有楼都是满的，所以从请求列表中选出的若干个请求是可行的需要满足 每栋楼员工净变化为 0 。意思是每栋楼 离开 的员工数目 等于 该楼 搬入 的员工数数目。比方说 n = 3 且两个员工要离开楼 0 ，一个员工要离开楼 1 ，一个员工要离开楼 2 ，如果该请求列表可行，应该要有两个员工搬入楼 0 ，一个员工搬入楼 1 ，一个员工搬入楼 2 。 请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。 示例：示例 1： 输入：n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]] 输出：5 解释：请求列表如下： 从楼 0 离开的员工为 x 和 y ，且他们都想要搬到楼 1 。 从楼 1 离开的员工为 a 和 b ，且他们分别想要搬到楼 2 和 0 。 从楼 2 离开的员工为 z ，且他想要搬到楼 0 。 从楼 3 离开的员工为 c ，且他想要搬到楼 4 。 没有员工从楼 4 离开。 我们可以让 x 和 b 交换他们的楼，以满足他们的请求。 我们可以让 y，a 和 z 三人在三栋楼间交换位置，满足他们的要求。 所以最多可以满足 5 个请求。 示例 2： 输入：n = 3, requests = [[0,0],[1,2],[2,1]] 输出：3 解释：请求列表如下： 从楼 0 离开的员工为 x ，且他想要回到原来的楼 0 。 从楼 1 离开的员工为 y ，且他想要搬到楼 2 。 从楼 2 离开的员工为 z ，且他想要搬到楼 1 。 我们可以满足所有的请求。 示例 3： 输入：n = 4, requests = [[0,3],[3,1],[1,2],[2,0]] 输出：4 提示： 1 &lt;= n &lt;= 20 1 &lt;= requests.length &lt;= 16 requests[i].length == 2 0 &lt;= fromi, toi &lt; n 分析：所有的可能最多有 1&lt;&lt;16 种，可以直接遍历，使用状态压缩，0表示不选择此请求，1表示选择此请求 记录每种可能每栋楼员工进出平衡的人数即可，如果不平衡说明此方案无法通过 代码：class Solution { public: int maximumRequests(int n, vector&lt;vector&lt;int&gt;&gt;&amp; requests) { int m = 0; for(int state = 0; state &lt; (1 &lt;&lt; requests.size()); state++){ int res = 0; vector&lt;int&gt; out(n, 0); vector&lt;int&gt; in(n, 0); for(int i = 0; i &lt; requests.size(); i++){ if((state &amp; (1 &lt;&lt; i)) &gt; 0){ in[requests[i][1]]++; out[requests[i][0]]++; } } bool b = false; for(int i = 0; i &lt; n; i++){ if(in[i] == out[i]) res += in[i]; else{ b = true; break; } } if(b) continue; m = max(m, res); } return m; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-achievable-transfer-requests/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5525. 皇位继承顺序]]></title>
    <url>%2F2020%2F09%2F27%2Fleetcode%205525.%20%E7%9A%87%E4%BD%8D%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目：一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。 这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。 Successor(x, curOrder): 如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中： 如果 x 是国王，那么返回 null 否则，返回 Successor(x 的父亲, curOrder) 否则，返回 x 不在 curOrder 中最年长的孩子 比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。 一开始， curOrder 为 [“king”]. 调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [“king”, “Alice”] 。 调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”] 。 调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [“king”, “Alice”, “Jack”, “Bob”] 。 调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [“king”, “Alice”, “Jack”, “Bob”] 。通过以上的函数，我们总是能得到一个唯一的继承顺序。 请你实现 ThroneInheritance 类： ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。 void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。 void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。 string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。 示例：输入： [&quot;ThroneInheritance&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;getInheritanceOrder&quot;, &quot;death&quot;, &quot;getInheritanceOrder&quot;] [[&quot;king&quot;], [&quot;king&quot;, &quot;andy&quot;], [&quot;king&quot;, &quot;bob&quot;], [&quot;king&quot;, &quot;catherine&quot;], [&quot;andy&quot;, &quot;matthew&quot;], [&quot;bob&quot;, &quot;alex&quot;], [&quot;bob&quot;, &quot;asha&quot;], [null], [&quot;bob&quot;], [null]] 输出： [null, null, null, null, null, null, null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;], null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]] 解释： ThroneInheritance t= new ThroneInheritance(&quot;king&quot;); // 继承顺序：king t.birth(&quot;king&quot;, &quot;andy&quot;); // 继承顺序：king &gt; andy t.birth(&quot;king&quot;, &quot;bob&quot;); // 继承顺序：king &gt; andy &gt; bob t.birth(&quot;king&quot;, &quot;catherine&quot;); // 继承顺序：king &gt; andy &gt; bob &gt; catherine t.birth(&quot;andy&quot;, &quot;matthew&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; catherine t.birth(&quot;bob&quot;, &quot;alex&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; catherine t.birth(&quot;bob&quot;, &quot;asha&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; asha &gt; catherine t.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;] t.death(&quot;bob&quot;); // 继承顺序：king &gt; andy &gt; matthew &gt; bob（已经去世）&gt; alex &gt; asha &gt; catherine t.getInheritanceOrder(); // 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;] 提示： 1 &lt;= kingName.length, parentName.length, childName.length, name.length &lt;= 15 kingName，parentName， childName 和 name 仅包含小写英文字母。 所有的参数 childName 和 kingName 互不相同。 所有 death 函数中的死亡名字 name 要么是国王，要么是已经出生了的人员名字。 每次调用 birth(parentName, childName) 时，测试用例都保证 parentName 对应的人员是活着的。 最多调用 105 次birth 和 death 。 最多调用 10 次 getInheritanceOrder 。 分析：构建一棵树，需要返回继承顺序时遍历一遍即可（记得去掉死亡的人） 代码：class ThroneInheritance { private: unordered_map&lt;string, vector&lt;string&gt;&gt; m; vector&lt;string&gt; ret; map&lt;string, int&gt; sw; string kingName1; public: ThroneInheritance(string kingName) { m[kingName]; kingName1 = kingName; } void birth(string parentName, string childName) { m[parentName].push_back(childName); } void death(string name) { sw[name] = 1; } void dfs(string n){ if(sw.count(n) == 0) ret.push_back(n); for(int i = 0; i &lt; m[n].size(); i++){ dfs(m[n][i]); } } vector&lt;string&gt; getInheritanceOrder() { ret.clear(); dfs(kingName1); return ret; } }; /** * Your ThroneInheritance object will be instantiated and called as such: * ThroneInheritance* obj = new ThroneInheritance(kingName); * obj-&gt;birth(parentName,childName); * obj-&gt;death(name); * vector&lt;string&gt; param_3 = obj-&gt;getInheritanceOrder(); */ 题目地址:https://leetcode-cn.com/problems/throne-inheritance/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5524. 经营摩天轮的最大利润]]></title>
    <url>%2F2020%2F09%2F27%2Fleetcode%205524.%20%E7%BB%8F%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6%2F</url>
    <content type="text"><![CDATA[题目：你正在经营一座摩天轮，该摩天轮共有 4 个座舱 ，每个座舱 最多可以容纳 4 位游客 。你可以 逆时针 轮转座舱，但每次轮转都需要支付一定的运行成本 runningCost 。摩天轮每次轮转都恰好转动 1 / 4 周。 给你一个长度为 n 的数组 customers ， customers[i] 是在第 i 次轮转（下标从 0 开始）之前到达的新游客的数量。这也意味着你必须在新游客到来前轮转 i 次。每位游客在登上离地面最近的座舱前都会支付登舱成本 boardingCost ，一旦该座舱再次抵达地面，他们就会离开座舱结束游玩。 你可以随时停下摩天轮，即便是 在服务所有游客之前 。如果你决定停止运营摩天轮，为了保证所有游客安全着陆，将免费进行所有后续轮转 。注意，如果有超过 4 位游客在等摩天轮，那么只有 4 位游客可以登上摩天轮，其余的需要等待 下一次轮转 。 返回最大化利润所需执行的 最小轮转次数 。 如果不存在利润为正的方案，则返回 -1 。 示例：示例 1： 输入：customers = [8,3], boardingCost = 5, runningCost = 6 输出：3 解释：座舱上标注的数字是该座舱的当前游客数。 1. 8 位游客抵达，4 位登舱，4 位等待下一舱，摩天轮轮转。当前利润为 4 * $5 - 1 * $6 = $14 。 2. 3 位游客抵达，4 位在等待的游客登舱，其他 3 位等待，摩天轮轮转。当前利润为 8 * $5 - 2 * $6 = $28 。 3. 最后 3 位游客登舱，摩天轮轮转。当前利润为 11 * $5 - 3 * $6 = $37 。 轮转 3 次得到最大利润，最大利润为 $37 。 示例 2： 输入：customers = [10,9,6], boardingCost = 6, runningCost = 4 输出：7 解释： 1. 10 位游客抵达，4 位登舱，6 位等待下一舱，摩天轮轮转。当前利润为 4 * $6 - 1 * $4 = $20 。 2. 9 位游客抵达，4 位登舱，11 位等待（2 位是先前就在等待的，9 位新加入等待的），摩天轮轮转。当前利润为 8 * $6 - 2 * $4 = $40 。 3. 最后 6 位游客抵达，4 位登舱，13 位等待，摩天轮轮转。当前利润为 12 * $6 - 3 * $4 = $60 。 4. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 * $6 - 4 * $4 = $80 。 5. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 20 * $6 - 5 * $4 = $100 。 6. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 24 * $6 - 6 * $4 = $120 。 7. 1 位登舱，摩天轮轮转。当前利润为 25 * $6 - 7 * $4 = $122 。 轮转 7 次得到最大利润，最大利润为$122 。 示例 3： 输入：customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92 输出：-1 解释： 1. 3 位游客抵达，3 位登舱，0 位等待，摩天轮轮转。当前利润为 3 * $1 - 1 * $92 = -$89 。 2. 4 位游客抵达，4 位登舱，0 位等待，摩天轮轮转。当前利润为 is 7 * $1 - 2 * $92 = -$177 。 3. 0 位游客抵达，0 位登舱，0 位等待，摩天轮轮转。当前利润为 7 * $1 - 3 * $92 = -$269 。 4. 5 位游客抵达，4 位登舱，1 位等待，摩天轮轮转。当前利润为 12 * $1 - 4 * $92 = -$356 。 5. 1 位游客抵达，2 位登舱，0 位等待，摩天轮轮转。当前利润为 13 * $1 - 5 * $92 = -$447 。 利润永不为正，所以返回 -1 。 示例 4： 输入：customers = [10,10,6,4,7], boardingCost = 3, runningCost = 8 输出：9 解释： 1. 10 位游客抵达，4 位登舱，6 位等待，摩天轮轮转。当前利润为 4 * $3 - 1 * $8 = $4 。 2. 10 位游客抵达，4 位登舱，12 位等待，摩天轮轮转。当前利润为 8 * $3 - 2 * $8 = $8 。 3. 6 位游客抵达，4 位登舱，14 位等待，摩天轮轮转。当前利润为 12 * $3 - 3 * $8 = $12 。 4. 4 位游客抵达，4 位登舱，14 位等待，摩天轮轮转。当前利润为 16 * $3 - 4 * $8 = $16 。 5. 7 位游客抵达，4 位登舱，17 位等待，摩天轮轮转。当前利润为 20 * $3 - 5 * $8 = $20 。 6. 4 位登舱，13 位等待，摩天轮轮转。当前利润为 24 * $3 - 6 * $8 = $24 。 7. 4 位登舱，9 位等待，摩天轮轮转。当前利润为 28 * $3 - 7 * $8 = $28 。 8. 4 位登舱，5 位等待，摩天轮轮转。当前利润为 32 * $3 - 8 * $8 = $32 。 9. 4 位登舱，1 位等待，摩天轮轮转。当前利润为 36 * $3 - 9 * $8 = $36 。 ​​​​​​​10. 1 位登舱，0 位等待，摩天轮轮转。当前利润为 37 * $3 - 10 * $8 = $31 。 轮转 9 次得到最大利润，最大利润为 $36 。 提示： n == customers.length 1 &lt;= n &lt;= 105 0 &lt;= customers[i] &lt;= 50 1 &lt;= boardingCost, runningCost &lt;= 100 分析：直接记录每次载客利润和次数，当利润大于最大值的时候记录次数即可 代码：class Solution { public: int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) { int m = 0; int sy = 0; int dd = 0; int ret = 0; int lz = 0; for(int i = 0; i &lt; customers.size(); i++){ lz += 1; dd += customers[i]; if(dd &gt;= 4){ dd -= 4; sy += 4*boardingCost; } else{ sy += dd*4; dd = 0; } sy -= runningCost; if(m &lt; sy){ m = sy; ret = lz; } } while(dd &gt; 0){ lz += 1; if(dd &gt;= 4){ dd -= 4; sy += 4*boardingCost; } else{ sy += dd*boardingCost; dd = 0; } sy -= runningCost; if(m &lt; sy){ m = sy; ret = lz; } } return ret &gt; 0 ? ret : -1; } }; 题目地址:https://leetcode-cn.com/problems/maximum-profit-of-operating-a-centennial-wheel/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5523. 文件夹操作日志搜集器]]></title>
    <url>%2F2020%2F09%2F27%2Fleetcode%205523.%20%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E6%90%9C%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目：每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。 下面给出对变更操作的说明： “../“ ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。 “./“ ：继续停留在当前文件夹。 “x/“ ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。给你一个字符串列表 logs ，其中 logs[i] 是用户在 ith 步执行的操作。 文件系统启动时位于主文件夹，然后执行 logs 中的操作。 执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。 示例：示例 1： 输入：logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;../&quot;,&quot;d21/&quot;,&quot;./&quot;] 输出：2 解释：执行 &quot;../&quot; 操作变更文件夹 2 次，即可回到主文件夹 示例 2： 输入：logs = [&quot;d1/&quot;,&quot;d2/&quot;,&quot;./&quot;,&quot;d3/&quot;,&quot;../&quot;,&quot;d31/&quot;] 输出：3 示例 3： 输入：logs = [&quot;d1/&quot;,&quot;../&quot;,&quot;../&quot;,&quot;../&quot;] 输出：0 提示： 1 &lt;= logs.length &lt;= 103 2 &lt;= logs[i].length &lt;= 10 logs[i] 包含小写英文字母，数字，’.’ 和 ‘/‘ logs[i] 符合语句中描述的格式 文件夹名称由小写英文字母和数字组成 分析：判断字符串倒数第二个字符 为“.”，判断字符串长度，如果为2，无操作，如果大于2，减少一步返回主文件夹所需的步数，当为0时，无效 为其他字符，增加一步返回主文件夹所需的步数 代码：class Solution { public: int minOperations(vector&lt;string&gt;&amp; logs) { int ret = 0; for(int i = 0; i &lt; logs.size(); i++){ if(logs[i][logs[i].size()-2] == &apos;.&apos;){ if(logs[i].size() == 3) ret--; } else{ ret++; } if(ret &lt; 0) ret = 0; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/crawler-log-folder/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1595. 连通两组点的最小成本]]></title>
    <url>%2F2020%2F09%2F21%2Fleetcode%201595.%20%E8%BF%9E%E9%80%9A%E4%B8%A4%E7%BB%84%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[题目：给你两组点，其中第一组中有 size1 个点，第二组中有 size2 个点，且 size1 &gt;= size2 。 任意两点间的连接成本 cost 由大小为 size1 x size2 矩阵给出，其中 cost[i][j] 是第一组中的点 i 和第二组中的点 j 的连接成本。如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。 返回连通两组点所需的最小成本。 示例：示例 1： 输入：cost = [[15, 96], [36, 2]] 输出：17 解释：连通两组点的最佳方法是： 1--A 2--B 总成本为 17 。 示例 2： 输入：cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]] 输出：4 解释：连通两组点的最佳方法是： 1--A 2--B 2--C 3--A 最小成本为 4 。 请注意，虽然有多个点连接到第一组中的点 2 和第二组中的点 A ，但由于题目并不限制连接点的数目，所以只需要关心最低总成本。 示例 3： 输入：cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]] 输出：10 提示： size1 == cost.length size2 == cost[i].length 1 &lt;= size1, size2 &lt;= 12 size1 &gt;= size2 0 &lt;= cost[i][j] &lt;= 100 分析：题目相当于：在一个矩阵中选取一些值, 要求满足矩阵的每一行和每一列都至少有一个元素被选中, 同时选中元素的总和最小 使用状态压缩dp，因为列数比较少，所以使用状压dp来表示每一行的选取情况 维护一个dp矩阵 dp[m][1 &lt;&lt; n], dp[i][j]表示当前选择第i行，行中的选取情况为j（二进制下，0表示未选中，1表示选中） 每一行选择的时候有两种策略 一种是随便选择一个（因为每行都需要至少选择一个） 一种是从未选择的列中挑选一部分选择（代码中遍历所有可能性） 代码：class Solution { public: int connectTwoGroups(vector&lt;vector&lt;int&gt;&gt;&amp; cost) { vector&lt;vector&lt;int&gt;&gt; dp(cost.size(), vector&lt;int&gt;(1 &lt;&lt; cost[0].size(), INT_MAX)); // 计算第一行各种状态下的结果 for(int i = 1; i &lt; (1 &lt;&lt; cost[0].size()); i++){ int z = 0; for(int j = 0; j &lt; cost[0].size(); j++) if((i &amp; (1 &lt;&lt; j)) != 0) z += cost[0][j]; dp[0][i] = z; } // 从第二行开始遍历 for(int i = 1; i &lt; cost.size(); i++){ for(int j = 1; j &lt; (1 &lt;&lt; cost[0].size()); j++){ // 先计算第i行至少选择一个的情况 for(int k = 0; k &lt; cost[0].size(); k++){ dp[i][j | (1 &lt;&lt; k)] = min(dp[i][j | (1 &lt;&lt; k)], dp[i-1][j] + cost[i][k]); } // 统计出到第i行时还未选择的列 int rest = (1 &lt;&lt; cost[0].size()) - 1 - j; // 将未选择的列的每种组合都遍历一遍， k = rest &amp; (k-1)可以得到所有的组合 for(int k = rest; k &gt;= 1; k = rest &amp; (k-1)){ int z = 0; for(int l = 0; l &lt; cost[0].size(); l++) if((k &amp; (1 &lt;&lt; l)) != 0) z += cost[i][l]; dp[i][j | k] = min(dp[i][j | k], dp[i-1][j] + z); } } } return dp[cost.size()-1][(1 &lt;&lt; cost[0].size()) - 1]; } }; 题目地址:https://leetcode-cn.com/problems/minimum-cost-to-connect-two-groups-of-points/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1594. 矩阵的最大非负积]]></title>
    <url>%2F2020%2F09%2F21%2Fleetcode%201594.%20%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%9E%E8%B4%9F%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目：给你一个大小为 rows x cols 的矩阵 grid 。最初，你位于左上角 (0, 0) ，每一步，你可以在矩阵中 向右 或 向下 移动。 在从左上角 (0, 0) 开始到右下角 (rows - 1, cols - 1) 结束的所有路径中，找出具有 最大非负积 的路径。路径的积是沿路径访问的单元格中所有整数的乘积。 返回 最大非负积 对 10^9 + 7 取余 的结果。如果最大积为负数，则返回 -1 。 注意，取余是在得到最大积之后执行的。 示例：示例 1： 输入：grid = [[-1,-2,-3], [-2,-3,-3], [-3,-3,-2]] 输出：-1 解释：从 (0, 0) 到 (2, 2) 的路径中无法得到非负积，所以返回 -1 示例 2： 输入：grid = [[1,-2,1], [1,-2,1], [3,-4,1]] 输出：8 解释：最大非负积对应的路径已经用粗体标出 (1 * 1 * -2 * -4 * 1 = 8) 示例 3： 输入：grid = [[1, 3], [0,-4]] 输出：0 解释：最大非负积对应的路径已经用粗体标出 (1 * 0 * -4 = 0) 示例 4： 输入：grid = [[ 1, 4,4,0], [-2, 0,0,1], [ 1,-1,1,1]] 输出：2 解释：最大非负积对应的路径已经用粗体标出 (1 * -2 * 1 * -1 * 1 * 1 = 2) 提示： 1 &lt;= rows, cols &lt;= 15 -4 &lt;= grid[i][j] &lt;= 4 分析：使用动态规划，每一个单元格有两种情况，一种是计算到当前单元格为正数，另一种为负数，同时维护两种情况即可 dp[i][j].first 表示到第i行第j列的非负数状态 dp[i][j].second 表示到第i行第j列的非正数状态 正数状态下设一个-1，表示到达当前格没办法为非负数 负数状态下设一个1，表示到达当前格没办法为非正数 代码：class Solution { public: int maxProductPath(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; dp(grid.size(), vector&lt;pair&lt;int, int&gt;&gt;(grid[0].size(), pair&lt;int, int&gt;{-1,1})); if(grid[0][0] == 0) return 0; if(grid[0][0] &gt; 0) dp[0][0].first = grid[0][0]; else dp[0][0].second = grid[0][0]; for(int i = 1; i &lt; grid.size(); i++){ int z = -1; int f = 1; if(dp[i-1][0].first != -1){ if(dp[i-1][0].first * grid[i][0] &gt;= 0) z = max(z, dp[i-1][0].first * grid[i][0]); if(dp[i-1][0].first * grid[i][0] &lt; 0) f = min(f, dp[i-1][0].first * grid[i][0]); } if(dp[i-1][0].second != 1){ if(dp[i-1][0].second * grid[i][0] &gt;= 0) z = max(z, dp[i-1][0].second * grid[i][0]); if(dp[i-1][0].second * grid[i][0] &lt; 0) f = min(f, dp[i-1][0].second * grid[i][0]); } dp[i][0].first = z; dp[i][0].second = f; } for(int i = 1; i &lt; grid[0].size(); i++){ int z = -1; int f = 1; if(dp[0][i-1].first != -1){ if(dp[0][i-1].first * grid[0][i] &gt;= 0) z = dp[0][i-1].first * grid[0][i]; if(dp[0][i-1].first * grid[0][i] &lt;= 0) f = dp[0][i-1].first * grid[0][i]; } if(dp[0][i-1].second != 1){ if(dp[0][i-1].second * grid[0][i] &gt;= 0) z = dp[0][i-1].second * grid[0][i]; if(dp[0][i-1].second * grid[0][i] &lt;= 0) f = dp[0][i-1].second * grid[0][i]; } dp[0][i].first = z; dp[0][i].second = f; } for(int i = 1; i &lt; grid.size(); i++){ for(int j = 1; j &lt; grid[0].size(); j++){ int z = -1; int f = 1; if(dp[i][j-1].first != -1){ if(dp[i][j-1].first * grid[i][j] &gt;= 0) z = max(z, dp[i][j-1].first * grid[i][j]); if(dp[i][j-1].first * grid[i][j] &lt;= 0) f = min(f, dp[i][j-1].first * grid[i][j]); } if(dp[i][j-1].second != 1){ if(dp[i][j-1].second * grid[i][j] &gt;= 0) z = max(z, dp[i][j-1].second * grid[i][j]); if(dp[i][j-1].second * grid[i][j] &lt;= 0) f = min(f, dp[i][j-1].second * grid[i][j]); } if(dp[i-1][j].first != -1){ if(dp[i-1][j].first * grid[i][j] &gt;= 0) z = max(z, dp[i-1][j].first * grid[i][j]); if(dp[i-1][j].first * grid[i][j] &lt;= 0) f = min(f, dp[i-1][j].first * grid[i][j]); } if(dp[i-1][j].second != 1){ if(dp[i-1][j].second * grid[i][j] &gt;= 0) z = max(z, dp[i-1][j].second * grid[i][j]); if(dp[i-1][j].second * grid[i][j] &lt;= 0) f = min(f, dp[i-1][j].second * grid[i][j]); } dp[i][j].first = z; dp[i][j].second = f; cout &lt;&lt; dp[i][j].first &lt;&lt; &quot; &quot;; } cout &lt;&lt; &quot;\n&quot;; } return dp[grid.size()-1][grid[0].size()-1].first; } }; 题目地址:https://leetcode-cn.com/problems/maximum-non-negative-product-in-a-matrix/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1593. 拆分字符串使唯一子字符串的数目最大]]></title>
    <url>%2F2020%2F09%2F21%2Fleetcode%201593.%20%E6%8B%86%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%BF%E5%94%AF%E4%B8%80%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE%E6%9C%80%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s ，请你拆分该字符串，并返回拆分后唯一子字符串的最大数目。 字符串 s 拆分后可以得到若干 非空子字符串 ，这些子字符串连接后应当能够还原为原字符串。但是拆分出来的每个子字符串都必须是 唯一的 。 注意：子字符串 是字符串中的一个连续字符序列。 示例：示例 1： 输入：s = &quot;ababccc&quot; 输出：5 解释：一种最大拆分方法为 [&apos;a&apos;, &apos;b&apos;, &apos;ab&apos;, &apos;c&apos;, &apos;cc&apos;] 。像 [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;cc&apos;] 这样拆分不满足题目要求，因为其中的 &apos;a&apos; 和 &apos;b&apos; 都出现了不止一次。 示例 2： 输入：s = &quot;aba&quot; 输出：2 解释：一种最大拆分方法为 [&apos;a&apos;, &apos;ba&apos;] 。 示例 3： 输入：s = &quot;aa&quot; 输出：1 解释：无法进一步拆分字符串。 提示： 1 &lt;= s.length &lt;= 16 s 仅包含小写英文字母 分析：回溯，直接暴力判断每种情况，使用一个map判断是否已经有此子字符串 代码：class Solution { private: int ret; public: void dg(int i, string &amp;s, unordered_map&lt;string, int&gt; &amp;m, string str, int ans){ if(i == s.size()){ ret = max(ret, ans); return; } str += s[i]; dg(i+1, s, m, str, ans); if(m[str] == 0){ m[str] = 1; ans++; dg(i+1, s, m, &quot;&quot;, ans); m[str] = 0; str = &quot;&quot;; } } int maxUniqueSplit(string s) { ret = 0; unordered_map&lt;string, int&gt; m; dg(0, s, m, &quot;&quot;, 0); return ret; } }; 题目地址:https://leetcode-cn.com/problems/split-a-string-into-the-max-number-of-unique-substrings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1592. 重新排列单词间的空格]]></title>
    <url>%2F2020%2F09%2F21%2Fleetcode%201592.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%8D%95%E8%AF%8D%E9%97%B4%E7%9A%84%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 text ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 text 至少包含一个单词 。 请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。 返回 重新排列空格后的字符串 。 示例：示例 1： 输入：text = &quot; this is a sentence &quot; 输出：&quot;this is a sentence&quot; 解释：总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 / (4-1) = 3 个。 示例 2： 输入：text = &quot; practice makes perfect&quot; 输出：&quot;practice makes perfect &quot; 解释：总共有 7 个空格和 3 个单词。7 / (3-1) = 3 个空格加上 1 个多余的空格。多余的空格需要放在字符串的末尾。 示例 3： 输入：text = &quot;hello world&quot; 输出：&quot;hello world&quot; 示例 4： 输入：text = &quot; walks udp package into bar a&quot; 输出：&quot;walks udp package into bar a &quot; 示例 5： 输入：text = &quot;a&quot; 输出：&quot;a&quot; 提示： 1 &lt;= text.length &lt;= 100 text 由小写英文字母和 ‘ ‘ 组成 text 中至少包含一个单词 分析：遍历一遍统计空格和单词数量，第二遍遍历时在每两个单词中间插入合适的空格数量即可 代码：class Solution { public: string reorderSpaces(string text) { int k = 0; int d = 0; for(int i = 0; i &lt; text.size(); i++){ if(text[i] == &apos; &apos;) k++; if(i - 1 &gt;= 0 &amp;&amp; text[i-1] == &apos; &apos; &amp;&amp; text[i] != &apos; &apos;) d++; } if(text[0] == &apos; &apos;) d--; int z = d == 0 ? 0 : k / d; int y = d == 0 ? k : k % d; string str = &quot;&quot;; int i = 0; while(i &lt; text.size() &amp;&amp; text[i] == &apos; &apos;) i++; for(; i &lt; text.size(); i++){ if(text[i] != &apos; &apos;) str += text[i]; else{ while(i &lt; text.size() &amp;&amp; text[i] == &apos; &apos;) i++; if(i == text.size()) break; i--; for(int j = 0; j &lt; z; j++) str += &apos; &apos;; cout &lt;&lt; i; } } for(int j = 0; j &lt; y; j++) str += &apos; &apos;; return str; } }; 题目地址:https://leetcode-cn.com/problems/rearrange-spaces-between-words/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5514. 检查字符串是否可以通过排序子字符串得到另一个字符串]]></title>
    <url>%2F2020%2F09%2F14%2Fleetcode%205514.%20%E6%A3%80%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%8E%92%E5%BA%8F%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%97%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你两个字符串 s 和 t ，请你通过若干次以下操作将字符串 s 转化成字符串 t ： 选择 s 中一个 非空 子字符串并将它包含的字符就地 升序 排序。 比方说，对下划线所示的子字符串进行操作可以由 “14234” 得到 “12344” 。 如果可以将字符串 s 变成 t ，返回 true 。否则，返回 false 。 一个 子字符串 定义为一个字符串中连续的若干字符。 示例：示例 1： 输入：s = &quot;84532&quot;, t = &quot;34852&quot; 输出：true 解释：你可以按以下操作将 s 转变为 t ： &quot;84532&quot; （从下标 2 到下标 3）-&gt; &quot;84352&quot; &quot;84352&quot; （从下标 0 到下标 2） -&gt; &quot;34852&quot; 示例 2： 输入：s = &quot;34521&quot;, t = &quot;23415&quot; 输出：true 解释：你可以按以下操作将 s 转变为 t ： &quot;34521&quot; -&gt; &quot;23451&quot; &quot;23451&quot; -&gt; &quot;23415&quot; 示例 3： 输入：s = &quot;12345&quot;, t = &quot;12435&quot; 输出：false 示例 4： 输入：s = &quot;1&quot;, t = &quot;2&quot; 输出：false 提示： s.length == t.length 1 &lt;= s.length &lt;= 105 s 和 t 都只包含数字字符，即 ‘0’ 到 ‘9’ 。 分析：将字符串排序简单化，每次只排序相邻两个字符，因为排序一整个字符串可以拆分成多次排序相邻字符 如果要将一个字符移动到后面，那么只需要看看移动的路径中是否有大于此字符的字符，若有，则不可能实现移动 只需要从后往前遍历，判断每次是否可以将最近的所需字符移动到最后即可 可以使用vector&lt;vector&gt;记录每种数字的下标组，可以节省时间 代码：class Solution { public: bool isTransformable(string s, string t) { vector&lt;vector&lt;int&gt;&gt; num(10); for(int i = 0; i &lt; s.size(); i++){ num[s[i] - &apos;0&apos;].push_back(i); } for(int i = s.size()-1; i &gt;= 0; i--){ int z = t[i] - &apos;0&apos;; if(num[z].size() == 0) return false; for(int j = z + 1; j &lt; 9; j++){ if(num[j].size() == 0) continue; if(num[j].back() &gt; num[z].back()) return false; } num[z].pop_back(); } return true; } }; 题目地址:https://leetcode-cn.com/problems/check-if-string-is-transformable-with-substring-sort-operations/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5513. 连接所有点的最小费用]]></title>
    <url>%2F2020%2F09%2F14%2Fleetcode%205513.%20%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[题目：给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。 请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。 示例：示例 1： 输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]] 输出：20 解释： 我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。 注意到任意两个点之间只有唯一一条路径互相到达。 示例 2： 输入：points = [[3,12],[-2,5],[-4,1]] 输出：18 示例 3： 输入：points = [[0,0],[1,1],[1,0],[-1,1]] 输出：4 示例 4： 输入：points = [[-1000000,-1000000],[1000000,1000000]] 输出：4000000 示例 5： 输入：points = [[0,0]] 输出：0 提示： 1 &lt;= points.length &lt;= 1000 -106 &lt;= xi, yi &lt;= 106 所有点 (xi, yi) 两两不同。 分析：将所有点之间都连上边，变成一张图，直接求出图中的最小生成树即可 代码：class Solution { public: int minCostConnectPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) { vector&lt;vector&lt;int&gt;&gt; v(points.size(), vector&lt;int&gt;(points.size(), 0)); vector&lt;int&gt; node(points.size(), 0); priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt; &gt; q; int n = 0; int ret = 0; for(int i = 0; i &lt; points.size(); i++){ for(int j = i; j &lt; points.size(); j++){ int a = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]); v[i][j] = a; v[j][i] = a; } } q.push(pair&lt;int, int&gt;{0, 0}); while(q.size()){ int a = q.top().second; int b = q.top().first; q.pop(); if(node[a] == 1) continue; node[a] = 1; for(int i = 0; i &lt; v[a].size(); i++){ if(i == a) continue; if(node[i] == 0) q.push(pair&lt;int, int&gt;{v[a][i], i}); } ret += b; n++; if(n == points.size()) return ret; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/min-cost-to-connect-all-points/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5512. 统计不开心的朋友]]></title>
    <url>%2F2020%2F09%2F14%2Fleetcode%205512.%20%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%BC%80%E5%BF%83%E7%9A%84%E6%9C%8B%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[题目：给你一份 n 位朋友的亲近程度列表，其中 n 总是 偶数 。 对每位朋友 i，preferences[i] 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 i 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 n-1 之间的整数表示。 所有的朋友被分成几对，配对情况以列表 pairs 给出，其中 pairs[i] = [xi, yi] 表示 xi 与 yi 配对，且 yi 与 xi 配对。 但是，这样的配对情况可能会是其中部分朋友感到不开心。在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心： x 与 u 的亲近程度胜过 x 与 y，且 u 与 x 的亲近程度胜过 u 与 v 返回 不开心的朋友的数目 。 示例：示例 1： 输入：n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]] 输出：2 解释： 朋友 1 不开心，因为： - 1 与 0 配对，但 1 与 3 的亲近程度比 1 与 0 高，且 - 3 与 1 的亲近程度比 3 与 2 高。 朋友 3 不开心，因为： - 3 与 2 配对，但 3 与 1 的亲近程度比 3 与 2 高，且 - 1 与 3 的亲近程度比 1 与 0 高。 朋友 0 和 2 都是开心的。 示例 2： 输入：n = 2, preferences = [[1], [0]], pairs = [[1, 0]] 输出：0 解释：朋友 0 和 1 都开心。 示例 3： 输入：n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]] 输出：4 提示： 2 &lt;= n &lt;= 500 n 是偶数 preferences.length == n preferences[i].length == n - 1 0 &lt;= preferences[i][j] &lt;= n - 1 preferences[i] 不包含 i preferences[i] 中的所有值都是独一无二的 pairs.length == n/2 pairs[i].length == 2 xi != yi 0 &lt;= xi, yi &lt;= n - 1 每位朋友都 恰好 被包含在一对中 分析：将pairs转换成 “a 的队友是 b” 通过 preferences 的定义一个数组，用以存储“a的朋友b的亲近程度” x 与 u 的亲近程度胜过 x 与 y，且u 与 x 的亲近程度胜过 u 与 v可以通过遍历preferences，判断比每一个人x的配对人y的亲近程度更高的人u与x的亲近程度是否大于u和他的配对人v，若是则x为不开心的人 代码：class Solution { public: int unhappyFriends(int n, vector&lt;vector&lt;int&gt;&gt;&amp; preferences, vector&lt;vector&lt;int&gt;&gt;&amp; pairs) { vector&lt;vector&lt;int&gt;&gt; pre(n, vector&lt;int&gt;(n, INT_MAX)); vector&lt;int&gt; frd(n); vector&lt;int&gt; v(n, 0); int ret = 0; for(int i = 0; i &lt; pairs.size(); i++){ frd[pairs[i][0]] = pairs[i][1]; frd[pairs[i][1]] = pairs[i][0]; } for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; preferences[i].size(); j++){ pre[i][preferences[i][j]] = j; } } for(int i = 0; i &lt; n; i++){ for(int j = 0; preferences[i][j] != frd[i]; j++){ if(pre[preferences[i][j]][i] &lt; pre[preferences[i][j]][frd[preferences[i][j]]]){ ret++; break; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-unhappy-friends/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5511. 二进制矩阵中的特殊位置]]></title>
    <url>%2F2020%2F09%2F14%2Fleetcode%205511.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个大小为 rows x cols 的矩阵 mat，其中 mat[i][j] 是 0 或 1，请返回 矩阵 mat 中特殊位置的数目 。 特殊位置 定义：如果 mat[i][j] == 1 并且第 i 行和第 j 列中的所有其他元素均为 0（行和列的下标均 从 0 开始 ），则位置 (i, j) 被称为特殊位置。 示例：示例 1： 输入：mat = [[1,0,0], [0,0,1], [1,0,0]] 输出：1 解释：(1,2) 是一个特殊位置，因为 mat[1][2] == 1 且所处的行和列上所有其他元素都是 0 示例 2： 输入：mat = [[1,0,0], [0,1,0], [0,0,1]] 输出：3 解释：(0,0), (1,1) 和 (2,2) 都是特殊位置 示例 3： 输入：mat = [[0,0,0,1], [1,0,0,0], [0,1,1,0], [0,0,0,0]] 输出：2 示例 4： 输入：mat = [[0,0,0,0,0], [1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0], [0,0,0,1,1]] 输出：3 提示： rows == mat.length cols == mat[i].length 1 &lt;= rows, cols &lt;= 100 mat[i][j] 是 0 或 1 分析：判断每行每列的1的数量，遍历每个位置，如果当前行当前列各有一个1，并且当前位置也为1，那么这个位置是特殊位置 代码：class Solution { public: int numSpecial(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { map&lt;int, int&gt; m1; map&lt;int, int&gt; m2; int ret = 0; for(int i = 0; i &lt; mat.size(); i++){ for(int j = 0; j &lt; mat[0].size(); j++){ if(mat[i][j] == 1) m1[i]++; } } for(int i = 0; i &lt; mat[0].size(); i++){ for(int j = 0; j &lt; mat.size(); j++){ if(mat[j][i] == 1) m2[i]++; } } for(int i = 0; i &lt; mat.size(); i++){ for(int j = 0; j &lt; mat[0].size(); j++){ if(m1[i] == 1 &amp;&amp; m2[j] == 1 &amp;&amp; mat[i][j] == 1) ret++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1579. 保证图可完全遍历]]></title>
    <url>%2F2020%2F09%2F07%2Fleetcode%201579.%20%E4%BF%9D%E8%AF%81%E5%9B%BE%E5%8F%AF%E5%AE%8C%E5%85%A8%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[题目：Alice 和 Bob 共有一个无向图，其中包含 n 个节点和 3 种类型的边： 类型 1：只能由 Alice 遍历。 类型 2：只能由 Bob 遍历。 类型 3：Alice 和 Bob 都可以遍历。 给你一个数组 edges ，其中 edges[i] = [typei, ui, vi] 表示节点 ui 和 vi 之间存在类型为 typei 的双向边。请你在保证图仍能够被 Alice和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。 返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。 示例：示例 1： 输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,3],[1,2,4],[1,1,2],[2,3,4]] 输出：2 解释：如果删除 [1,1,2] 和 [1,1,3] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 2 。 示例 2： 输入：n = 4, edges = [[3,1,2],[3,2,3],[1,1,4],[2,1,4]] 输出：0 解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。 示例 3： 输入：n = 4, edges = [[3,2,3],[1,1,2],[2,3,4]] 输出：-1 解释：在当前图中，Alice 无法从其他节点到达节点 4 。类似地，Bob 也不能达到节点 1 。因此，图无法完全遍历。 提示： 1 &lt;= n &lt;= 10^5 1 &lt;= edges.length &lt;= min(10^5, 3 n (n-1) / 2) edges[i].length == 3 1 &lt;= edges[i][0] &lt;= 3 1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n 所有元组 (typei, ui, vi) 互不相同 分析：先使用bfs来判断Alice和Bob是否可以遍历全图，不行就直接返回-1 只考虑类型3的边，使用bfs将边删至最简，得到最少的类型3的边的数量 sum 因为Alice和Bob遍历全部的结点最少需要（n-1）*2条边。他们可以共用类型3的边，那么需要（n-1）*2 - sum 条边 需要删除的边就为 总边数 - （（n-1）*2 - sum） 条 O(n) 的复杂度理论上可以过，但不知道什么c++最后一个例子超时了 代码：class Solution { public: int bfs(int n, unordered_map&lt;int, vector&lt;int&gt;&gt;&amp; m1, vector&lt;bool&gt;&amp; m){ queue&lt;int&gt; q; q.push(n); while(q.size()){ int z = q.front(); q.pop(); if(m[z]) continue; m[z] = true; for(int a : m1[z]){ q.push(a); } } int ret = 0; for(int i = 1; i &lt; m.size(); i++){ if(m[i]) ret++; } return ret; } int maxNumEdgesToRemove(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { int ret = 0; unordered_map &lt;int, vector&lt;int&gt;&gt; m1; unordered_map &lt;int, vector&lt;int&gt;&gt; m2; unordered_map &lt;int, vector&lt;int&gt;&gt; m3; for(vector&lt;int&gt;&amp; edge : edges){ if(edge[0] == 1){ m1[edge[1]].push_back(edge[2]); m1[edge[2]].push_back(edge[1]); } else if(edge[0] == 2){ m2[edge[1]].push_back(edge[2]); m2[edge[2]].push_back(edge[1]); } else{ m1[edge[1]].push_back(edge[2]); m1[edge[2]].push_back(edge[1]); m2[edge[1]].push_back(edge[2]); m2[edge[2]].push_back(edge[1]); m3[edge[1]].push_back(edge[2]); m3[edge[2]].push_back(edge[1]); } } vector&lt;bool&gt; mi1(n+1, false); vector&lt;bool&gt; mi2(n+1, false); vector&lt;bool&gt; mi3(n+1, false); if(bfs(1, m1, mi1) != n) return -1; if(bfs(1, m2, mi2) != n) return -1; int b = 0; int z = 0; for(int i = 1; i &lt;= n; i++){ if(!mi3[i]){ b = b - z; z = bfs(i, m3, mi3); b = b + z-1; } } return edges.size() - ((n-1)*2-b); } }; 题目地址:https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1578. 避免重复字母的最小删除成本]]></title>
    <url>%2F2020%2F09%2F07%2Fleetcode%201578.%20%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E5%88%A0%E9%99%A4%E6%88%90%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s 和一个整数数组 cost ，其中 cost[i] 是从 s 中删除字符 i 的代价。 返回使字符串任意相邻两个字母不相同的最小删除成本。 请注意，删除一个字符后，删除其他字符的成本不会改变。 示例：示例 1： 输入：s = &quot;abaac&quot;, cost = [1,2,3,4,5] 输出：3 解释：删除字母 &quot;a&quot; 的成本为 3，然后得到 &quot;abac&quot;（字符串中相邻两个字母不相同）。 示例 2： 输入：s = &quot;abc&quot;, cost = [1,2,3] 输出：0 解释：无需删除任何字母，因为字符串中不存在相邻两个字母相同的情况。 示例 3： 输入：s = &quot;aabaa&quot;, cost = [1,2,3,4,1] 输出：2 解释：删除第一个和最后一个字母，得到字符串 (&quot;aba&quot;) 。 提示： s.length == cost.length 1 &lt;= s.length, cost.length &lt;= 10^5 1 &lt;= cost[i] &lt;= 10^4 s 中只含有小写英文字母 分析：遍历字符串，当有两个相邻并且相同的字母时，删除成本低的那个（因为不需要返还删除后的字符串，可以将成本高的放在后面，这样下次如果还是相同，判断的就是成本高的那个，起到的删除字符一样的效果） 代码：class Solution { public: int minCost(string s, vector&lt;int&gt;&amp; cost) { int ret = 0; for(int i = 1; i &lt; s.size(); i++){ if(s[i] == s[i-1]){ if(cost[i] &lt; cost[i-1]){ ret += cost[i]; cost[i] = cost[i-1]; } else{ ret += cost[i-1]; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1577. 数的平方等于两数乘积的方法数]]></title>
    <url>%2F2020%2F09%2F07%2Fleetcode%201577.%20%E6%95%B0%E7%9A%84%E5%B9%B3%E6%96%B9%E7%AD%89%E4%BA%8E%E4%B8%A4%E6%95%B0%E4%B9%98%E7%A7%AF%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你两个整数数组 nums1 和 nums2 ，请你返回根据以下规则形成的三元组的数目（类型 1 和类型 2 ）： 类型 1：三元组 (i, j, k) ，如果 nums1[i]2 == nums2[j] * nums2[k] 其中 0 &lt;= i &lt; nums1.length 且 0 &lt;= j &lt; k &lt; nums2.length 类型 2：三元组 (i, j, k) ，如果 nums2[i]2 == nums1[j] * nums1[k] 其中 0 &lt;= i &lt; nums2.length 且 0 &lt;= j &lt; k &lt; nums1.length 示例：示例 1： 输入：nums1 = [7,4], nums2 = [5,2,8,9] 输出：1 解释：类型 1：(1,1,2), nums1[1]^2 = nums2[1] * nums2[2] (4^2 = 2 * 8) 示例 2： 输入：nums1 = [1,1], nums2 = [1,1,1] 输出：9 解释：所有三元组都符合题目要求，因为 1^2 = 1 * 1 类型 1：(0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2), nums1[i]^2 = nums2[j] * nums2[k] 类型 2：(0,0,1), (1,0,1), (2,0,1), nums2[i]^2 = nums1[j] * nums1[k] 示例 3： 输入：nums1 = [7,7,8,3], nums2 = [1,2,9,7] 输出：2 解释：有两个符合题目要求的三元组 类型 1：(3,0,2), nums1[3]^2 = nums2[0] * nums2[2] 类型 2：(3,0,1), nums2[3]^2 = nums1[0] * nums1[1] 示例 4： 输入：nums1 = [4,7,9,11,23], nums2 = [3,5,1024,12,18] 输出：0 解释：不存在符合题目要求的三元组 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 1 &lt;= nums1[i], nums2[i] &lt;= 10^5 分析：使用map记录两个整数数组中的乘积 遍历两个整数数组，和对应的数组的map比较，看是否有相同的数 代码：class Solution { public: int numTriplets(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_map&lt;long, int&gt; m1; unordered_map&lt;long, int&gt; m2; int ret = 0; for(int i = 0; i &lt; nums1.size(); i++){ for(int j = i+1; j &lt; nums1.size(); j++){ m1[(long)nums1[i] * nums1[j]]++; } } for(int i = 0; i &lt; nums2.size(); i++){ for(int j = i+1; j &lt; nums2.size(); j++){ m2[(long)nums2[i] * nums2[j]]++; } } for(int i = 0; i &lt; nums1.size(); i++){ if(m2.count((long)nums1[i] * nums1[i])) ret += m2[(long)nums1[i] * nums1[i]]; } for(int i = 0; i &lt; nums2.size(); i++){ if(m1.count((long)nums2[i] * nums2[i])) ret += m1[(long)nums2[i] * nums2[i]]; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1576. 替换所有的问号]]></title>
    <url>%2F2020%2F09%2F07%2Fleetcode%201576.%20%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目：给你一个仅包含小写英文字母和 ‘?’ 字符的字符串 s ，请你将所有的 ‘?’ 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。 注意：你 不能 修改非 ‘?’ 字符。 题目测试用例保证 除 ‘?’ 字符 之外，不存在连续重复的字符。 在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。 示例：示例 1： 输入：s = &quot;?zs&quot; 输出：&quot;azs&quot; 解释：该示例共有 25 种解决方案，从 &quot;azs&quot; 到 &quot;yzs&quot; 都是符合题目要求的。只有 &quot;z&quot; 是无效的修改，因为字符串 &quot;zzs&quot; 中有连续重复的两个 &apos;z&apos; 。 示例 2： 输入：s = &quot;ubv?w&quot; 输出：&quot;ubvaw&quot; 解释：该示例共有 24 种解决方案，只有替换成 &quot;v&quot; 和 &quot;w&quot; 不符合题目要求。因为 &quot;ubvvw&quot; 和 &quot;ubvww&quot; 都包含连续重复的字符。 示例 3： 输入：s = &quot;j?qg??b&quot; 输出：&quot;jaqgacb&quot; 示例 4： 输入：s = &quot;??yw?ipkj?&quot; 输出：&quot;acywaipkja&quot; 提示： 1 &lt;= s.length &lt;= 100 s 仅包含小写英文字母和 ‘?’ 字符 分析：对每个 ? 分析左右侧的字母，填入合适的字母即可 代码：class Solution { public: string modifyString(string s) { if(s.size() == 0) return s; if(s.size() == 1){ if(s[0] == &apos;?&apos;){ s[0] = &apos;a&apos;; return s; } return s; } if(s[0] == &apos;?&apos;){ for(int i = 0; i &lt; 24; i++){ if(&apos;a&apos; + i != s[1]){ s[0] = &apos;a&apos; + i; break; } } } for(int i = 1; i &lt; s.size()-1; i++){ if(s[i] == &apos;?&apos;){ for(int j = 0; j &lt; 24; j++){ if(&apos;a&apos; + j != s[i-1] &amp;&amp; &apos;a&apos; + j != s[i+1]){ s[i] = &apos;a&apos; + j; break; } } } } if(s[s.size()-1] == &apos;?&apos;){ for(int i = 0; i &lt; 24; i++){ if(&apos;a&apos; + i != s[s.size()-2]){ s[s.size()-1] = &apos;a&apos; + i; break; } } } return s; } }; 题目地址:https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1569. 将子数组重新排序得到同一个二叉查找树的方案数]]></title>
    <url>%2F2020%2F08%2F31%2Fleetcode%201569.%20%E5%B0%86%E5%AD%90%E6%95%B0%E7%BB%84%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 nums 表示 1 到 n 的一个排列。我们按照元素在 nums 中的顺序依次插入一个初始为空的二叉查找树（BST）。请你统计将 nums 重新排序后，统计满足如下条件的方案数：重排后得到的二叉查找树与 nums 原本数字顺序得到的二叉查找树相同。 比方说，给你 nums = [2,1,3]，我们得到一棵 2 为根，1 为左孩子，3 为右孩子的树。数组 [2,3,1] 也能得到相同的 BST，但 [3,2,1] 会得到一棵不同的 BST 。 请你返回重排 nums 后，与原数组 nums 得到相同二叉查找树的方案数。 由于答案可能会很大，请将结果对 10^9 + 7 取余数。 示例：示例 1： 输入：nums = [2,1,3] 输出：1 解释：我们将 nums 重排， [2,3,1] 能得到相同的 BST 。没有其他得到相同 BST 的方案了。 示例 2： 输入：nums = [3,4,5,1,2] 输出：5 解释：下面 5 个数组会得到相同的 BST： [3,1,2,4,5] [3,1,4,2,5] [3,1,4,5,2] [3,4,1,2,5] [3,4,1,5,2] 示例 3： 输入：nums = [1,2,3] 输出：0 解释：没有别的排列顺序能得到相同的 BST 。 示例 4： 输入：nums = [3,1,2,5,4,6] 输出：19 示例 5： 输入：nums = [9,4,2,1,3,6,5,7,8,14,11,10,12,13,16,15,17,18] 输出：216212978 解释：得到相同 BST 的方案数是 3216212999。将它对 10^9 + 7 取余后得到 216212978。 提示： 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= nums.length nums 中所有数 互不相同 。 分析：对于一个数组，确定根结点后，右子树和左子树之间的位置可以交换而不会影响到最后生成的二叉查找树，方法数就为C（n，n+m）（n+m中取n个方法数）* dg(left) * dg(right) （左子树和右子树递归求解），最后减去自身 预处理1000以内组合的数量C（n，m）= C（n-1，m-1）+ C（n，m-1） 视频：https://www.bilibili.com/video/BV1j5411b7gn?from=search&amp;seid=1509420205452868671​ 代码：class Solution { private: int c[1001][1001]; public: int dg(vector&lt;int&gt;&amp; v){ if(v.size() == 0) return 1; vector&lt;int&gt; l; vector&lt;int&gt; r; for(int i = 1; i &lt; v.size(); i++){ if(v[i] &gt; v[0]) r.push_back(v[i]); else l.push_back(v[i]); } return (long long)c[v.size()-1][l.size()] * dg(l) % 1000000007 * dg(r) % 1000000007; } int numOfWays(vector&lt;int&gt;&amp; nums) { for(int i = 0; i &lt;= nums.size(); i++){ for(int j = 0; j &lt;= i; j++){ if(j == 0) c[i][j] = 1; else c[i][j] = (c[i-1][j-1] + c[i-1][j]) % 1000000007; } } return dg(nums)-1; } }; 题目地址:https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1568. 使陆地分离的最少天数]]></title>
    <url>%2F2020%2F08%2F31%2Fleetcode%201568.%20%E4%BD%BF%E9%99%86%E5%9C%B0%E5%88%86%E7%A6%BB%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个由若干 0 和 1 组成的二维网格 grid ，其中 0 表示水，而 1 表示陆地。岛屿由水平方向或竖直方向上相邻的 1 （陆地）连接形成。 如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。 一天内，可以将任何单个陆地单元（1）更改为水单元（0）。 返回使陆地分离的最少天数。 示例：示例 1： 输入：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]] 输出：2 解释：至少需要 2 天才能得到分离的陆地。 将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。 示例 2： 输入：grid = [[1,1]] 输出：2 解释：如果网格中都是水，也认为是分离的 ([[1,1]] -&gt; [[0,0]])，0 岛屿。 示例 3： 输入：grid = [[1,0,1,0]] 输出：0 示例 4： 输入：grid = [[1,1,0,1,1], [1,1,1,1,1], [1,1,0,1,1], [1,1,0,1,1]] 输出：1 示例 5： 输入：grid = [[1,1,0,1,1], [1,1,1,1,1], [1,1,0,1,1], [1,1,1,1,1]] 输出：2 提示： 1 &lt;= grid.length, grid[i].length &lt;= 30 grid[i][j] 为 0 或 1 分析：在角上的格子最多只需要两次删除即可使陆地分离，所以只需要将每个格子都尝试删除一遍即可。注意有些特殊情况可以直接输出 代码：class Solution { public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; g, int x, int y, int&amp; z){ if(g[x][y] == 1){ z++; g[x][y] = 0; } else return; if(x-1 &gt;= 0) dfs(g, x-1, y, z); if(x+1 &lt; g.size()) dfs(g, x+1, y, z); if(y-1 &gt;= 0) dfs(g, x, y-1, z); if(y+1 &lt; g[0].size()) dfs(g, x, y+1, z); } int minDays(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int x1 = -1; int y1 = -1; int x2 = -1; int y2 = -1; int q = 0; for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ if(grid[i][j] == 1){ q++; if(x1 == -1){ x1 = i; y1 = j; } else if(x2 == -1){ x2 = i; y2 = j; } } } } if(q == 0) return 0; if(q == 1) return 1; int z = 0; vector&lt;vector&lt;int&gt;&gt; g = grid; if(g[x1][y1] != 0) dfs(g, x1, y1, z); else dfs(g, x2, y2, z); if(z != q) return 0; for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ if(grid[i][j] == 0) continue; g = grid; g[i][j] = 0; z = 0; if(g[x1][y1] != 0) dfs(g, x1, y1, z); else dfs(g, x2, y2, z); if(q-1 != z) return 1; } } return 2; } }; 题目地址:https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1566. 重复至少 K 次且长度为 M 的模式]]></title>
    <url>%2F2020%2F08%2F31%2Fleetcode%201566.%20%E9%87%8D%E5%A4%8D%E8%87%B3%E5%B0%91%20K%20%E6%AC%A1%E4%B8%94%E9%95%BF%E5%BA%A6%E4%B8%BA%20M%20%E7%9A%84%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题目：给你一个正整数数组 arr，请你找出一个长度为 m 且在数组中至少重复 k 次的模式。 模式 是由一个或多个值组成的子数组（连续的子序列），连续 重复多次但 不重叠 。 模式由其长度和重复次数定义。 如果数组中存在至少重复 k 次且长度为 m 的模式，则返回 true ，否则返回 false 。 示例：示例 1： 输入：arr = [1,2,4,4,4,4], m = 1, k = 3 输出：true 解释：模式 (4) 的长度为 1 ，且连续重复 4 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。 示例 2： 输入：arr = [1,2,1,2,1,1,1,3], m = 2, k = 2 输出：true 解释：模式 (1,2) 长度为 2 ，且连续重复 2 次。另一个符合题意的模式是 (2,1) ，同样重复 2 次。 示例 3： 输入：arr = [1,2,1,2,1,3], m = 2, k = 3 输出：false 解释：模式 (1,2) 长度为 2 ，但是只连续重复 2 次。不存在长度为 2 且至少重复 3 次的模式。 示例 4： 输入：arr = [1,2,3,1,2], m = 2, k = 2 输出：false 解释：模式 (1,2) 出现 2 次但并不连续，所以不能算作连续重复 2 次。 示例 5： 输入：arr = [2,2,2,2], m = 2, k = 3 输出：false 解释：长度为 2 的模式只有 (2,2) ，但是只连续重复 2 次。注意，不能计算重叠的重复次数。 提示： 2 &lt;= arr.length &lt;= 100 1 &lt;= arr[i] &lt;= 100 1 &lt;= m &lt;= 100 2 &lt;= k &lt;= 100 分析：直接暴力枚举，每次取m个元素比较k次 代码：class Solution { public: bool containsPattern(vector&lt;int&gt;&amp; arr, int m, int k) { vector&lt;int&gt; v; int z = 0; for(int i = 0; i+m-1 &lt; arr.size(); i++){ v.assign(arr.begin()+i, arr.begin()+i+m); for(int j = i; j+m-1 &lt; arr.size(); j++){ vector&lt;int&gt; v1; v1.assign(arr.begin()+j, arr.begin()+j+m); if(v == v1){ z++; j += m-1; if(z == k) return true; } else{ break; } } z = 0; } return false; } }; 题目地址:https://leetcode-cn.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1567. 乘积为正数的最长子数组长度]]></title>
    <url>%2F2020%2F08%2F31%2Fleetcode%201567.%20%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。 一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。 请你返回乘积为正数的最长子数组长度。 示例：示例 1： 输入：nums = [1,-2,-3,4] 输出：4 解释：数组本身乘积就是正数，值为 24 。 示例 2： 输入：nums = [0,1,-2,-3,-4] 输出：3 解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。 注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。 示例 3： 输入：nums = [-1,-2,-3,0,1] 输出：2 解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。 示例 4： 输入：nums = [-1,2] 输出：1 示例 5： 输入：nums = [1,2,3,5,-6,4,0,10] 输出：4 提示： 1 &lt;= nums.length &lt;= 10^5 -10^9 &lt;= nums[i] &lt;= 10^9 分析：记录连续的正数数量z和连续带负数的数量f，在设一个b记录负数个数 遇到正数，z++,f++ 遇到负数，f++，并且看是否有偶数个负数，如果有z = f，并且将b置为false 遇到0，全部清空 这样的步骤反着再遍历一遍，因为这个方法遇到奇数个负数时不会考虑第一个负数之间内容，反着遍历一遍可以避免这个问题 代码：class Solution { public: int getMaxLen(vector&lt;int&gt;&amp; nums) { int z = 0; // 只包含正数 int f = 0; // 包含负数 bool b = false; // false表示负数为0，true表示负数为1 int ret = 0; // 返回结果 for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] &gt; 0){ z++; f++; } else if(nums[i] &lt; 0){ f++; z = 0; if(b == false) b = true; else{ b = false; z = f; } } else{ z = 0; f = 0; b = false; } ret = max(ret, z); } z = 0; f = 0; b = false; for(int i = nums.size()-1; i &gt;= 0; i--){ if(nums[i] &gt; 0){ z++; f++; } else if(nums[i] &lt; 0){ f++; z = 0; if(b == false) b = true; else{ b = false; z = f; } } else{ z = 0; f = 0; b = false; } ret = max(ret, z); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1563. 石子游戏 V]]></title>
    <url>%2F2020%2F08%2F24%2Fleetcode%201563.%20%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%20V%2F</url>
    <content type="text"><![CDATA[题目：几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。 游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。 只 剩下一块石子 时，游戏结束。Alice 的分数最初为 0 。 返回 Alice 能够获得的最大分数 。 示例：示例 1： 输入：stoneValue = [6,2,3,4,5,5] 输出：18 解释：在第一轮中，Alice 将行划分为 [6，2，3]，[4，5，5] 。左行的值是 11 ，右行的值是 14 。Bob 丢弃了右行，Alice 的分数现在是 11 。 在第二轮中，Alice 将行分成 [6]，[2，3] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 16（11 + 5）。 最后一轮 Alice 只能将行分成 [2]，[3] 。Bob 扔掉右行，Alice 的分数现在是 18（16 + 2）。游戏结束，因为这行只剩下一块石头了。 示例 2： 输入：stoneValue = [7,7,7,7,7,7,7] 输出：28 示例 3： 输入：stoneValue = [4] 输出：0 提示： 1 &lt;= stoneValue.length &lt;= 500 1 &lt;= stoneValue[i] &lt;= 10^6 分析：使用dfs和记忆化 遍历每一种可能性，使用记忆化来减少重复运算 代码：class Solution { private: public: int dfs(vector&lt;int&gt;&amp; stoneValue, vector&lt;vector&lt;int&gt;&gt;&amp; dp, vector&lt;int&gt;&amp; q, int l, int r){ if(dp[l][r] != -1) return dp[l][r]; if(l == r) return 0; int m = 0; for(int i = l; i &lt; r; i++){ int l1 = q[i] - (l-1 &gt;= 0 ? q[l-1] : 0); int r1 = q[r] - q[i]; if(l1 &lt; r1){ m = max(m, dfs(stoneValue, dp, q, l, i) + l1); } else if(l1 &gt; r1){ m = max(m, dfs(stoneValue, dp, q, i+1, r) + r1); } else{ m = max(m, dfs(stoneValue, dp, q, l, i) + l1); m = max(m, dfs(stoneValue, dp, q, i+1, r) + r1); } } dp[l][r] = m; return m; } int stoneGameV(vector&lt;int&gt;&amp; stoneValue) { vector&lt;int&gt; q(stoneValue.size(), 0); vector&lt;vector&lt;int&gt;&gt; dp(stoneValue.size(), vector&lt;int&gt;(stoneValue.size(), -1)); q[0] = stoneValue[0]; for(int i = 1; i &lt; stoneValue.size(); i++){ q[i] = q[i-1] + stoneValue[i]; } return dfs(stoneValue, dp, q, 0, stoneValue.size()-1); } }; 题目地址:https://leetcode-cn.com/problems/stone-game-v/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1562. 查找大小为 M 的最新分组]]></title>
    <url>%2F2020%2F08%2F24%2Fleetcode%201562.%20%E6%9F%A5%E6%89%BE%E5%A4%A7%E5%B0%8F%E4%B8%BA%20M%20%E7%9A%84%E6%9C%80%E6%96%B0%E5%88%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 arr ，该数组表示一个从 1 到 n 的数字排列。有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0 。 在从 1 到 n 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置 arr[i] 的位将会设为 1 。 给你一个整数 m ，请你找出二进制字符串上存在长度为 m 的一组 1 的最后步骤。一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1 。 返回存在长度 恰好 为 m 的 一组 1 的最后步骤。如果不存在这样的步骤，请返回 -1 。 示例：示例 1： 输入：arr = [3,5,1,2,4], m = 1 输出：4 解释： 步骤 1：&quot;00100&quot;，由 1 构成的组：[&quot;1&quot;] 步骤 2：&quot;00101&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;] 步骤 3：&quot;10101&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;] 步骤 4：&quot;11101&quot;，由 1 构成的组：[&quot;111&quot;, &quot;1&quot;] 步骤 5：&quot;11111&quot;，由 1 构成的组：[&quot;11111&quot;] 存在长度为 1 的一组 1 的最后步骤是步骤 4 。 示例 2： 输入：arr = [3,1,5,4,2], m = 2 输出：-1 解释： 步骤 1：&quot;00100&quot;，由 1 构成的组：[&quot;1&quot;] 步骤 2：&quot;10100&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;] 步骤 3：&quot;10101&quot;，由 1 构成的组：[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;] 步骤 4：&quot;10111&quot;，由 1 构成的组：[&quot;1&quot;, &quot;111&quot;] 步骤 5：&quot;11111&quot;，由 1 构成的组：[&quot;11111&quot;] 不管是哪一步骤都无法形成长度为 2 的一组 1 。 示例 3： 输入：arr = [1], m = 1 输出：1 示例 4： 输入：arr = [2,1], m = 2 输出：2 提示： n == arr.length 1 &lt;= n &lt;= 10^5 1 &lt;= arr[i] &lt;= n arr 中的所有整数 互不相同 1 &lt;= m &lt;= arr.length 分析：使用两个map用来存储连续1的左边界和右边界 每次添加新的1时，查看左右是否有连续的1，若有，则合并。 中途记录最后拥有m个1的步骤即可 代码：class Solution { public: int findLatestStep(vector&lt;int&gt;&amp; arr, int m) { unordered_map&lt;int, int&gt; ml; unordered_map&lt;int, int&gt; mr; int z = 0; int ret = -1; for(int i = 0; i &lt; arr.size(); i++){ int l = arr[i]; int r = arr[i]; int c = 1; if(ml.count(arr[i]-1)){ l = arr[i] - ml[arr[i]-1]; c += ml[arr[i]-1]; } if(mr.count(arr[i]+1)){ r = arr[i] + mr[arr[i]+1]; c += mr[arr[i]+1]; } mr[l] = c; ml[r] = c; if(c == m) z++; if(ml[arr[i]-1] == m) z--; if(mr[arr[i]+1] == m) z--; if(z != 0) ret = i+1; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-latest-group-of-size-m/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1561. 你可以获得的最大硬币数目]]></title>
    <url>%2F2020%2F08%2F24%2Fleetcode%201561.%20%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%A1%AC%E5%B8%81%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币： 每一轮中，你将会选出 任意 3 堆硬币（不一定连续）。 Alice 将会取走硬币数量最多的那一堆。 你将会取走硬币数量第二多的那一堆。 Bob 将会取走最后一堆。 重复这个过程，直到没有更多硬币。 给你一个整数数组 piles ，其中 piles[i] 是第 i 堆中硬币的数目。 返回你可以获得的最大硬币数目。 示例：示例 1： 输入：piles = [2,4,1,2,7,8] 输出：9 解释：选出 (2, 7, 8) ，Alice 取走 8 枚硬币的那堆，你取走 7 枚硬币的那堆，Bob 取走最后一堆。 选出 (1, 2, 4) , Alice 取走 4 枚硬币的那堆，你取走 2 枚硬币的那堆，Bob 取走最后一堆。 你可以获得的最大硬币数目：7 + 2 = 9. 考虑另外一种情况，如果选出的是 (1, 2, 8) 和 (2, 4, 7) ，你就只能得到 2 + 4 = 6 枚硬币，这不是最优解。 示例 2： 输入：piles = [2,4,5] 输出：4 示例 3： 输入：piles = [9,8,7,6,5,1,2,3,4] 输出：18 提示： 3 &lt;= piles.length &lt;= 10^5 piles.length % 3 == 0 1 &lt;= piles[i] &lt;= 10^4 分析：每次都选第一多第二多和最少的硬币堆，将所有第二多的硬币相加即可 代码：class Solution { public: int maxCoins(vector&lt;int&gt;&amp; piles) { sort(piles.begin(), piles.end()); int ret = 0; for(int l = 0, r = piles.size()-1; l &lt; r; l++, r-=2){ ret += piles[r-1]; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1560. 圆形赛道上经过次数最多的扇区]]></title>
    <url>%2F2020%2F08%2F24%2Fleetcode%201560.%20%E5%9C%86%E5%BD%A2%E8%B5%9B%E9%81%93%E4%B8%8A%E7%BB%8F%E8%BF%87%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%89%87%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n 和一个整数数组 rounds 。有一条圆形赛道由 n 个扇区组成，扇区编号从 1 到 n 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 m 个阶段组成。其中，第 i 个阶段将会从扇区 rounds[i - 1] 开始，到扇区 rounds[i] 结束。举例来说，第 1 阶段从 rounds[0] 开始，到 rounds[1] 结束。 请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 升序 排列。 注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。 示例：示例 1： 输入：n = 4, rounds = [1,3,1,2] 输出：[1,2] 解释：本场马拉松比赛从扇区 1 开始。经过各个扇区的次序如下所示： 1 --&gt; 2 --&gt; 3（阶段 1 结束）--&gt; 4 --&gt; 1（阶段 2 结束）--&gt; 2（阶段 3 结束，即本场马拉松结束） 其中，扇区 1 和 2 都经过了两次，它们是经过次数最多的两个扇区。扇区 3 和 4 都只经过了一次。 示例 2： 输入：n = 2, rounds = [2,1,2,1,2,1,2,1,2] 输出：[2] 示例 3： 输入：n = 7, rounds = [1,3,5,7] 输出：[1,2,3,4,5,6,7] 提示： 2 &lt;= n &lt;= 100 1 &lt;= m &lt;= 100 rounds.length == m + 1 1 &lt;= rounds[i] &lt;= n rounds[i] != rounds[i + 1] ，其中 0 &lt;= i &lt; m 分析：统计路过的所有扇区的数量，找出其中最多的即可。注意需要用取余 代码：class Solution { public: vector&lt;int&gt; mostVisited(int n, vector&lt;int&gt;&amp; rounds) { vector&lt;int&gt; v(n+1, 0); v[rounds[0]]++; for(int i = 1; i &lt; rounds.size(); i++){ for(int j = (rounds[i-1]+1)%(n+1); j != (rounds[i]+1)%(n+1); j = (j+1)%(n+1)){ if(j == 0) continue; v[j]++; } } vector&lt;int&gt; ret; int z = 0; for(int i = 0; i &lt; n+1; i++){ if(z &lt; v[i]){ z = v[i]; ret.clear(); ret.push_back(i); } else if(z == v[i]) ret.push_back(i); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1547. 切棍子的最小成本]]></title>
    <url>%2F2020%2F08%2F10%2Fleetcode%201547.%20%E5%88%87%E6%A3%8D%E5%AD%90%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[题目：有一根长度为 n 个单位的木棍，棍上从 0 到 n 标记了若干位置。例如，长度为 6 的棍子可以标记如下： 给你一个整数数组 cuts ，其中 cuts[i] 表示你需要将棍子切开的位置。 你可以按顺序完成切割，也可以根据需要更改切割的顺序。 每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。 返回切棍子的 最小总成本 。 示例：示例 1： 输入：n = 7, cuts = [1,3,4,5] 输出：16 解释：按 [1, 3, 4, 5] 的顺序切割的情况如下所示： 第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 = 20 。 而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。 示例 2： 输入：n = 9, cuts = [5,6,1,4,2] 输出：22 解释：如果按给定的顺序切割，则总成本为 25 。总成本 &lt;= 25 的切割顺序很多，例如，[4，6，5，2，1] 的总成本 = 22，是所有可能方案中成本最小的。 提示： 2 &lt;= n &lt;= 10^6 1 &lt;= cuts.length &lt;= min(n - 1, 100) 1 &lt;= cuts[i] &lt;= n - 1 cuts 数组中的所有整数都 互不相同 分析：使用dp 往cuts中添加0和cuts.size()-1，排序 dp[i][j] 表示从i到j段的木头切割需要的成本 dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i]) (k表示从i到j的数) 初始化 dp[i][i+1] = 0; 代码：class Solution { public: int minCost(int n, vector&lt;int&gt;&amp; cuts) { cuts.push_back(n); cuts.push_back(0); vector&lt;vector&lt;int&gt;&gt; dp(cuts.size(), vector&lt;int&gt;(cuts.size(), INT_MAX)); sort(cuts.begin(), cuts.end()); for(int i = 1; i &lt; cuts.size(); i++){ dp[i-1][i] = 0; } for(int i = 1; i &lt; cuts.size(); i++){ for(int j = i-1; j &gt;= 0; j--){ for(int k = i-1; k &gt; j; k--){ dp[j][i] = min(dp[j][i], dp[j][k] + dp[k][i] + cuts[i] - cuts[j]); } } } return dp[0][cuts.size()-1]; } }; 题目地址:https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1546. 和为目标值的最大数目不重叠非空子数组数目]]></title>
    <url>%2F2020%2F08%2F10%2Fleetcode%201546.%20%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE%E4%B8%8D%E9%87%8D%E5%8F%A0%E9%9D%9E%E7%A9%BA%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 nums 和一个整数 target 。 请你返回 非空不重叠 子数组的最大数目，且每个子数组中数字和都为 target 。 示例：示例 1： 输入：nums = [1,1,1,1,1], target = 2 输出：2 解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 。 示例 2： 输入：nums = [-1,3,5,1,4,2,-9], target = 6 输出：2 解释：总共有 3 个子数组和为 6 。 ([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。 示例 3： 输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10 输出：3 示例 4： 输入：nums = [0,0,0], target = 0 输出：3 提示： 1 &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 0 &lt;= target &lt;= 10^6 分析：申明数组 前缀和 v 使用map记录前缀和以及下标 使用 z 来记录最后一个子数组的结尾下标 遍历数组，对每一个数i进行运算 v[i] - target，判断map中是否有运算结果： 有，判断起始下标是否大于结尾下标： 大于 ret++ 小于 忽视（因为如果小于就会覆盖之前的子数组，没有必要） 没有，说明无法组成和为target的子数组，忽视 代码：class Solution { public: int maxNonOverlapping(vector&lt;int&gt;&amp; nums, int target) { map&lt;int, int&gt; m; m[0] = -1; int z = -1; vector&lt;int&gt; v; v.push_back(nums[0]); int ret = 0; for(int i = 1; i &lt; nums.size(); i++) v.push_back(v[v.size()-1]+nums[i]); for(int i = 0; i &lt; nums.size(); i++){ if(m.count(v[i] - target) == 1 &amp;&amp; m[v[i] - target]+1 &gt; z){ ret++; z = i; } m[v[i]] = i; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1545. 找出第 N 个二进制字符串中的第 K 位]]></title>
    <url>%2F2020%2F08%2F10%2Fleetcode%201545.%20%E6%89%BE%E5%87%BA%E7%AC%AC%20N%20%E4%B8%AA%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%20K%20%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[题目：给你两个正整数 n 和 k，二进制字符串 Sn 的形成规则如下： S1 = “0”当 i &gt; 1 时，Si = Si-1 + “1” + reverse(invert(Si-1))其中 + 表示串联操作，reverse(x) 返回反转 x 后得到的字符串，而 invert(x) 则会翻转 x 中的每一位（0 变为 1，而 1 变为 0） 例如，符合上述描述的序列的前 4 个字符串依次是： S1 = “0” S2 = “011” S3 = “0111001” S4 = “011100110110001” 请你返回 Sn 的 第 k 位字符 ，题目数据保证 k 一定在 Sn 长度范围以内。 示例：示例 1： 输入：n = 3, k = 1 输出：&quot;0&quot; 解释：S3 为 &quot;0111001&quot;，其第 1 位为 &quot;0&quot; 。 示例 2： 输入：n = 4, k = 11 输出：&quot;1&quot; 解释：S4 为 &quot;011100110110001&quot;，其第 11 位为 &quot;1&quot; 。 示例 3： 输入：n = 1, k = 1 输出：&quot;0&quot; 示例 4： 输入：n = 2, k = 3 输出：&quot;1&quot; 提示： 1 &lt;= n &lt;= 20 1 &lt;= k &lt;= 2n - 1 分析：直接按照规则算就可以了 代码：class Solution { public: char findKthBit(int n, int k) { string str = &quot;0&quot;; for(int i = 1; i &lt; n; i++){ string s = &quot;&quot;; for(int j = str.size()-1; j &gt;= 0; j--){ s += str[j] == &apos;1&apos; ? &apos;0&apos;: &apos;1&apos;; } str = str + &apos;1&apos; + s; } return str[k-1]; } }; 题目地址:https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1544. 整理字符串]]></title>
    <url>%2F2020%2F08%2F10%2Fleetcode%201544.%20%E6%95%B4%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你一个由大小写英文字母组成的字符串 s 。 一个整理好的字符串中，两个相邻字符 s[i] 和 s[i + 1] 不会同时满足下述条件： 0 &lt;= i &lt;= s.length - 2 s[i] 是小写字符，但 s[i + 1] 是相同的大写字符；反之亦然 。 请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。 请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。 注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。 示例：示例 1： 输入：s = &quot;leEeetcode&quot; 输出：&quot;leetcode&quot; 解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 &quot;leEeetcode&quot; 缩减为 &quot;leetcode&quot; 。 示例 2： 输入：s = &quot;abBAcC&quot; 输出：&quot;&quot; 解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如： &quot;abBAcC&quot; --&gt; &quot;aAcC&quot; --&gt; &quot;cC&quot; --&gt; &quot;&quot; &quot;abBAcC&quot; --&gt; &quot;abBA&quot; --&gt; &quot;aA&quot; --&gt; &quot;&quot; 示例 3： 输入：s = &quot;s&quot; 输出：&quot;s&quot; 提示： 1 &lt;= s.length &lt;= 100 s 只包含小写和大写英文字母 分析：多次遍历，每次将相邻的大小写字母删除，直到全部删除为止 还可以用栈，每次判断栈顶和当前元素是否是大小写关系，是出栈，不是入栈 代码：class Solution { public: string makeGood(string s) { bool b = true; while(b &amp;&amp; s.size() != 0){ b = false; for(int i = 0; i+1 &lt; s.size(); i++){ if(s[i] == s[i+1]-&apos;A&apos;+&apos;a&apos; || s[i+1] == s[i]-&apos;A&apos;+&apos;a&apos;){ s.erase(i, 2); b = true; } } } return s; } }; 题目地址:https://leetcode-cn.com/problems/make-the-string-great/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1521. 找到最接近目标值的函数值]]></title>
    <url>%2F2020%2F07%2F20%2Fleetcode%201521.%20%E6%89%BE%E5%88%B0%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：Winston 构造了一个如上所示的函数 func 。他有一个整数数组 arr 和一个整数 target ，他想找到让 |func(arr, l, r) - target| 最小的 l 和 r 。 请你返回 |func(arr, l, r) - target| 的最小值。 请注意， func 的输入参数 l 和 r 需要满足 0 &lt;= l, r &lt; arr.length 。 示例：示例 1： 输入：arr = [9,12,3,7,15], target = 5 输出：2 解释：所有可能的 [l,r] 数对包括 [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]]， Winston 得到的相应结果为 [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0] 。最接近 5 的值是 7 和 3，所以最小差值为 2 。 示例 2： 输入：arr = [1000000,1000000,1000000], target = 1 输出：999999 解释：Winston 输入函数的所有可能 [l,r] 数对得到的函数值都为 1000000 ，所以最小差值为 999999 。 示例 3： 输入：arr = [1,2,4,8,16], target = 0 输出：0 提示： 1 &lt;= arr.length &lt;= 10^5 1 &lt;= arr[i] &lt;= 10^6 0 &lt;= target &lt;= 10^7 分析：与操作有个特性，每次进行与操作，结果不会大于两个操作数 如果固定右端点r，左端点从0取到r的结果都是小于r的，并且因为10^6 &lt; 2^20，所以最多有20中结果（因为如果每次减少一个1，20次后也就全0了） 从小到大遍历r，用一个数组存储func(arr, l, r)的值，数组的大小不会大于20 每次遍历新的值，就将新的值和原数组中的每个值进行按位与，添加一个新的值本身。再去重即可（因为数组本身就是从大到小的，所以可以直接使用unique() + erase()） 代码：class Solution { public: int closestToTarget(vector&lt;int&gt;&amp; arr, int target) { vector&lt;int&gt; v; int ret = INT_MAX; for(int i : arr){ vector&lt;int&gt; v1; v1.push_back(i); ret = min(ret, abs(i - target)); for(int j : v){ v1.push_back(j &amp; i); ret = min(ret, abs((j &amp; i) - target)); } v1.erase(unique(v1.begin(), v1.end()), v1.end()); v = v1; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1520. 最多的不重叠子字符串]]></title>
    <url>%2F2020%2F07%2F20%2Fleetcode%201520.%20%E6%9C%80%E5%A4%9A%E7%9A%84%E4%B8%8D%E9%87%8D%E5%8F%A0%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你一个只包含小写字母的字符串 s ，你需要找到 s 中最多数目的非空子字符串，满足如下条件： 这些字符串之间互不重叠，也就是说对于任意两个子字符串 s[i..j] 和 s[k..l] ，要么 j &lt; k 要么 i &gt; l 。 如果一个子字符串包含字符 c ，那么 s 中所有 c 字符都应该在这个子字符串中。请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。 请注意，你可以以 任意 顺序返回最优解的子字符串。 示例：示例 1： 输入：s = &quot;adefaddaccc&quot; 输出：[&quot;e&quot;,&quot;f&quot;,&quot;ccc&quot;] 解释：下面为所有满足第二个条件的子字符串： [ &quot;adefaddaccc&quot; &quot;adefadda&quot;, &quot;ef&quot;, &quot;e&quot;, &quot;f&quot;, &quot;ccc&quot;, ] 如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 1 。如果我们选择 &quot;adefadda&quot; ，剩下子字符串中我们只可以选择 &quot;ccc&quot; ，它是唯一不重叠的子字符串，所以答案为 2 。同时我们可以发现，选择 &quot;ef&quot; 不是最优的，因为它可以被拆分成 2 个子字符串。所以最优解是选择 [&quot;e&quot;,&quot;f&quot;,&quot;ccc&quot;] ，答案为 3 。不存在别的相同数目子字符串解。 示例 2： 输入：s = &quot;abbaccd&quot; 输出：[&quot;d&quot;,&quot;bb&quot;,&quot;cc&quot;] 解释：注意到解 [&quot;d&quot;,&quot;abba&quot;,&quot;cc&quot;] 答案也为 3 ，但它不是最优解，因为它的总长度更长。 提示： 1 &lt;= s.length &lt;= 10^5 s 只包含小写英文字母。 分析：v[i][j] 表示字符串以i开头，j为0时表示字符串的起始位置，j为1是表示字符串的结束位置 将字符串分割成v[i][j]的形式 将字符串以题目的要求进行合并，还要去除一部分不可能的字符串 比如 abab 以 b 开头就不可能 之后将字符串按照长短排序 按照贪心的方式从短到长一个个遍历，将不重叠的返回（因为只有不重叠和完全包含两种可能，如果完全包含，只需要取短的一部分即可） 代码：bool bj(vector&lt;int&gt; a, vector&lt;int&gt; b){ if(a[0] == -1) return false; if(b[0] == -1) return true; return a[1] - a[0] &lt; b[1] - b[0]; } class Solution { public: vector&lt;string&gt; maxNumOfSubstrings(string s) { vector&lt;vector&lt;int&gt;&gt; v(26, vector&lt;int&gt;(2, -1)); vector&lt;vector&lt;int&gt;&gt; v1(26, vector&lt;int&gt;(2, -1)); for(int i = 0; i &lt; s.size(); i++){ if(v[s[i]-&apos;a&apos;][0] == -1) v[s[i]-&apos;a&apos;][0] = i; v[s[i]-&apos;a&apos;][1] = i; } for(int i = 0; i &lt; 26; i++){ if(v[i][0] == -1) continue; int l = v[i][0]; int r = v[i][1]; bool b = true; while(b){ b = false; for(int j = 0; j &lt; 26; j++){ if(v[j][0] == -1) continue; if(i == j) continue; // 新的字符串的头位于当前字符串之间 if(v[j][0] &gt; l &amp;&amp; v[j][0] &lt; r &amp;&amp; v[j][1] &gt; r){ r = max(v[j][1], r); b = true; } // 新的字符串的尾位于当前字符串之间 else if(v[j][1] &gt; l &amp;&amp; v[j][1] &lt; r &amp;&amp; v[j][0] &lt; l){ l = -1; r = -1; b = false; break; }// 新的字符串完全包含当前字符串 else if(v[j][0] &lt; l &amp;&amp; v[j][1] &gt; r){ for(int k = l+1; k &lt; r; k++){ if(s[k] == s[v[j][0]]){ l = -1; r = -1; b = false; break; } } } } } v1[i][0] = l; v1[i][1] = r; } sort(v1.begin(), v1.end(), bj); vector&lt;string&gt; ret; vector&lt;vector&lt;int&gt;&gt; v2; for(int i = 0; i &lt; 26; i++){ if(v1[i][0] == -1) break; bool b = true; for(int j = 0; j &lt; v2.size(); j++){ if(v1[i][0] &lt; v2[j][0] &amp;&amp; v1[i][1] &gt; v2[j][0]){ b = false; break; } } if(b){ v2.push_back(v1[i]); ret.push_back(s.substr(v1[i][0], v1[i][1]-v1[i][0]+1)); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-substrings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1519. 子树中标签相同的节点数]]></title>
    <url>%2F2020%2F07%2F20%2Fleetcode%201519.%20%E5%AD%90%E6%A0%91%E4%B8%AD%E6%A0%87%E7%AD%BE%E7%9B%B8%E5%90%8C%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一棵树（即，一个连通的无环无向图），这棵树由编号从 0 到 n - 1 的 n 个节点组成，且恰好有 n - 1 条 edges 。树的根节点为节点 0 ，树上的每一个节点都有一个标签，也就是字符串 labels 中的一个小写字符（编号为 i 的 节点的标签就是 labels[i] ） 边数组 edges 以 edges[i] = [ai, bi] 的形式给出，该格式表示节点 ai 和 bi 之间存在一条边。 返回一个大小为 n 的数组，其中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数。 树 T 中的子树是由 T 中的某个节点及其所有后代节点组成的树。 示例：示例 1： 输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = &quot;abaedcd&quot; 输出：[2,1,1,1,1,1,1] 解释：节点 0 的标签为 &apos;a&apos; ，以 &apos;a&apos; 为根节点的子树中，节点 2 的标签也是 &apos;a&apos; ，因此答案为 2 。注意树中的每个节点都是这棵子树的一部分。 节点 1 的标签为 &apos;b&apos; ，节点 1 的子树包含节点 1、4 和 5，但是节点 4、5 的标签与节点 1 不同，故而答案为 1（即，该节点本身）。 示例 2： 输入：n = 4, edges = [[0,1],[1,2],[0,3]], labels = &quot;bbbb&quot; 输出：[4,2,1,1] 解释：节点 2 的子树中只有节点 2 ，所以答案为 1 。 节点 3 的子树中只有节点 3 ，所以答案为 1 。 节点 1 的子树中包含节点 1 和 2 ，标签都是 &apos;b&apos; ，因此答案为 2 。 节点 0 的子树中包含节点 0、1、2 和 3，标签都是 &apos;b&apos;，因此答案为 4 。 示例 3： 输入：n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = &quot;aabab&quot; 输出：[3,2,1,1,1] 示例 4： 输入：n = 6, edges = [[0,1],[0,2],[1,3],[3,4],[4,5]], labels = &quot;cbabaa&quot; 输出：[1,2,1,1,2,1] 示例 5： 输入：n = 7, edges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]], labels = &quot;aaabaaa&quot; 输出：[6,5,4,1,3,2,1] 提示： 1 &lt;= n &lt;= 10^5 edges.length == n - 1 edges[i].length == 2 0 &lt;= ai, bi &lt; n ai != bi labels.length == n labels 仅由小写英文字母组成 分析：将边转换成map形式 照树的方法dfs遍历 代码：class Solution { private: unordered_map&lt;int, vector&lt;int&gt;&gt; m; vector&lt;int&gt; ret; vector&lt;int&gt; v; public: void dfs(int r, string&amp; labels, int f){ int z = v[labels[r]-&apos;a&apos;]; // 记录进入此树前标签等于此树的数量 v[labels[r]-&apos;a&apos;]++; for(int i = 0; i &lt; m[r].size(); i++){ if(m[r][i] == f) continue; dfs(m[r][i], labels, r); } ret[r] = v[labels[r]-&apos;a&apos;] - z; // 标签的数量为遍历完此树减进入此树前的数量 } vector&lt;int&gt; countSubTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, string labels) { for(int i = 0; i &lt; n; i++) ret.push_back(0); for(int i = 0; i &lt; 26; i++) v.push_back(0); for(int i = 0; i &lt; edges.size(); i++){ m[edges[i][0]].push_back(edges[i][1]); m[edges[i][1]].push_back(edges[i][0]); } dfs(0, labels, -1); return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1518. 换酒问题]]></title>
    <url>%2F2020%2F07%2F20%2Fleetcode%201518.%20%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目：小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。 如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。 请你计算 最多 能喝到多少瓶酒。 示例：示例 1： 输入：numBottles = 9, numExchange = 3 输出：13 解释：你可以用 3 个空酒瓶兑换 1 瓶酒。 所以最多能喝到 9 + 3 + 1 = 13 瓶酒。 示例 2： 输入：numBottles = 15, numExchange = 4 输出：19 解释：你可以用 4 个空酒瓶兑换 1 瓶酒。 所以最多能喝到 15 + 3 + 1 = 19 瓶酒。 示例 3： 输入：numBottles = 5, numExchange = 5 输出：6 示例 4： 输入：numBottles = 2, numExchange = 3 输出：2 提示： 1 &lt;= numBottles &lt;= 100 2 &lt;= numExchange &lt;= 100 分析：直接按照规则换瓶子即可 代码：class Solution { public: int numWaterBottles(int numBottles, int numExchange) { int ret = 0; int i = numBottles; int j = 0; while(1){ ret += i; i += j; j = i % numExchange; i = i / numExchange; if(i + j &lt; numExchange) break; } ret += i; return ret; } }; 题目地址:https://leetcode-cn.com/problems/water-bottles/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5211. 概率最大的路径]]></title>
    <url>%2F2020%2F07%2F13%2Fleetcode%205211.%20%E6%A6%82%E7%8E%87%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。 指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。 如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。 示例：示例 1： 输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2 输出：0.25000 解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25 示例 2： 输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2 输出：0.30000 示例 3： 输入：n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2 输出：0.00000 解释：节点 0 和 节点 2 之间不存在路径 提示： 2 &lt;= n &lt;= 10^4 0 &lt;= start, end &lt; n start != end 0 &lt;= a, b &lt; n a != b 0 &lt;= succProb.length == edges.length &lt;= 2*10^4 0 &lt;= succProb[i] &lt;= 1 每两个节点之间最多有一条边 分析：用一个数组存储到达每个点最佳的概率，使用bfs从start开始遍历，只有数组中没存储或者比数组中概率更大的时候才入队列 代码：class Solution { public: double maxProbability(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;double&gt;&amp; succProb, int start, int end) { map&lt;int, map&lt;int, double&gt;&gt; m; for(int i = 0; i &lt; edges.size(); i++){ m[edges[i][0]][edges[i][1]] = succProb[i]; m[edges[i][1]][edges[i][0]] = succProb[i]; } queue&lt;pair&lt;int, double&gt;&gt; q; vector&lt;double&gt; vi(n, 0); q.push(pair&lt;int, double&gt;{start, 1}); while(q.size()){ pair&lt;int, double&gt; p = q.front(); q.pop(); if(vi[p.first] &lt; p.second) vi[p.first] = p.second; else continue; for(auto i = m[p.first].begin(); i != m[p.first].end(); i++){ q.push(pair&lt;int, double&gt;{i-&gt;first, vi[p.first] * i-&gt;second}); } } return vi[end]; } }; 题目地址:https://leetcode-cn.com/problems/path-with-maximum-probability/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5461. 仅含 1 的子串数]]></title>
    <url>%2F2020%2F07%2F13%2Fleetcode%205461.%20%E4%BB%85%E5%90%AB%201%20%E7%9A%84%E5%AD%90%E4%B8%B2%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个二进制字符串 s（仅由 ‘0’ 和 ‘1’ 组成的字符串）。 返回所有字符都为 1 的子字符串的数目。 由于答案可能很大，请你将它对 10^9 + 7 取模后返回。 示例：示例 1： 输入：s = &quot;0110111&quot; 输出：9 解释：共有 9 个子字符串仅由 &apos;1&apos; 组成 &quot;1&quot; -&gt; 5 次 &quot;11&quot; -&gt; 3 次 &quot;111&quot; -&gt; 1 次 示例 2： 输入：s = &quot;101&quot; 输出：2 解释：子字符串 &quot;1&quot; 在 s 中共出现 2 次 示例 3： 输入：s = &quot;111111&quot; 输出：21 解释：每个子字符串都仅由 &apos;1&apos; 组成 示例 4： 输入：s = &quot;000&quot; 输出：0 提示： s[i] == ‘0’ 或 s[i] == ‘1’ 1 &lt;= s.length &lt;= 10^5 分析：1个1有1种方式；2个1有1+2种方式；3个1有1+2+3种方式。。。。。。 遍历，对每一段连续的1进行计算 代码：class Solution { public: int numSub(string s) { int ret = 0; int z = 0; vector&lt;int&gt; v(100001, 0); for(int i = 1; i &lt; 100001; i++){ v[i] = (v[i-1] + i) % 1000000007; } for(int i = 0; i &lt; s.size(); i++){ if(s[i] == &apos;0&apos;){ ret = (ret + v[z]) % 1000000007; z = 0; } else z++; } ret = (ret + v[z]) % 1000000007; return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-substrings-with-only-1s/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5460. 好数对的数目]]></title>
    <url>%2F2020%2F07%2F13%2Fleetcode%205460.%20%E5%A5%BD%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 。 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i &lt; j ，就可以认为这是一组 好数对 。 返回好数对的数目。 示例：示例 1： 输入：nums = [1,2,3,1,1,3] 输出：4 解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5) ，下标从 0 开始 示例 2： 输入：nums = [1,1,1,1] 输出：6 解释：数组中的每组数字都是好数对 示例 3： 输入：nums = [1,2,3] 输出：0 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 分析：直接双重循环遍历即可 代码：class Solution { public: int numIdenticalPairs(vector&lt;int&gt;&amp; nums) { int ret = 0; for(int i = 0; i &lt; nums.size(); i++){ for(int j = i+1; j &lt; nums.size(); j++){ if(nums[i] == nums[j]) ret++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-good-pairs/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1502. 判断能否形成等差数列]]></title>
    <url>%2F2020%2F07%2F06%2Fleetcode%201502.%20%E5%88%A4%E6%96%AD%E8%83%BD%E5%90%A6%E5%BD%A2%E6%88%90%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个数字数组 arr 。 如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。 如果可以重新排列数组形成等差数列，请返回 true ；否则，返回 false 。 示例：示例 1： 输入：arr = [3,5,1] 输出：true 解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。 示例 2： 输入：arr = [1,2,4] 输出：false 解释：无法通过重新排序得到等差数列。 提示： 2 &lt;= arr.length &lt;= 1000 -10^6 &lt;= arr[i] &lt;= 10^6 分析：排序，判断每两个数之间的差是否相同 代码：class Solution { public: bool canMakeArithmeticProgression(vector&lt;int&gt;&amp; arr) { sort(arr.begin(), arr.end()); int c = arr[1] - arr[0]; for(int i = 2; i &lt; arr.size(); i++){ if(arr[i] - arr[i-1] != c) return false; } return true; } }; 题目地址:https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1504. 统计全 1 子矩形]]></title>
    <url>%2F2020%2F07%2F06%2Fleetcode%201504.%20%E7%BB%9F%E8%AE%A1%E5%85%A8%201%20%E5%AD%90%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题目：给你一个只包含 0 和 1 的 rows * columns 矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。 示例：示例 1： 输入：mat = [[1,0,1], [1,1,0], [1,1,0]] 输出：13 解释： 有 6 个 1x1 的矩形。 有 2 个 1x2 的矩形。 有 3 个 2x1 的矩形。 有 1 个 2x2 的矩形。 有 1 个 3x1 的矩形。 矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。 示例 2： 输入：mat = [[0,1,1,0], [0,1,1,1], [1,1,1,0]] 输出：24 解释： 有 8 个 1x1 的子矩形。 有 5 个 1x2 的子矩形。 有 2 个 1x3 的子矩形。 有 4 个 2x1 的子矩形。 有 2 个 2x2 的子矩形。 有 2 个 3x1 的子矩形。 有 1 个 3x2 的子矩形。 矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24 。 示例 3： 输入：mat = [[1,1,1,1,1,1]] 输出：21 示例 4： 输入：mat = [[1,0,1],[0,1,0],[1,0,1]] 输出：5 提示： 1 &lt;= rows &lt;= 150 1 &lt;= columns &lt;= 150 0 &lt;= mat[i][j] &lt;= 1 分析：使用dp存储每个节点的左侧连续1的数量 遍历所有节点，利用之前计算的左侧连续1的数量来对每个节点向上查找矩形数量，将矩形个数加到答案中即可 代码：class Solution { public: int numSubmat(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { vector&lt;vector&lt;int&gt;&gt; dp(mat.size(), vector&lt;int&gt;(mat[0].size(), 0)); int ret = 0; for(int i = 0; i &lt; mat.size(); i++){ for(int j = 0; j &lt; mat[i].size(); j++){ if(j == 0) dp[i][j] = mat[i][j]; else{ if(mat[i][j] == 0) dp[i][j] = 0; else dp[i][j] = dp[i][j-1] + 1; } } } for(int i = 0; i &lt; mat.size(); i++){ for(int j = 0; j &lt; mat[0].size(); j++){ int z = dp[i][j]; ret += z; for(int k = 1; i-k &gt;= 0 &amp;&amp; dp[i-k][j] &gt; 0; k++){ z = min(dp[i-k][j], z); ret += z; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-submatrices-with-all-ones/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1503. 所有蚂蚁掉下来前的最后一刻]]></title>
    <url>%2F2020%2F07%2F06%2Fleetcode%201503.%20%E6%89%80%E6%9C%89%E8%9A%82%E8%9A%81%E6%8E%89%E4%B8%8B%E6%9D%A5%E5%89%8D%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%88%BB%2F</url>
    <content type="text"><![CDATA[题目：有一块木板，长度为 n 个 单位 。一些蚂蚁在木板上移动，每只蚂蚁都以 每秒一个单位 的速度移动。其中，一部分蚂蚁向 左 移动，其他蚂蚁向 右 移动。 当两只向 不同 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。 而当蚂蚁在某一时刻 t 到达木板的一端时，它立即从木板上掉下来。 给你一个整数 n 和两个整数数组 left 以及 right 。两个数组分别标识向左或者向右移动的蚂蚁在 t = 0 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。 示例：示例 1： 输入：n = 4, left = [4,3], right = [0,1] 输出：4 解释：如上图所示： -下标 0 处的蚂蚁命名为 A 并向右移动。 -下标 1 处的蚂蚁命名为 B 并向右移动。 -下标 3 处的蚂蚁命名为 C 并向左移动。 -下标 4 处的蚂蚁命名为 D 并向左移动。 请注意，蚂蚁在木板上的最后时刻是 t = 4 秒，之后蚂蚁立即从木板上掉下来。（也就是说在 t = 4.0000000001 时，木板上没有蚂蚁）。 示例 2： 输入：n = 7, left = [], right = [0,1,2,3,4,5,6,7] 输出：7 解释：所有蚂蚁都向右移动，下标为 0 的蚂蚁需要 7 秒才能从木板上掉落。 示例 3： 输入：n = 7, left = [0,1,2,3,4,5,6,7], right = [] 输出：7 解释：所有蚂蚁都向左移动，下标为 7 的蚂蚁需要 7 秒才能从木板上掉落。 示例 4： 输入：n = 9, left = [5], right = [4] 输出：5 解释：t = 1 秒时，两只蚂蚁将回到初始位置，但移动方向与之前相反。 示例 5： 输入：n = 6, left = [6], right = [0] 输出：6 提示： 1 &lt;= n &lt;= 10^4 0 &lt;= left.length &lt;= n + 1 0 &lt;= left[i] &lt;= n 0 &lt;= right.length &lt;= n + 1 0 &lt;= right[i] &lt;= n 1 &lt;= left.length + right.length &lt;= n + 1 left 和 right 中的所有值都是唯一的，并且每个值 只能出现在二者之一 中。 分析：题目有点迷惑人，但两只蚂蚁相撞掉头后其实还是一个方向一只，等于没掉头 代码：class Solution { public: int getLastMoment(int n, vector&lt;int&gt;&amp; left, vector&lt;int&gt;&amp; right) { int ret = 0; for(int i = 0; i &lt; left.size(); i++){ ret = max(ret, left[i] - 0); } for(int i = 0; i &lt; right.size(); i++){ ret = max(ret, n - right[i]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5451. 满足不等式的最大值]]></title>
    <url>%2F2020%2F06%2F29%2Fleetcode%205451.%20%E6%BB%A1%E8%B6%B3%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 points 和一个整数 k 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序。也就是说 points[i] = [xi, yi] ，并且在 1 &lt;= i &lt; j &lt;= points.length 的前提下， xi &lt; xj 总成立。 请你找出 yi + yj + |xi - xj| 的 最大值，其中 |xi - xj| &lt;= k 且 1 &lt;= i &lt; j &lt;= points.length。 题目测试数据保证至少存在一对能够满足 |xi - xj| &lt;= k 的点。 示例：示例 1： 输入：points = [[1,3],[2,0],[5,10],[6,-10]], k = 1 输出：4 解释：前两个点满足 |xi - xj| &lt;= 1 ，带入方程计算，则得到值 3 + 0 + |1 - 2| = 4 。第三个和第四个点也满足条件，得到值 10 + -10 + |5 - 6| = 1 。 没有其他满足条件的点，所以返回 4 和 1 中最大的那个。 示例 2： 输入：points = [[0,0],[3,0],[9,2]], k = 3 输出：3 解释：只有前两个点满足 |xi - xj| &lt;= 3 ，带入方程后得到值 0 + 0 + |0 - 3| = 3 。 提示： 2 &lt;= points.length &lt;= 10^5 points[i].length == 2 -10^8 &lt;= points[i][0], points[i][1] &lt;= 10^8 0 &lt;= k &lt;= 2 * 10^8 对于所有的1 &lt;= i &lt; j &lt;= points.length ，points[i][0] &lt; points[j][0] 都成立。也就是说，xi 是严格递增的。 分析：使用单调队列和滑动窗口 x本身就是有序的，根据k的大小维护一个滑动窗口[i, j] 将原表达式处理成 （yj + xj） + （yi - xi） 在单调队列中存储（yj + xj）和 xj 的值 代码：class Solution { public: int findMaxValueOfEquation(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) { priority_queue&lt;pair&lt;int, int&gt;&gt; q; int j = 1; int ret = INT_MIN; for(int i = 0; i &lt; points.size(); i++){ // 将k范围内的点加入单调队列 while(j &lt; points.size() &amp;&amp; points[j][0] - points[i][0] &lt;= k){ q.push(pair&lt;int, int&gt;{points[j][0] + points[j][1], points[j][0]}); j++; } while(q.size() &gt; 0){ // 如果队列头的x值（xj）小于等于xi的值，就出队列，否则更新解 if(q.top().second &lt;= points[i][0]) q.pop(); else{ ret = max(ret, q.top().first + points[i][1] - points[i][0]); break; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/max-value-of-equation/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5450. 满足条件的子序列数目]]></title>
    <url>%2F2020%2F06%2F28%2Fleetcode%205450.%20%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 和一个整数 target 。 请你统计并返回 nums 中能满足其最小元素与最大元素的 和 小于或等于 target 的 非空 子序列的数目。 由于答案可能很大，请将结果对 10^9 + 7 取余后返回。 示例：示例 1： 输入：nums = [3,5,6,7], target = 9 输出：4 解释：有 4 个子序列满足该条件。 [3] -&gt; 最小元素 + 最大元素 &lt;= target (3 + 3 &lt;= 9) [3,5] -&gt; (3 + 5 &lt;= 9) [3,5,6] -&gt; (3 + 6 &lt;= 9) [3,6] -&gt; (3 + 6 &lt;= 9) 示例 2： 输入：nums = [3,3,6,8], target = 10 输出：6 解释：有 6 个子序列满足该条件。（nums 中可以有重复数字） [3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6] 示例 3： 输入：nums = [2,3,3,4,6,7], target = 12 输出：61 解释：共有 63 个非空子序列，其中 2 个不满足条件（[6,7], [7]） 有效序列总数为（63 - 2 = 61） 示例 4： 输入：nums = [5,2,4,1,7,6,8], target = 16 输出：127 解释：所有非空子序列都满足条件 (2^7 - 1) = 127 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^6 1 &lt;= target &lt;= 10^6 分析：排序 使用双指针来找到最大和最小的元素，根据之间的元素个数来计算组合方式的数量 需要预处理不同的数的组合数量（2的次幂），不然会超时 代码：class Solution { public: int numSubseq(vector&lt;int&gt;&amp; nums, int target) { vector&lt;long&gt; v; sort(nums.begin(), nums.end()); int l = 0; int r; long ret = 0; long z = 2; v.push_back(1); for(int i = 1; i &lt; 100000; i++){ v.push_back(z + v[i-1] % 1000000007); z *= 2; z %= 1000000007; } for(r = nums.size()-1; r &gt;= 0; r--){ if(nums[0] + nums[r] &lt;= target){ break; } if(r == 0) return 0; } for(l = 0; l &lt; r;){ ret += v[r-l-1]; ret %= 1000000007; l++; while(nums[l] + nums[r] &gt; target &amp;&amp; r &gt; l) r--; } for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] * 2 &lt;= target) ret++; else break; } ret %= 1000000007; return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2020%2F06%2F28%2Fleetcode%205449.%20%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E5%AF%B9%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%20k%20%E6%95%B4%E9%99%A4%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 arr 和一个整数 k ，其中数组长度是偶数，值为 n 。 现在需要把数组恰好分成 n / 2 对，以使每对数字的和都能够被 k 整除。 如果存在这样的分法，请返回 True ；否则，返回 False 。 示例：示例 1： 输入：arr = [1,2,3,4,5,10,6,7,8,9], k = 5 输出：true 解释：划分后的数字对为 (1,9),(2,8),(3,7),(4,6) 以及 (5,10) 。 示例 2： 输入：arr = [1,2,3,4,5,6], k = 7 输出：true 解释：划分后的数字对为 (1,6),(2,5) 以及 (3,4) 。 示例 3： 输入：arr = [1,2,3,4,5,6], k = 10 输出：false 解释：无法在将数组中的数字分为三对的同时满足每对数字和能够被 10 整除的条件。 示例 4： 输入：arr = [-10,10], k = 2 输出：true 示例 5： 输入：arr = [-1,1,-2,2,-3,3,-4,4], k = 3 输出：true 提示： arr.length == n 1 &lt;= n &lt;= 10^5 n 为偶数 -10^9 &lt;= arr[i] &lt;= 10^9 1 &lt;= k &lt;= 10^5 分析：对所有数求余，统计各余数的个数，然后进行配对 负数可以加上k变成正数（类似补码），也可以直接将对应余数个数减1 代码：class Solution { public: bool canArrange(vector&lt;int&gt;&amp; arr, int k) { vector&lt;int&gt; v(k, 0); for(int i = 0; i &lt; arr.size(); i++){ if(arr[i] &gt;= 0) v[arr[i]%k]++; else v[arr[i] * -1 %k]--; } for(int i = 1; i &lt; v.size(); i++){ if(v[i] != v[k-i]) return false; } if(v[0] % 2 != 0) return false; if(k % 2 == 0 &amp;&amp; v[k/2] % 2 != 0) return false; return true; } }; 题目地址:https://leetcode-cn.com/problems/check-if-array-pairs-are-divisible-by-k/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5448. 判断路径是否相交]]></title>
    <url>%2F2020%2F06%2F28%2Fleetcode%205448.%20%E5%88%A4%E6%96%AD%E8%B7%AF%E5%BE%84%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 path，其中 path[i] 的值可以是 ‘N’、’S’、’E’ 或者 ‘W’，分别表示向北、向南、向东、向西移动一个单位。 机器人从二维平面上的原点 (0, 0) 处开始出发，按 path 所指示的路径行走。 如果路径在任何位置上出现相交的情况，也就是走到之前已经走过的位置，请返回 True ；否则，返回 False 。 示例：示例 1： 输入：path = &quot;NES&quot; 输出：false 解释：该路径没有在任何位置相交。 示例 2： 输入：path = &quot;NESWW&quot; 输出：true 解释：该路径经过原点两次。 提示： 1 &lt;= path.length &lt;= 10^4 path 仅由 {‘N’, ‘S’, ‘E’, ‘W} 中的字符组成 分析：使用map记录所有经过的点，判断是否重复经过即可 代码：class Solution { public: bool isPathCrossing(string path) { map&lt;int, map&lt;int, int&gt;&gt; m; m[0][0] = 1; int x = 0; int y = 0; for(int i = 0; i &lt; path.size(); i++){ if(path[i] == &apos;N&apos;) y--; else if(path[i] == &apos;S&apos;) y++; else if(path[i] == &apos;E&apos;) x++; else if(path[i] == &apos;W&apos;) x--; if(m[x][y] == 0) m[x][y] = 1; else return true; } return false; } }; 题目地址:https://leetcode-cn.com/problems/path-crossing/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1489. 找到最小生成树里的关键边和伪关键边]]></title>
    <url>%2F2020%2F06%2F22%2Fleetcode%201489.%20%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%87%8C%E7%9A%84%E5%85%B3%E9%94%AE%E8%BE%B9%E5%92%8C%E4%BC%AA%E5%85%B3%E9%94%AE%E8%BE%B9%2F</url>
    <content type="text"><![CDATA[题目：给你一个 n 个点的带权无向连通图，节点编号为 0 到 n-1 ，同时还有一个数组 edges ，其中 edges[i] = [fromi, toi, weighti] 表示在 fromi 和 toi 节点之间有一条带权无向边。最小生成树 (MST) 是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。 请你找到给定图中最小生成树的所有关键边和伪关键边。如果最小生成树中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。 请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。 示例：示例 1： 输入：n = 5, edges = [[0,1,1],[1,2,1],[2,3,2],[0,3,2],[0,4,3],[3,4,3],[1,4,6]] 输出：[[0,1],[2,3,4,5]] 解释：上图描述了给定图。 下图是所有的最小生成树。 注意到第 0 条边和第 1 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。 边 2，3，4 和 5 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。 示例 2 ： 输入：n = 4, edges = [[0,1,1],[1,2,1],[2,3,1],[0,3,1]] 输出：[[],[0,1,2,3]] 解释：可以观察到 4 条边都有相同的权值，任选它们中的 3 条可以形成一棵 MST 。所以 4 条边都是伪关键边。 提示： 2 &lt;= n &lt;= 100 1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2) edges[i].length == 3 0 &lt;= fromi &lt; toi &lt; n 1 &lt;= weighti &lt;= 1000 所有 (fromi, toi) 数对都是互不相同的。 分析：求最小生成树有克鲁斯卡尔算法(Kruskal算法)和普里姆算法(Prim算法) 总共有三种边：一种是少了就会让最小生成树权值和增加的关键边；一种是有没有最小生成树都不变的伪关键边；还有一种是加上就会让最小生成树权值和增加的无用边 第一种边可以通从所有边中去掉这种，看看是否让最小生成树权值和增加或者干脆无法链接所有结点来判断 第三种边可以通过在使用Kruskal算法时先将此边加入来判断是否是无用边 剩下的就是第二种边了 在使用Kruskal算法时还会用到并查集 代码：bool bj(vector&lt;int&gt; a, vector&lt;int&gt; b){ return a[2] &lt; b[2]; } // 并查集压缩算法 int ys(int a, vector&lt;int&gt;&amp; v){ int root = a; while(v[root] != root){ root = v[root]; } while(v[a] != root){ int b = v[a]; v[a] = root; a = b; } return root; } // e为边的集合，n为结点个数，j为事先添加的边 int Kruskal(vector&lt;vector&lt;int&gt;&gt;&amp; e, int n, vector&lt;int&gt; j){ vector&lt;int&gt; v(n); for(int i = 0; i &lt; v.size(); i++){ v[i] = i; } int ret = 0; int jd = n; if(j.size() &gt; 0){ jd--; v[j[0]] = v[j[1]]; ret += j[2]; } for(int i = 0; i &lt; e.size(); i++){ int root1 = ys(e[i][0], v); int root2 = ys(e[i][1], v); if(root1 != root2){ v[root2] = root1; jd--; ret += e[i][2]; } } if(jd == 1) return ret; return -1; } class Solution { public: vector&lt;vector&lt;int&gt;&gt; findCriticalAndPseudoCriticalEdges(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) { map&lt;vector&lt;int&gt;, int&gt; m; for(int i = 0; i &lt; edges.size(); i++){ m[edges[i]] = i; } vector&lt;int&gt; v(n, 0); sort(edges.begin(), edges.end(), bj); int k = Kruskal(edges, n, vector&lt;int&gt;()); vector&lt;vector&lt;int&gt;&gt; ret(2); for(int i = 0; i &lt; edges.size(); i++){ vector&lt;vector&lt;int&gt;&gt; e = edges; e.erase(e.begin()+i); int k1 = Kruskal(e, n, vector&lt;int&gt;()); if(k1 &gt; k || k1 == -1){ ret[0].push_back(m[edges[i]]); } else{ k1 = Kruskal(e, n, edges[i]); if(k1 == k) ret[1].push_back(m[edges[i]]); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/submissions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1488. 避免洪水泛滥]]></title>
    <url>%2F2020%2F06%2F22%2Fleetcode%201488.%20%E9%81%BF%E5%85%8D%E6%B4%AA%E6%B0%B4%E6%B3%9B%E6%BB%A5%2F</url>
    <content type="text"><![CDATA[题目：你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨的时候，如果第 n 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水。 给你一个整数数组 rains ，其中： rains[i] &gt; 0 表示第 i 天时，第 rains[i] 个湖泊会下雨。 rains[i] == 0 表示第 i 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。 请返回一个数组 ans ，满足： ans.length == rains.length 如果 rains[i] &gt; 0 ，那么ans[i] == -1 。 如果 rains[i] == 0 ，ans[i] 是你第 i 天选择抽干的湖泊。 如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。 请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生（详情请看示例 4）。 示例：示例 1： 输入：rains = [1,2,3,4] 输出：[-1,-1,-1,-1] 解释：第一天后，装满水的湖泊包括 [1] 第二天后，装满水的湖泊包括 [1,2] 第三天后，装满水的湖泊包括 [1,2,3] 第四天后，装满水的湖泊包括 [1,2,3,4] 没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。 示例 2： 输入：rains = [1,2,0,0,2,1] 输出：[-1,-1,2,1,-1,-1] 解释：第一天后，装满水的湖泊包括 [1] 第二天后，装满水的湖泊包括 [1,2] 第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1] 第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。 第五天后，装满水的湖泊包括 [2]。 第六天后，装满水的湖泊包括 [1,2]。 可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。 示例 3： 输入：rains = [1,2,0,1,2] 输出：[] 解释：第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。 但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。 示例 4： 输入：rains = [69,0,0,0,69] 输出：[-1,69,1,1,-1] 解释：任何形如 [-1,69,x,y,-1], [-1,x,69,y,-1] 或者 [-1,x,y,69,-1] 都是 可行的解，其中 1 &lt;= x,y &lt;= 10^9 示例 5： 输入：rains = [10,20,20] 输出：[] 解释：由于湖泊 20 会连续下 2 天的雨，所以没有没有办法阻止洪水。 提示： 1 &lt;= rains.length &lt;= 10^5 0 &lt;= rains[i] &lt;= 10^9 分析：使用 unordered_map&lt;int, int&gt; m 来存储湖泊装满水的时间 使用 set v 来记录晴天的日子 遍历，遇到当天下雨并且湖泊此湖泊装满水的时候，查找v中是否有晴天在此湖泊两次下雨之间：若有，记录这个晴天时排水的湖泊，并将此湖泊装满水的时间更新，；若没有，返回空数组 代码：class Solution { public: vector&lt;int&gt; avoidFlood(vector&lt;int&gt;&amp; rains) { unordered_map&lt;int, int&gt; m; set&lt;int&gt; v; vector&lt;int&gt; ret(rains.size(), -1); for(int i = 0; i &lt; rains.size(); i++){ if(rains[i] == 0){ v.insert(i); } else{ if(m.count(rains[i]) == 0){ m[rains[i]] = i; } else{ bool b = true; auto a = v.lower_bound(m[rains[i]]); if(a == v.end()) return vector&lt;int&gt;(); ret[*a] = rains[i]; v.erase(a); m[rains[i]] = i; } } } for(auto a = v.begin(); a != v.end(); a++){ ret[*a] = 1; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/avoid-flood-in-the-city/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1487. 保证文件名唯一]]></title>
    <url>%2F2020%2F06%2F22%2Fleetcode%201487.%20%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E5%90%8D%E5%94%AF%E4%B8%80%2F</url>
    <content type="text"><![CDATA[题目：给你一个长度为 n 的字符串数组 names 。你将会在文件系统中创建 n 个文件夹：在第 i 分钟，新建名为 names[i] 的文件夹。 由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 (k) 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。 返回长度为 n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。 示例：示例 1： 输入：names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;] 输出：[&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;] 解释：文件系统将会这样创建文件名： &quot;pes&quot; --&gt; 之前未分配，仍为 &quot;pes&quot; &quot;fifa&quot; --&gt; 之前未分配，仍为 &quot;fifa&quot; &quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot; &quot;pes(2019)&quot; --&gt; 之前未分配，仍为 &quot;pes(2019)&quot; 示例 2： 输入：names = [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;] 输出：[&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;] 解释：文件系统将会这样创建文件名： &quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot; &quot;gta(1)&quot; --&gt; 之前未分配，仍为 &quot;gta(1)&quot; &quot;gta&quot; --&gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 &quot;gta(1)&quot; 也被占用，所以 k = 2 。实际创建的文件名为 &quot;gta(2)&quot; 。 &quot;avalon&quot; --&gt; 之前未分配，仍为 &quot;avalon&quot; 示例 3： 输入：names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;] 输出：[&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;] 解释：当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 &quot;onepiece(4)&quot;。 示例 4： 输入：names = [&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;] 输出：[&quot;wano&quot;,&quot;wano(1)&quot;,&quot;wano(2)&quot;,&quot;wano(3)&quot;] 解释：每次创建文件夹 &quot;wano&quot; 时，只需增加后缀中 k 的值即可。 示例 5： 输入：names = [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;] 输出：[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;] 解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。 提示： 1 &lt;= names.length &lt;= 5 * 10^4 1 &lt;= names[i].length &lt;= 20 names[i] 由小写英文字母、数字和/或圆括号组成。 分析：使用两个unordered_map 一个用来存储已经出现过的文件名；一个用来存储这个文件名从1开始已经使用过的最大后缀，用于下次碰到相同文件名时节省时间 代码：class Solution { public: vector&lt;string&gt; getFolderNames(vector&lt;string&gt;&amp; names) { unordered_map&lt;string, int&gt; m; unordered_map&lt;string, int&gt; m1; vector&lt;string&gt; ret(names.size()); for(int i = 0; i &lt; names.size(); i++){ if(m[names[i]] == 0){ m[names[i]] = 1; ret[i] = names[i]; } else{ int j; if(m1[names[i]] != 0) j = m1[names[i]]; else j = 1; for(; ; j++){ string q = &quot;(&quot;+to_string(j)+&quot;)&quot;; if(m[names[i]+q] == 0){ m[names[i]+q] = 1; ret[i] = names[i]+q; m1[names[i]] = j; break; } } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/making-file-names-unique/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1486. 数组异或操作]]></title>
    <url>%2F2020%2F06%2F22%2Fleetcode%201486.%20%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[题目：给你两个整数，n 和 start 。 数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。 请返回 nums 中所有元素按位异或（XOR）后得到的结果。 示例：示例 1： 输入：n = 5, start = 0 输出：8 解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。 &quot;^&quot; 为按位异或 XOR 运算符。 示例 2： 输入：n = 4, start = 3 输出：8 解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8. 示例 3： 输入：n = 1, start = 7 输出：7 示例 4： 输入：n = 10, start = 5 输出：2 提示： 1 &lt;= n &lt;= 1000 0 &lt;= start &lt;= 1000 n == nums.length 分析：直接按照规则计算即可 代码：class Solution { public: int xorOperation(int n, int start) { int ret = 0; for(int i = 0; i &lt; n; i++){ ret = ret^(2*i+start); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/xor-operation-in-an-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1483. 树节点的第 K 个祖先]]></title>
    <url>%2F2020%2F06%2F15%2Fleetcode%201483.%20%E6%A0%91%E8%8A%82%E7%82%B9%E7%9A%84%E7%AC%AC%20K%20%E4%B8%AA%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[题目：给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。 请你设计并实现 getKthAncestor(int node, int k) 函数，函数返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。 树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。 示例：输入： [&quot;TreeAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;,&quot;getKthAncestor&quot;] [[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]] 输出： [null,1,0,-1] 解释： TreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]); treeAncestor.getKthAncestor(3, 1); // 返回 1 ，它是 3 的父节点 treeAncestor.getKthAncestor(5, 2); // 返回 0 ，它是 5 的祖父节点 treeAncestor.getKthAncestor(6, 3); // 返回 -1 因为不存在满足要求的祖先节点 提示： 1 &lt;= k &lt;= n &lt;= 5*10^4 parent[0] == -1 表示编号为 0 的节点是根节点。 对于所有的 0 &lt; i &lt; n ，0 &lt;= parent[i] &lt; n 总成立 0 &lt;= node &lt; n 至多查询 5*10^4 次 分析：可以使用倍增 参考： https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node/solution/li-kou-zai-zhu-jian-ba-acm-mo-ban-ti-ban-shang-lai/ https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node/solution/dpbei-zeng-fa-dai-ma-qing-xi-python3xiang-xi-zhu-s/ 重点： 当k=10 时，二进制为 1010, 等于 2^3 + 2^1 当求node的第10个祖先时，结果为: dp[dp[node][2^3]][2^1]，和幂运算类似，底数不变，指数相加 还可以:https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node/solution/dfsceng-ci-bian-li-er-fen-cha-zhao-bei-zeng-shi-ya/这个方法比较偏 代码：class TreeAncestor { private: vector&lt;vector&lt;int&gt;&gt; dp; // dp[i][j],代表第i个结点的2^j个祖先节点 public: TreeAncestor(int n, vector&lt;int&gt;&amp; parent) { for(int i = 0; i &lt; n; i++){ // 将每个节点的父节点录入 dp.push_back(vector&lt;int&gt;(1, parent[i])); } for(int j = 1; ; j++){ // 将每个节点的2^j个祖先节点录入 bool b = true; for(int i = 0; i &lt; n; i++){ int t = dp[i][j-1] != -1 ? dp[dp[i][j-1]][j-1] : -1; // 如果祖先节点不存在，录入-1 dp[i].push_back(t); if(t != -1) b = false; } if(b) break; // 当所有结点的祖先节点全部为-1时结束 } } int getKthAncestor(int node, int k) { queue&lt;int&gt; q; int ret = node; int i = 0; while(k &gt; 0){ // 将k变成2^k1 + 2^k2....的形式存入队列 if(k%2 != 0) q.push(i); k/=2; i++; } if(i &gt; dp[0].size()) return -1; // 如果k的大小大于先前祖先节点最大的大小，溢出了，返回-1 while(q.size()){ // 按队列中存储的数据进行运算即可 ret = dp[ret][q.front()]; if(ret == -1) return -1; // 不能省，因为dp[-1]会报错 q.pop(); } return ret; } }; /** * Your TreeAncestor object will be instantiated and called as such: * TreeAncestor* obj = new TreeAncestor(n, parent); * int param_1 = obj-&gt;getKthAncestor(node,k); */ 题目地址:https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1482. 制作 m 束花所需的最少天数]]></title>
    <url>%2F2020%2F06%2F15%2Fleetcode%201482.%20%E5%88%B6%E4%BD%9C%20m%20%E6%9D%9F%E8%8A%B1%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%A9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 bloomDay，以及两个整数 m 和 k 。 现需要制作 m 束花。制作花束时，需要使用花园中 相邻的 k 朵花 。 花园中有 n 朵花，第 i 朵花会在 bloomDay[i] 时盛开，恰好 可以用于 一束 花中。 请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。 示例：示例 1： 输入：bloomDay = [1,10,3,10,2], m = 3, k = 1 输出：3 解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。 现在需要制作 3 束花，每束只需要 1 朵。 1 天后：[x, _, _, _, _] // 只能制作 1 束花 2 天后：[x, _, _, _, x] // 只能制作 2 束花 3 天后：[x, _, x, _, x] // 可以制作 3 束花，答案为 3 示例 2： 输入：bloomDay = [1,10,3,10,2], m = 3, k = 2 输出：-1 解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。 示例 3： 输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3 输出：12 解释：要制作 2 束花，每束需要 3 朵。 花园在 7 天后和 12 天后的情况如下： 7 天后：[x, x, x, x, _, x, x] 可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。 12 天后：[x, x, x, x, x, x, x] 显然，我们可以用不同的方式制作两束花。 示例 4： 输入：bloomDay = [1000000000,1000000000], m = 1, k = 1 输出：1000000000 解释：需要等 1000000000 天才能采到花来制作花束 示例 5： 输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2 输出：9 提示： bloomDay.length == n 1 &lt;= n &lt;= 10^5 1 &lt;= bloomDay[i] &lt;= 10^9 1 &lt;= m &lt;= 10^6 1 &lt;= k &lt;= n 分析：将所有花开的时间排序，对每个时间点开的花搜索两边连续开的花的数量。 当一朵花在中间开的时候，花束的总数为：原数量-当前花左侧和右侧连续花束的数量+(当前花左侧和右侧花数量加自身 / 每束花的数量) 还可以按照天数 按二分法求 代码：class Solution { public: int minDays(vector&lt;int&gt;&amp; bloomDay, int m, int k) { if(k*m &gt; bloomDay.size()) return -1; map&lt;int, vector&lt;int&gt;&gt; m1; vector&lt;int&gt; vi(bloomDay.size(), 0); for(int i = 0; i &lt; bloomDay.size(); i++){ m1[bloomDay[i]].push_back(i); } int z = 0; for(auto a = m1.begin(); a != m1.end(); a++){ for(int i = 0; i &lt; a-&gt;second.size(); i++){ vi[a-&gt;second[i]] = 1; int r = 0; for(int j = a-&gt;second[i]+1; j &lt; bloomDay.size() &amp;&amp; vi[j] != 0; j++){ r++; } int l = 0; for(int j = a-&gt;second[i]-1; j &gt;= 0 &amp;&amp; vi[j] != 0; j--){ l++; } z -= r/k; z -= l/k; z += (r+l+1)/k; } if(z &gt;= m) return a-&gt;first; } return -1; } }; 题目地址:https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1481. 不同整数的最少数目]]></title>
    <url>%2F2020%2F06%2F15%2Fleetcode%201481.%20%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 arr 和一个整数 k 。现需要从数组中恰好移除 k 个元素，请找出移除后数组中不同整数的最少数目。 示例：示例 1： 输入：arr = [5,5,4], k = 1 输出：1 解释：移除 1 个 4 ，数组中只剩下 5 一种整数。 示例 2： 输入：arr = [4,3,1,1,3,3,2], k = 3 输出：2 解释：先移除 4、2 ，然后再移除两个 1 中的任意 1 个或者三个 3 中的任意 1 个，最后剩下 1 和 3 两种整数。 提示： 1 &lt;= arr.length &lt;= 10^5 1 &lt;= arr[i] &lt;= 10^9 0 &lt;= k &lt;= arr.length 分析：统计每个整数出现次数，从数量最少的元素开始移除数组 代码：class Solution { public: int findLeastNumOfUniqueInts(vector&lt;int&gt;&amp; arr, int k) { map&lt;int, int&gt; m; for(int i = 0; i &lt; arr.size(); i++){ m[arr[i]]++; } vector&lt;int&gt; v; for(auto a = m.begin(); a != m.end(); a++){ v.push_back(a-&gt;second); } sort(v.begin(), v.end()); for(int i = 0; i &lt; v.size(); i++){ k -= v[i]; if(k &lt; 0) return v.size()-i; if(k == 0) return v.size()-i-1; } return 0; } }; 题目地址:https://leetcode-cn.com/problems/least-number-of-unique-integers-after-k-removals/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1480. 一维数组的动态和]]></title>
    <url>%2F2020%2F06%2F15%2Fleetcode%201480.%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例：示例 1： 输入：nums = [1,2,3,4] 输出：[1,3,6,10] 解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 输入：nums = [1,1,1,1,1] 输出：[1,2,3,4,5] 解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 输入：nums = [3,1,2,10,1] 输出：[3,4,6,16,17] 提示： 1 &lt;= nums.length &lt;= 1000 -10^6 &lt;= nums[i] &lt;= 10^6 分析：直接对原数组求和即可 代码：class Solution { public: vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) { for(int i = 1; i &lt; nums.size(); i++){ nums[i] = nums[i-1]+nums[i]; } return nums; } }; 题目地址:https://leetcode-cn.com/problems/running-sum-of-1d-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5431. 给房子涂色 III]]></title>
    <url>%2F2020%2F06%2F08%2Fleetcode%205431.%20%E7%BB%99%E6%88%BF%E5%AD%90%E6%B6%82%E8%89%B2%20III%2F</url>
    <content type="text"><![CDATA[题目：在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。 我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 houses = [1,2,2,3,3,2,1,1] ，它包含 5 个街区 [{1}, {2,2}, {3,3}, {2}, {1,1}] 。） 给你一个数组 houses ，一个 m * n 的矩阵 cost 和一个整数 target ，其中： houses[i]：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。 cost[i][j]：是将第 i 个房子涂成颜色 j+1 的花费。 请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 -1 。 示例：示例 1： 输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 输出：9 解释：房子涂色方案为 [1,2,2,1,1] 此方案包含 target = 3 个街区，分别是 [{1}, {2,2}, {1,1}]。 涂色的总花费为 (1 + 1 + 1 + 1 + 5) = 9。 示例 2： 输入：houses = [0,2,1,2,0], cost = [[1,10],[10,1],[10,1],[1,10],[5,1]], m = 5, n = 2, target = 3 输出：11 解释：有的房子已经被涂色了，在此基础上涂色方案为 [2,2,1,2,2] 此方案包含 target = 3 个街区，分别是 [{2,2}, {1}, {2,2}]。 给第一个和最后一个房子涂色的花费为 (10 + 1) = 11。 示例 3： 输入：houses = [0,0,0,0,0], cost = [[1,10],[10,1],[1,10],[10,1],[1,10]], m = 5, n = 2, target = 5 输出：5 示例 4： 输入：houses = [3,1,2,3], cost = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]], m = 4, n = 3, target = 3 输出：-1 解释：房子已经被涂色并组成了 4 个街区，分别是 [{3},{1},{2},{3}] ，无法形成 target = 3 个街区。 提示： m == houses.length == cost.length n == cost[i].length 1 &lt;= m &lt;= 100 1 &lt;= n &lt;= 20 1 &lt;= target &lt;= m 0 &lt;= houses[i] &lt;= n 1 &lt;= cost[i][j] &lt;= 10^4 分析：动态规划 dp[i][j][k] 当第i个房子，最后颜色为j，分成k个街区时的花费 代码：class Solution { public: int minCost(vector&lt;int&gt;&amp; houses, vector&lt;vector&lt;int&gt;&gt;&amp; cost, int m, int n, int target) { // i个房子，最后颜色为j，k个街区 vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(m+1, vector&lt;vector&lt;int&gt;&gt;(n+1, vector&lt;int&gt;(m+1, INT_MAX))); //初始化，第0个房子每种颜色的花费，值为INT_MAX的表示无可用涂色方案 for(int j = 1; j &lt;= n; j++){ if(houses[0] == 0) dp[0][j][0] = cost[0][j-1]; else if(houses[0] == j) dp[0][j][0] = 0; } for(int i = 0; i &lt; m-1; i++){ for(int j = 1; j &lt;= n; j++){ for(int k = 0; k &lt;= i; k++){ for(int l = 1; l &lt;= n; l++){ // 当值为INT_MAX时表示无可行方案，直接跳过 if(dp[i][j][k] == INT_MAX) continue; // 新的房子颜色刚好为l时的情况 if(houses[i+1] == l){ // 如果新的房子颜色和上一个房子相等，街区不会增加，否则街区数量增加 if(l == j) dp[i+1][l][k] = min(dp[i+1][l][k], dp[i][j][k]); else dp[i+1][l][k+1] = min(dp[i+1][l][k+1], dp[i][j][k]); continue; } // 如果新的房子没有上色 if(houses[i+1] == 0){ // 两种上色可能 if(l == j){ dp[i+1][l][k] = min(dp[i+1][l][k], dp[i][j][k] + cost[i+1][l-1]); } else{ dp[i+1][l][k+1] = min(dp[i+1][l][k+1], dp[i][j][k] + cost[i+1][l-1]); } } } } } } int ret = INT_MAX; // 获得涂完所有房子并且街区数量为target-1（从0开始）的最小花费 for(int i = 1; i &lt;= n; i++){ if(dp[m-1][i][target-1] &lt; ret) ret = dp[m-1][i][target-1]; } if(ret == INT_MAX) return -1; //如果为INT_MAX的表示无可用涂色方案，返回-1 return ret; } }; 题目地址:https://leetcode-cn.com/problems/paint-house-iii/submissions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5430. 设计浏览器历史记录]]></title>
    <url>%2F2020%2F06%2F08%2Fleetcode%205430.%20%E8%AE%BE%E8%AE%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[题目：你有一个只支持单个标签页的 浏览器 ，最开始你浏览的网页是 homepage ，你可以访问其他的网站 url ，也可以在浏览历史中后退 steps 步或前进 steps 步。 请你实现 BrowserHistory 类： BrowserHistory(string homepage) ，用 homepage 初始化浏览器类。 void visit(string url) 从当前页跳转访问 url 对应的页面 。执行此操作会把浏览历史前进的记录全部删除。 string back(int steps) 在浏览历史中后退 steps 步。如果你只能在浏览历史中后退至多 x 步且 steps &gt; x ，那么你只后退 x 步。请返回后退 至多 steps 步以后的 url 。 string forward(int steps) 在浏览历史中前进 steps 步。如果你只能在浏览历史中前进至多 x 步且 steps &gt; x ，那么你只前进 x 步。请返回前进 至多 steps步以后的 url 。 示例：输入： [&quot;BrowserHistory&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;visit&quot;,&quot;back&quot;,&quot;back&quot;,&quot;forward&quot;,&quot;visit&quot;,&quot;forward&quot;,&quot;back&quot;,&quot;back&quot;] [[&quot;leetcode.com&quot;],[&quot;google.com&quot;],[&quot;facebook.com&quot;],[&quot;youtube.com&quot;],[1],[1],[1],[&quot;linkedin.com&quot;],[2],[2],[7]] 输出： [null,null,null,null,&quot;facebook.com&quot;,&quot;google.com&quot;,&quot;facebook.com&quot;,null,&quot;linkedin.com&quot;,&quot;google.com&quot;,&quot;leetcode.com&quot;] 解释： BrowserHistory browserHistory = new BrowserHistory(&quot;leetcode.com&quot;); browserHistory.visit(&quot;google.com&quot;); // 你原本在浏览 &quot;leetcode.com&quot; 。访问 &quot;google.com&quot; browserHistory.visit(&quot;facebook.com&quot;); // 你原本在浏览 &quot;google.com&quot; 。访问 &quot;facebook.com&quot; browserHistory.visit(&quot;youtube.com&quot;); // 你原本在浏览 &quot;facebook.com&quot; 。访问 &quot;youtube.com&quot; browserHistory.back(1); // 你原本在浏览 &quot;youtube.com&quot; ，后退到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot; browserHistory.back(1); // 你原本在浏览 &quot;facebook.com&quot; ，后退到 &quot;google.com&quot; 并返回 &quot;google.com&quot; browserHistory.forward(1); // 你原本在浏览 &quot;google.com&quot; ，前进到 &quot;facebook.com&quot; 并返回 &quot;facebook.com&quot; browserHistory.visit(&quot;linkedin.com&quot;); // 你原本在浏览 &quot;facebook.com&quot; 。 访问 &quot;linkedin.com&quot; browserHistory.forward(2); // 你原本在浏览 &quot;linkedin.com&quot; ，你无法前进任何步数。 browserHistory.back(2); // 你原本在浏览 &quot;linkedin.com&quot; ，后退两步依次先到 &quot;facebook.com&quot; ，然后到 &quot;google.com&quot; ，并返回 &quot;google.com&quot; browserHistory.back(7); // 你原本在浏览 &quot;google.com&quot;， 你只能后退一步到 &quot;leetcode.com&quot; ，并返回 &quot;leetcode.com&quot; 提示： 1 &lt;= homepage.length &lt;= 20 1 &lt;= url.length &lt;= 20 1 &lt;= steps &lt;= 100 homepage 和 url 都只包含 ‘.’ 或者小写英文字母。 最多调用 5000 次 visit， back 和 forward 函数。 分析：使用vector来存储访问过的网站，用变量i来记录当前网站是vector中的哪一个 代码：class BrowserHistory { private: vector&lt;string&gt; vs; int i; public: BrowserHistory(string homepage) { // 往vs添加第一个网址，将i置为0 vs.push_back(homepage); i = 0; } void visit(string url) { // 将当前网页之后的页面全部删除，添加新的页面，i++ vs.erase(vs.begin()+i+1, vs.end()); vs.push_back(url); i++; } string back(int steps) { // 按照要求移动指针i，当i小于0的时候置为0 i -= steps; if(i &lt; 0) i = 0; return vs[i]; } string forward(int steps) { // 按照要求移动指针i，当i大于vs的最后一位的时候置为最后一位 i += steps; if(i &gt;= vs.size()) i = vs.size()-1; return vs[i]; } }; /** * Your BrowserHistory object will be instantiated and called as such: * BrowserHistory* obj = new BrowserHistory(homepage); * obj-&gt;visit(url); * string param_2 = obj-&gt;back(steps); * string param_3 = obj-&gt;forward(steps); */ 题目地址:https://leetcode-cn.com/problems/design-browser-history/submissions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5429. 数组中的 k 个最强值]]></title>
    <url>%2F2020%2F06%2F08%2Fleetcode%205429.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%20k%20%E4%B8%AA%E6%9C%80%E5%BC%BA%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 arr 和一个整数 k 。 设 m 为数组的中位数，只要满足下述两个前提之一，就可以判定 arr[i] 的值比 arr[j] 的值更强： |arr[i] - m| &gt; |arr[j] - m| |arr[i] - m| == |arr[j] - m|，且 arr[i] &gt; arr[j] 请返回由数组中最强的 k 个值组成的列表。答案可以以 任意顺序 返回。 中位数 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 n ，那么中位数就是该有序列表（下标从 0 开始）中位于 ((n - 1) / 2) 的元素。 例如 arr = [6, -3, 7, 2, 11]，n = 5：数组排序后得到 arr = [-3, 2, 6, 7, 11] ，数组的中间位置为 m = ((5 - 1) / 2) = 2 ，中位数 arr[m] 的值为 6 。 例如 arr = [-7, 22, 17, 3]，n = 4：数组排序后得到 arr = [-7, 3, 17, 22] ，数组的中间位置为 m = ((4 - 1) / 2) = 1 ，中位数 arr[m] 的值为 3 。 示例：示例 1： 输入：arr = [1,2,3,4,5], k = 2 输出：[5,1] 解释：中位数为 3，按从强到弱顺序排序后，数组变为 [5,1,4,2,3]。最强的两个元素是 [5, 1]。[1, 5] 也是正确答案。 注意，尽管 |5 - 3| == |1 - 3| ，但是 5 比 1 更强，因为 5 &gt; 1 。 示例 2： 输入：arr = [1,1,3,5,5], k = 2 输出：[5,5] 解释：中位数为 3, 按从强到弱顺序排序后，数组变为 [5,5,1,1,3]。最强的两个元素是 [5, 5]。 示例 3： 输入：arr = [6,7,11,7,6,8], k = 5 输出：[11,8,6,6,7] 解释：中位数为 7, 按从强到弱顺序排序后，数组变为 [11,8,6,6,7,7]。 [11,8,6,6,7] 的任何排列都是正确答案。 示例 4： 输入：arr = [6,-3,7,2,11], k = 3 输出：[-3,11,2] 示例 5： 输入：arr = [-7,22,17,3], k = 2 输出：[22,17] 提示： 1 &lt;= arr.length &lt;= 10^5 -10^5 &lt;= arr[i] &lt;= 10^5 1 &lt;= k &lt;= arr.length 分析：直接使用sort排序，按照题目的排序方式写个函数即可 代码：int m; bool bj(int a, int b){ int a1 = a-m; a1 = a1 &lt; 0 ? a1*-1 : a1; int b1 = b-m; b1 = b1 &lt; 0 ? b1*-1 : b1; if(a1 &gt; b1) return true; else if(a1 &lt; b1) return false; else if(a &gt; b) return true; else return false; } class Solution { public: vector&lt;int&gt; getStrongest(vector&lt;int&gt;&amp; arr, int k) { sort(arr.begin(), arr.end()); m = arr[(arr.size()-1)/2]; sort(arr.begin(), arr.end(), bj); vector&lt;int&gt; ret; for(int i = 0; i &lt; k; i++){ ret.push_back(arr[i]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/the-k-strongest-values-in-an-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5428. 重新排列数组]]></title>
    <url>%2F2020%2F06%2F08%2Fleetcode%205428.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。 请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。 示例：示例 1： 输入：nums = [2,5,1,3,4,7], n = 3 输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2： 输入：nums = [1,2,3,4,4,3,2,1], n = 4 输出：[1,4,2,3,3,2,4,1] 示例 3： 输入：nums = [1,1,2,2], n = 2 输出：[1,2,1,2] 提示： 1 &lt;= n &lt;= 500 nums.length == 2n 1 &lt;= nums[i] &lt;= 10^3 分析：两个指针，一个指向前半部分，一个指向后半部分，按照格式重新排列即可 代码：class Solution { public: vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; nums, int n) { vector&lt;int&gt; ret; for(int i = 0, j = nums.size()/2; i &lt; nums.size()/2; i++, j++){ ret.push_back(nums[i]); ret.push_back(nums[j]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/shuffle-the-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5427. 两个盒子中球的颜色数相同的概率]]></title>
    <url>%2F2020%2F06%2F01%2Fleetcode%205427.%20%E4%B8%A4%E4%B8%AA%E7%9B%92%E5%AD%90%E4%B8%AD%E7%90%83%E7%9A%84%E9%A2%9C%E8%89%B2%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A6%82%E7%8E%87%2F</url>
    <content type="text"><![CDATA[题目：桌面上有 2n 个颜色不完全相同的球，球上的颜色共有 k 种。给你一个大小为 k 的整数数组 balls ，其中 balls[i] 是颜色为 i 的球的数量。 所有的球都已经 随机打乱顺序 ，前 n 个球放入第一个盒子，后 n 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。 注意：这两个盒子是不同的。例如，两个球颜色分别为 a 和 b，盒子分别为 [] 和 ()，那么 [a] (b) 和 [b] (a) 这两种分配方式是不同的（请认真阅读示例 1 的解释部分）。 请计算「两个盒子中球的颜色数相同」的情况的概率。 示例：示例 1： 输入：balls = [1,1] 输出：1.00000 解释：球平均分配的方式只有两种： - 颜色为 1 的球放入第一个盒子，颜色为 2 的球放入第二个盒子 - 颜色为 2 的球放入第一个盒子，颜色为 1 的球放入第二个盒子 这两种分配，两个盒子中球的颜色数都相同。所以概率为 2/2 = 1 。 示例 2： 输入：balls = [2,1,1] 输出：0.66667 解释：球的列表为 [1, 1, 2, 3] 随机打乱，得到 12 种等概率的不同打乱方案，每种方案概率为 1/12 ： [1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1] 然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。 这 12 种可能的随机打乱方式中的 8 种满足「两个盒子中球的颜色数相同」。 概率 = 8/12 = 0.66667 示例 3： 输入：balls = [1,2,1,2] 输出：0.60000 解释：球的列表为 [1, 2, 2, 3, 4, 4]。要想显示所有 180 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 108 种情况是比较容易的。 概率 = 108 / 180 = 0.6 。 示例 4： 输入：balls = [3,2,1] 输出：0.30000 解释：球的列表为 [1, 1, 1, 2, 2, 3]。要想显示所有 60 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 18 种情况是比较容易的。 概率 = 18 / 60 = 0.3 。 示例 5： 输入：balls = [6,6,6,6,6,6] 输出：0.90327 提示： 1 &lt;= balls.length &lt;= 8 1 &lt;= balls[i] &lt;= 6 sum(balls) 是偶数 答案与真实值误差在 10^-5 以内，则被视为正确答案 分析：首先要知道求可重复排列的方法 https://www.bilibili.com/video/BV1PA411q7c5?from=search&amp;seid=292759695996125444839分钟时有讲 使用dfs遍历 每次遍历往里面添加一种颜色，将这种颜色所有分配方式尝试一遍 如果遇到左边盒子大于一半的情况，就返回，因为已经不成立了 直到所有颜色取完，判断是否左右两边的颜色数量相同，若相同使用上面公式求出所有排列组合的数量 将所有的可能全部相加再除以所有的排列方式即可 代码：class Solution { private: int n; int bsize; long double fa; public: long double cj(int a){ long double ret = 1; for(int i = 1; i &lt;=a; i++){ ret *= i; } return ret; } void dfs(int y, int l, int r, vector&lt;int&gt; &amp;ly, vector&lt;int&gt; &amp;ry, vector&lt;int&gt;&amp; balls){ if(l &gt; n || r &gt; n) return; if(y == bsize){ if(ly.size() == ry.size()){ long double z = cj(n); for(int i = 0; i &lt; ly.size(); i++){ z /= cj(ly[i]); } long double z1 = cj(n); for(int i = 0; i &lt; ry.size(); i++){ z1 /= cj(ry[i]); } fa += z * z1; } return; } for(int i = 0; i &lt;= balls[y]; i++){ if(i &gt; 0) ly.push_back(i); if(balls[y]-i &gt; 0) ry.push_back(balls[y]-i); dfs(y+1, l+i, r+balls[y]-i, ly, ry, balls); if(i &gt; 0) ly.pop_back(); if(balls[y]-i &gt; 0) ry.pop_back(); } } double getProbability(vector&lt;int&gt;&amp; balls) { vector&lt;int&gt; ly; vector&lt;int&gt; ry; for(int i = 0; i &lt; balls.size(); i++){ n += balls[i]; } n /= 2; bsize = balls.size(); fa = 0; dfs(0, 0, 0, ly, ry, balls); long double z = cj(2*n); for(int i = 0; i &lt; balls.size(); i++){ z /= cj(balls[i]); } return double(fa) / z; } }; 题目地址:https://leetcode-cn.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5426. 重新规划路线]]></title>
    <url>%2F2020%2F06%2F01%2Fleetcode%205426.%20%E9%87%8D%E6%96%B0%E8%A7%84%E5%88%92%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[题目：n 座城市，从 0 到 n-1 编号，其间共有 n-1 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。 路线用 connections 表示，其中 connections[i] = [a, b] 表示从城市 a 到 b 的一条有向路线。 今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。 请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。 题目数据 保证 每个城市在重新规划路线方向后都能到达城市 0 。 示例：示例 1： 输入：n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]] 输出：3 解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。 示例 2： 输入：n = 5, connections = [[1,0],[1,2],[3,2],[3,4]] 输出：2 解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 0 。 示例 3： 输入：n = 3, connections = [[1,0],[2,0]] 输出：0 提示： 2 &lt;= n &lt;= 5 * 10^4 connections.length == n-1 connections[i].length == 2 0 &lt;= connections[i][0], connections[i][1] &lt;= n-1 connections[i][0] != connections[i][1] 分析：将到达每个点和从每个点出发的路径存储到map中 使用bfs从0遍历，统计所有从节点出发的路径的数量 中途记得使用map保存已经遍历过的结点 代码：class Solution { public: int minReorder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) { map&lt;int, vector&lt;int&gt;&gt; m; map&lt;int, vector&lt;int&gt;&gt; m1; for(int i = 0; i &lt; connections.size(); i++){ m[connections[i][0]].push_back(connections[i][1]); m1[connections[i][1]].push_back(connections[i][0]); } queue&lt;int&gt; q; q.push(0); int ret = 0; map&lt;int, int&gt; m2; m2[0] = 1; while(q.size()){ int z = q.front(); q.pop(); for(int i = 0; i &lt; m[z].size(); i++){ if(m2[m[z][i]] == 1) continue; q.push(m[z][i]); m2[m[z][i]] = 1; ret++; } for(int i = 0; i &lt; m1[z].size(); i++){ if(m2[m1[z][i]] == 1) continue; q.push(m1[z][i]); m2[m1[z][i]] = 1; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5425. 切割后面积最大的蛋糕]]></title>
    <url>%2F2020%2F06%2F01%2Fleetcode%205425.%20%E5%88%87%E5%89%B2%E5%90%8E%E9%9D%A2%E7%A7%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E8%9B%8B%E7%B3%95%2F</url>
    <content type="text"><![CDATA[题目：矩形蛋糕的高度为 h 且宽度为 w，给你两个整数数组 horizontalCuts 和 verticalCuts，其中 horizontalCuts[i] 是从矩形蛋糕顶部到第 i 个水平切口的距离，类似地， verticalCuts[j] 是从矩形蛋糕的左侧到第 j 个竖直切口的距离。 请你按数组 horizontalCuts 和 verticalCuts 中提供的水平和竖直位置切割后，请你找出 面积最大 的那份蛋糕，并返回其 面积 。由于答案可能是一个很大的数字，因此需要将结果对 10^9 + 7 取余后返回。 示例：示例 1： 输入：h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3] 输出：4 解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色的那份蛋糕面积最大。 示例 2： 输入：h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1] 输出：6 解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色和黄色的两份蛋糕面积最大。 示例 3： 输入：h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3] 输出：9 提示： 2 &lt;= h, w &lt;= 10^9 1 &lt;= horizontalCuts.length &lt; min(h, 10^5) 1 &lt;= verticalCuts.length &lt; min(w, 10^5) 1 &lt;= horizontalCuts[i] &lt; h 1 &lt;= verticalCuts[i] &lt; w 题目数据保证 horizontalCuts 中的所有元素各不相同 题目数据保证 verticalCuts 中的所有元素各不相同 分析：对horizontalCuts和verticalCuts排序，找出最长的切割间距，相乘即可 代码：class Solution { public: int maxArea(int h, int w, vector&lt;int&gt;&amp; horizontalCuts, vector&lt;int&gt;&amp; verticalCuts) { sort(horizontalCuts.begin(), horizontalCuts.end()); sort(verticalCuts.begin(), verticalCuts.end()); int z = max(horizontalCuts[0], h - horizontalCuts[horizontalCuts.size()-1]); int x = max(verticalCuts[0], w - verticalCuts[verticalCuts.size()-1]); for(int i = 1; i &lt; horizontalCuts.size(); i++){ if(horizontalCuts[i] - horizontalCuts[i-1] &gt; z) z = horizontalCuts[i] - horizontalCuts[i-1]; } for(int j = 1; j &lt; verticalCuts.size(); j++){ if(verticalCuts[j] - verticalCuts[j-1] &gt; x) x = verticalCuts[j] - verticalCuts[j-1]; } return (long long)z*x % 1000000007; } }; 题目地址:https://leetcode-cn.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5424. 数组中两元素的最大乘积]]></title>
    <url>%2F2020%2F06%2F01%2Fleetcode%205424.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。 请你计算并返回该式的最大值。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 示例：示例 1： 输入：nums = [3,4,5,2] 输出：12 解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 示例 2： 输入：nums = [1,5,4,5] 输出：16 解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。 示例 3： 输入：nums = [3,7] 输出：12 提示： 2 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 10^3 分析：直接遍历找出两个最大值，按规则运算即可 代码：class Solution { public: int maxProduct(vector&lt;int&gt;&amp; nums) { sort(nums.begin(), nums.end()); return (nums[nums.size()-1]-1) * (nums[nums.size()-2]-1); } }; 题目地址:https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5419. 两个子序列的最大点积]]></title>
    <url>%2F2020%2F05%2F25%2Fleetcode%205419.%20%E4%B8%A4%E4%B8%AA%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目：给你两个数组 nums1 和 nums2 。 请你返回 nums1 和 nums2 中两个长度相同的 非空 子序列的最大点积。 数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，[2,3,5] 是 [1,2,3,4,5] 的一个子序列而 [1,5,3] 不是。 示例：示例 1： 输入：nums1 = [2,1,-2,5], nums2 = [3,0,-6] 输出：18 解释：从 nums1 中得到子序列 [2,-2] ，从 nums2 中得到子序列 [3,-6] 。 它们的点积为 (2*3 + (-2)*(-6)) = 18 。 示例 2： 输入：nums1 = [3,-2], nums2 = [2,-6,7] 输出：21 解释：从 nums1 中得到子序列 [3] ，从 nums2 中得到子序列 [7] 。 它们的点积为 (3*7) = 21 。 示例 3： 输入：nums1 = [-1,-1], nums2 = [1,1] 输出：-1 解释：从 nums1 中得到子序列 [-1] ，从 nums2 中得到子序列 [1] 。 它们的点积为 -1 。 提示： 1 &lt;= nums1.length, nums2.length &lt;= 500 -1000 &lt;= nums1[i], nums2[i] &lt;= 100 分析：动态规划 dp[i][j] nums1到第i位，nums2到第j位时的最大点积 状态转移方程：dp[i][j] = max(dp[i-1][j-1] + nums1[i-1] * nums2[j-1], max(dp[i-1][j], dp[i][j-1])); 代码：class Solution { public: int maxDotProduct(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;vector&lt;int&gt;&gt; dp(nums1.size()+1, vector&lt;int&gt;(nums2.size()+1, 0)); int ret = INT_MIN; for(int i = 1; i &lt;= nums1.size(); i++){ for(int j = 1; j &lt;= nums2.size(); j++){ dp[i][j] = max(dp[i-1][j-1] + nums1[i-1] * nums2[j-1], max(dp[i-1][j], dp[i][j-1])); ret = ret &gt; dp[i-1][j-1] + nums1[i-1] * nums2[j-1] ? ret : dp[i-1][j-1] + nums1[i-1] * nums2[j-1]; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/max-dot-product-of-two-subsequences/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5418. 二叉树中的伪回文路径]]></title>
    <url>%2F2020%2F05%2F25%2Fleetcode%205418.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%9B%9E%E6%96%87%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目：给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。 请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。 示例：示例 1： 输入：root = [2,3,1,3,1,null,1] 输出：2 解释：上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。 在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。 示例 2： 输入：root = [2,1,1,1,3,null,null,null,null,null,1] 输出：1 解释：上图为给定二叉树。总共有 3 条从根到叶子的路径：绿色路径 [2,1,1] ，路径 [2,1,3,1] 和路径 [2,1] 。 这些路径中只有绿色路径是伪回文路径，因为 [2,1,1] 存在回文排列 [1,2,1] 。 示例 3： 输入：root = [9] 输出：1 提示： 给定二叉树的节点数目在 1 到 10^5 之间。 节点值在 1 到 9 之间。 分析：使用dfs，中途存储经过结点的各个值的数量 到达叶节点时判断：如果有偶数个结点，存在回文序列的要求为每个值都出现过偶数次；如果有奇数个结点，存在回文序列的要求为有一个值出现奇数次，其他值出现偶数次 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: int ret; public: void dfs(TreeNode* root, vector&lt;int&gt; v){ v[root-&gt;val]++; if(root -&gt; left != NULL){ dfs(root-&gt;left, v); } if(root -&gt; right != NULL){ dfs(root-&gt;right, v); } if(root -&gt; left == NULL &amp;&amp; root -&gt; right == NULL){ int z = 0; int x = 0; for(int i = 0; i &lt; v.size(); i++){ x += v[i]; if(v[i] % 2 == 1) z++; } if(x % 2 == 0 &amp;&amp; z == 0){ ret++; } else if(x % 2 == 1 &amp;&amp; z &lt; 2){ ret++; } } } int pseudoPalindromicPaths (TreeNode* root) { ret = 0; vector&lt;int&gt; v(10, 0); dfs(root, v); return ret; } }; 题目地址:https://leetcode-cn.com/problems/pseudo-palindromic-paths-in-a-binary-tree/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5417. 定长子串中元音的最大数目]]></title>
    <url>%2F2020%2F05%2F25%2Fleetcode%205417.%20%E5%AE%9A%E9%95%BF%E5%AD%90%E4%B8%B2%E4%B8%AD%E5%85%83%E9%9F%B3%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你字符串 s 和整数 k 。 请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。 英文中的 元音字母 为（a, e, i, o, u）。 示例：示例 1： 输入：s = &quot;abciiidef&quot;, k = 3 输出：3 解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。 示例 2： 输入：s = &quot;aeiou&quot;, k = 2 输出：2 解释：任意长度为 2 的子字符串都包含 2 个元音字母。 示例 3： 输入：s = &quot;leetcode&quot;, k = 3 输出：2 解释：&quot;lee&quot;、&quot;eet&quot; 和 &quot;ode&quot; 都包含 2 个元音字母。 示例 4： 输入：s = &quot;rhythms&quot;, k = 4 输出：0 解释：字符串 s 中不含任何元音字母。 示例 5： 输入：s = &quot;tryhard&quot;, k = 4 输出：1 提示： 1 &lt;= s.length &lt;= 10^5 s 由小写英文字母组成 1 &lt;= k &lt;= s.length 分析：使用滑动窗口来统计长度为k内的最大元音字母数 代码：class Solution { public: int maxVowels(string s, int k) { int z = 0; int ret = 0; for(int l = 0, r = 0; r &lt; s.size(); r++){ if(s[r] == &apos;a&apos;) z++; else if(s[r] == &apos;e&apos;) z++; else if(s[r] == &apos;i&apos;) z++; else if(s[r] == &apos;o&apos;) z++; else if(s[r] == &apos;u&apos;) z++; if(r - l &gt;= k){ if(s[l] == &apos;a&apos;) z--; else if(s[l] == &apos;e&apos;) z--; else if(s[l] == &apos;i&apos;) z--; else if(s[l] == &apos;o&apos;) z--; else if(s[l] == &apos;u&apos;) z--; l++; } ret = max(z &lt; k ? z:k, ret); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5416. 检查单词是否为句中其他单词的前缀]]></title>
    <url>%2F2020%2F05%2F25%2Fleetcode%205416.%20%E6%A3%80%E6%9F%A5%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A5%E4%B8%AD%E5%85%B6%E4%BB%96%E5%8D%95%E8%AF%8D%E7%9A%84%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。 请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。 如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。 如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。 如果 searchWord 不是任何单词的前缀，则返回 -1 。 字符串 S 的 「前缀」是 S 的任何前导连续子字符串。 示例：示例 1： 输入：sentence = &quot;i love eating burger&quot;, searchWord = &quot;burg&quot; 输出：4 解释：&quot;burg&quot; 是 &quot;burger&quot; 的前缀，而 &quot;burger&quot; 是句子中第 4 个单词。 示例 2： 输入：sentence = &quot;this problem is an easy problem&quot;, searchWord = &quot;pro&quot; 输出：2 解释：&quot;pro&quot; 是 &quot;problem&quot; 的前缀，而 &quot;problem&quot; 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。 示例 3： 输入：sentence = &quot;i am tired&quot;, searchWord = &quot;you&quot; 输出：-1 解释：&quot;you&quot; 不是句子中任何单词的前缀。 示例 4： 输入：sentence = &quot;i use triple pillow&quot;, searchWord = &quot;pill&quot; 输出：4 示例 5： 输入：sentence = &quot;hello from the other side&quot;, searchWord = &quot;they&quot; 输出：-1 提示： 1 &lt;= sentence.length &lt;= 100 1 &lt;= searchWord.length &lt;= 10 sentence 由小写英文字母和空格组成。 searchWord 由小写英文字母组成。 前缀就是紧密附着于词根的语素，中间不能插入其它成分，并且它的位置是固定的——-位于词根之前。（引用自 前缀_百度百科 ） 分析：直接遍历，以遇到空格来分隔 注意得是前缀，可以通过同时对两个字符串计数来保证是否是前缀 代码：class Solution { public: int isPrefixOfWord(string sentence, string searchWord) { int z = 1; for(int i = 0, j = 0, k = 0; i &lt; sentence.size(); i++){ k++; if(sentence[i] == &apos; &apos;) { z++; k = 0; } if(sentence[i] == searchWord[j]){ j++; if(j == searchWord.size() &amp;&amp; k == j){ return z; } } else { j = 0; } } return -1; } }; 题目地址:https://leetcode-cn.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5415. 圆形靶内的最大飞镖数量]]></title>
    <url>%2F2020%2F05%2F18%2Fleetcode%205415.%20%E5%9C%86%E5%BD%A2%E9%9D%B6%E5%86%85%E7%9A%84%E6%9C%80%E5%A4%A7%E9%A3%9E%E9%95%96%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：墙壁上挂着一个圆形的飞镖靶。现在请你蒙着眼睛向靶上投掷飞镖。 投掷到墙上的飞镖用二维平面上的点坐标数组表示。飞镖靶的半径为 r 。 请返回能够落在 任意 半径为 r 的圆形靶内或靶上的最大飞镖数。 示例：示例 1： 输入：points = [[-2,0],[2,0],[0,2],[0,-2]], r = 2 输出：4 解释：如果圆形的飞镖靶的圆心为 (0,0) ，半径为 2 ，所有的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 4 。 示例 2： 输入：points = [[-3,0],[3,0],[2,6],[5,4],[0,9],[7,8]], r = 5 输出：5 解释：如果圆形的飞镖靶的圆心为 (0,4) ，半径为 5 ，则除了 (7,8) 之外的飞镖都落在靶上，此时落在靶上的飞镖数最大，值为 5 。 示例 3： 输入：points = [[-2,0],[2,0],[0,2],[0,-2]], r = 1 输出：1 示例 4： 输入：points = [[1,2],[3,5],[1,-1],[2,3],[4,1],[1,3]], r = 2 输出：4 提示： 1 &lt;= points.length &lt;= 100 points[i].length == 2 -10^4 &lt;= points[i][0], points[i][1] &lt;= 10^4 1 &lt;= r &lt;= 5000 分析：每两个点画圆可以画出两个圆 对所有的点遍历，画出所有可能的圆 判断每个圆中最多的点数 方法来自：https://www.bilibili.com/video/BV12z4y1R7GW?p=5 代码：class Solution { public: int check(vector&lt;vector&lt;int&gt;&gt;&amp; points, double xc, double yc, int r){ int ret = 0; for(int i = 0; i &lt; points.size(); i++){ if((points[i][0] - xc) * (points[i][0] - xc) + (points[i][1] - yc) * (points[i][1] - yc) &lt; r * r + 1e-7){ ret++; } } return ret; } int numPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, int r) { int ret = 1; for(int i = 0; i &lt; points.size(); i++){ int x1 = points[i][0]; int y1 = points[i][1]; for(int j = i+1; j &lt; points.size(); j++){ int x2 = points[j][0]; int y2 = points[j][1]; int d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1); if(d2 &gt; r * r * 4) continue; double xm = (x1 + x2) / 2.0; double ym = (y1 + y2) / 2.0; double d = sqrt(d2); double q = sqrt(r * r - d2 / 4.0); double v1 = x1 - x2; double v2 = y1 - y2; double xc = xm - v2 / d * q; double yc = ym + v1 / d * q; ret = max(ret, check(points, xc, yc, r)); xc = xm + v2 / d * q; yc = ym - v1 / d * q; ret = max(ret, check(points, xc, yc, r)); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5414. 收藏清单]]></title>
    <url>%2F2020%2F05%2F18%2Fleetcode%205414.%20%E6%94%B6%E8%97%8F%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 favoriteCompanies ，其中 favoriteCompanies[i] 是第 i 名用户收藏的公司清单（下标从 0 开始）。 请找出不是其他任何人收藏的公司清单的子集的收藏清单，并返回该清单下标。下标需要按升序排列。 示例：示例 1： 输入：favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;,&quot;microsoft&quot;],[&quot;google&quot;,&quot;facebook&quot;],[&quot;google&quot;],[&quot;amazon&quot;]] 输出：[0,1,4] 解释： favoriteCompanies[2]=[&quot;google&quot;,&quot;facebook&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 的子集。 favoriteCompanies[3]=[&quot;google&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 和 favoriteCompanies[1]=[&quot;google&quot;,&quot;microsoft&quot;] 的子集。 其余的收藏清单均不是其他任何人收藏的公司清单的子集，因此，答案为 [0,1,4] 。 示例 2： 输入：favoriteCompanies = [[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;],[&quot;leetcode&quot;,&quot;amazon&quot;],[&quot;facebook&quot;,&quot;google&quot;]] 输出：[0,1] 解释：favoriteCompanies[2]=[&quot;facebook&quot;,&quot;google&quot;] 是 favoriteCompanies[0]=[&quot;leetcode&quot;,&quot;google&quot;,&quot;facebook&quot;] 的子集，因此，答案为 [0,1] 。 示例 3： 输入：favoriteCompanies = [[&quot;leetcode&quot;],[&quot;google&quot;],[&quot;facebook&quot;],[&quot;amazon&quot;]] 输出：[0,1,2,3] 提示： 1 &lt;= favoriteCompanies.length &lt;= 100 1 &lt;= favoriteCompanies[i].length &lt;= 500 1 &lt;= favoriteCompanies[i][j].length &lt;= 20 favoriteCompanies[i] 中的所有字符串 各不相同 。 用户收藏的公司清单也 各不相同 ，也就是说，即便我们按字母顺序排序每个清单， favoriteCompanies[i] != favoriteCompanies[j] 仍然成立。 所有字符串仅包含小写英文字母。 分析：可以使用unordered_map来存储用户收藏的公司清单之后每两个用户之间的清单进行比较即可 或者可以照这个方法来：https://leetcode-cn.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/solution/favorite-companies-by-ikaruga/ 代码：class Solution { public: vector&lt;int&gt; peopleIndexes(vector&lt;vector&lt;string&gt;&gt;&amp; favoriteCompanies) { unordered_map&lt;string, int&gt; vm[100]; vector&lt;int&gt; ret; for(int i = 0; i &lt; favoriteCompanies.size(); i++){ for(int j = 0; j &lt; favoriteCompanies[i].size(); j++){ vm[i][favoriteCompanies[i][j]] = 1; } } for(int i = 0; i &lt; favoriteCompanies.size(); i++){ bool b = true; for(int j = 0; j &lt; favoriteCompanies.size() &amp;&amp; b; j++){ if(i == j) continue; int k = 0; for(; k &lt; favoriteCompanies[i].size(); k++){ if(vm[j][favoriteCompanies[i][k]] == 0){ break; } } if(k == favoriteCompanies[i].size() &amp;&amp; vm[j][favoriteCompanies[i][k-1]] != 0){ b = false; } } if(b) ret.push_back(i); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/solution/favorite-companies-by-ikaruga/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5413. 重新排列句子中的单词]]></title>
    <url>%2F2020%2F05%2F18%2Fleetcode%205413.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[题目：「句子」是一个用空格分隔单词的字符串。给你一个满足下述格式的句子 text : 句子的首字母大写text 中的每个单词都用单个空格分隔。请你重新排列 text 中的单词，使所有单词按其长度的升序排列。如果两个单词的长度相同，则保留其在原句子中的相对顺序。 请同样按上述格式返回新的句子。 示例：示例 1： 输入：text = &quot;Leetcode is cool&quot; 输出：&quot;Is cool leetcode&quot; 解释：句子中共有 3 个单词，长度为 8 的 &quot;Leetcode&quot; ，长度为 2 的 &quot;is&quot; 以及长度为 4 的 &quot;cool&quot; 。 输出需要按单词的长度升序排列，新句子中的第一个单词首字母需要大写。 示例 2： 输入：text = &quot;Keep calm and code on&quot; 输出：&quot;On and keep calm code&quot; 解释：输出的排序情况如下： &quot;On&quot; 2 个字母。 &quot;and&quot; 3 个字母。 &quot;keep&quot; 4 个字母，因为存在长度相同的其他单词，所以它们之间需要保留在原句子中的相对顺序。 &quot;calm&quot; 4 个字母。 &quot;code&quot; 4 个字母。 示例 3： 输入：text = &quot;To be or not to be&quot; 输出：&quot;To be or to be not&quot; 提示： text 以大写字母开头，然后包含若干小写字母以及单词间的单个空格。 1 &lt;= text.length &lt;= 10^5 分析：先将所有的单词变成小写后存储按题目要求排序后输出，注意第一个改成大写 代码：struct t{ string str; int i; }; bool b(t t1, t t2){ if(t1.str.size() &lt; t2.str.size()) return true; if(t1.str.size() &gt; t2.str.size()) return false; if(t1.i &lt; t2.i) return true; return false; } class Solution { public: string arrangeWords(string text) { vector&lt;t&gt; v; string s = &quot;&quot;; text[0] = text[0] - (&apos;A&apos; - &apos;a&apos;); for(int i = 0; i &lt; text.size(); i++){ if(text[i] == &apos; &apos;){ t t1 = {s, i}; v.push_back(t1); s = &quot;&quot;; } else{ s += text[i]; } } t t1 = {s, int(text.size()-1)}; v.push_back(t1); sort(v.begin(), v.end(), b); string ret = &quot;&quot;; for(int i = 0; i &lt; v.size(); i++){ if(i == 0){ v[i].str[0] = v[i].str[0] + (&apos;A&apos; - &apos;a&apos;); } ret += v[i].str; ret += &quot; &quot;; } ret.pop_back(); return ret; } }; 题目地址:https://leetcode-cn.com/problems/rearrange-words-in-a-sentence/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5412. 在既定时间做作业的学生人数]]></title>
    <url>%2F2020%2F05%2F18%2Fleetcode%205412.%20%E5%9C%A8%E6%97%A2%E5%AE%9A%E6%97%B6%E9%97%B4%E5%81%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BA%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。 已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。 请返回在查询时间 queryTime 时正在做作业的学生人数。形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。 示例：示例 1： 输入：startTime = [1,2,3], endTime = [3,2,7], queryTime = 4 输出：1 解释：一共有 3 名学生。 第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。 第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。 第二名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。 示例 2： 输入：startTime = [4], endTime = [4], queryTime = 4 输出：1 解释：在查询时间只有一名学生在做作业。 示例 3： 输入：startTime = [4], endTime = [4], queryTime = 5 输出：0 示例 4： 输入：startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7 输出：0 示例 5： 输入：startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5 输出：5 提示： startTime.length == endTime.length 1 &lt;= startTime.length &lt;= 100 1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000 1 &lt;= queryTime &lt;= 1000 分析：对每名学生进行判断，是否在 queryTime 时处于做作业状态 代码：class Solution { public: int busyStudent(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, int queryTime) { int ret = 0; for(int i = 0; i &lt; startTime.size(); i++){ if(startTime[i] &lt;= queryTime &amp;&amp; endTime[i] &gt;= queryTime){ ret++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-students-doing-homework-at-a-given-time/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1444. 切披萨的方案数]]></title>
    <url>%2F2020%2F05%2F11%2Fleetcode%201444.%20%E5%88%87%E6%8A%AB%E8%90%A8%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个 rows x cols 大小的矩形披萨和一个整数 k ，矩形包含两种字符： ‘A’ （表示苹果）和 ‘.’ （表示空白格子）。你需要切披萨 k-1 次，得到 k 块披萨并送给别人。 切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。 请你返回确保每一块披萨包含 至少 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 10^9 + 7 取余的结果。 示例：示例 1： 输入：pizza = [&quot;A..&quot;,&quot;AAA&quot;,&quot;...&quot;], k = 3 输出：3 解释：上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。 示例 2： 输入：pizza = [&quot;A..&quot;,&quot;AA.&quot;,&quot;...&quot;], k = 3 输出：1 示例 3： 输入：pizza = [&quot;A..&quot;,&quot;A..&quot;,&quot;...&quot;], k = 1 输出：1 提示： 1 &lt;= rows, cols &lt;= 50 rows == pizza.length cols == pizza[i].length 1 &lt;= k &lt;= 10 pizza 只包含字符 ‘A’ 和 ‘.’ 。 分析：使用动态规划 dp[i][j][k]，表示所剩披萨的最左上角坐标为ij，k表示已经切的刀数 代码：class Solution { public: int ways(vector&lt;string&gt;&amp; pizza, int k) { vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt; dp(pizza.size(), vector&lt;vector&lt;long long&gt;&gt;(pizza[0].size(), vector&lt;long long&gt;(k, 0))); vector&lt;vector&lt;int&gt;&gt; v1(pizza.size()+1, vector&lt;int&gt;(pizza[0].size()+1, 0)); // 存储以每个节点为右下角的矩形中苹果的数量 dp[0][0][0] = 1; // 初始化一刀未切为1 for(int i = 1; i &lt;= pizza.size(); i++){ // 苹果数量初始化 for(int j = 1; j &lt;= pizza[0].size(); j++){ v1[i][j] = v1[i][j-1] + v1[i-1][j] - v1[i-1][j-1] +int(pizza[i-1][j-1] == &apos;A&apos;); } } for(int k1 = 0; k1 &lt; k-1; k1++){ for(int i = 0; i &lt; pizza.size(); i++){ for(int j = 0; j &lt; pizza[0].size(); j++){ int q = v1[i][pizza[0].size()] + v1[pizza.size()][j] - v1[i][j]; // 对每种可能的切法进行遍历 for(int i1 = i+1; i1 &lt; pizza.size(); i1++){ int q1 = v1[i1][pizza[0].size()] + v1[pizza.size()][j] - v1[i1][j]; // 需要判断切掉的部分有苹果并且所剩的也有苹果 if(q1 - q &gt; 0 &amp;&amp; v1[pizza.size()][pizza[0].size()] - q1 &gt; 0){ dp[i1][j][k1+1] = (dp[i1][j][k1+1] + dp[i][j][k1]) % 1000000007; } } for(int j1 = j+1; j1 &lt; pizza[0].size(); j1++){ int q1 = v1[i][pizza[0].size()] + v1[pizza.size()][j1] - v1[i][j1]; if(q1 - q &gt; 0 &amp;&amp; v1[pizza.size()][pizza[0].size()] - q1 &gt; 0){ dp[i][j1][k1+1] = (dp[i][j1][k1+1] + dp[i][j][k1]) % 1000000007; } } } } } int ret = 0; for(int i = 0; i &lt; pizza.size(); i++){ // 统计分成k块的方案数 for(int j = 0; j &lt; pizza[0].size(); j++){ ret += dp[i][j][k-1]; ret %= 1000000007; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-ways-of-cutting-a-pizza/submissions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5406. 收集树上所有苹果的最少时间]]></title>
    <url>%2F2020%2F05%2F11%2Fleetcode%205406.%20%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%8A%E6%89%80%E6%9C%89%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：给你一棵有 n 个节点的无向树，节点编号为 0 到 n-1 ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 节点 0 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。 无向树的边由 edges 给出，其中 edges[i] = [fromi, toi] ，表示有一条边连接 from 和 toi 。除此以外，还有一个布尔数组 hasApple ，其中 hasApple[i] = true 代表节点 i 有一个苹果，否则，节点 i 没有苹果。 示例：示例 1： 输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false] 输出：8 解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。 示例 2： 输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false] 输出：6 解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。 示例 3： 输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false] 输出：0 提示： 1 &lt;= n &lt;= 10^5 edges.length == n-1 edges[i].length == 2 0 &lt;= fromi, toi &lt;= n-1 fromi &lt; toi hasApple.length == n 分析：将每个节点的子树用 map&lt;int, vector&gt; 存储，将每个节点对应的父节点用 map&lt;int, int&gt; 存储。 使用hasApple将每个节点的子树和当前节点所拥有的苹果数存储 dfs遍历，如果当前节点下还有子树有苹果就继续往下遍历否则返回 返回遍历的结点数*2即可 代码：class Solution { private: map&lt;int, vector&lt;int&gt;&gt; m; map&lt;int, int&gt; m1; int ret; public: int dfs(vector&lt;int&gt;&amp; vb, int z, vector&lt;bool&gt;&amp; hasApple){ if(z &gt;= vb.size() || vb[z] == 0) return 0; ret += 2; int x = 0; if(hasApple[z]) x++; vb[z] -= x; if(vb[z] &gt; 0){ for(int i = 0; i &lt; m[z].size() &amp;&amp; vb[z] &gt; 0; i++){ int c = dfs(vb, m[z][i], hasApple); x += c; vb[z] -= c; } } return x; } int minTime(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;bool&gt;&amp; hasApple) { vector&lt;int&gt; vb(n, 0); ret = -2; for(int i = 0; i &lt; edges.size(); i++){ m[edges[i][0]].push_back(edges[i][1]); m1[edges[i][1]] = edges[i][0]; } for(int i = n-1; i &gt;= 0; i--){ if(hasApple[i]){ int z = i; while(z &gt; 0){ vb[z]++; z = m1[z]; } vb[z]++; } } dfs(vb, 0, hasApple); return ret &gt; 0 ? ret : 0; } }; 题目地址:https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5405. 形成两个异或相等数组的三元组数目]]></title>
    <url>%2F2020%2F05%2F11%2Fleetcode%205405.%20%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 arr 。 现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;= i &lt; j &lt;= k &lt; arr.length) 。 a 和 b 定义如下： a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ … ^ arr[k] 注意：^ 表示 按位异或 操作。 请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。 示例：示例 1： 输入：arr = [2,3,1,6,7] 输出：4 解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4) 示例 2： 输入：arr = [1,1,1,1,1] 输出：10 示例 3： 输入：arr = [2,3] 输出：0 示例 4： 输入：arr = [1,3,5,7,9] 输出：3 示例 5： 输入：arr = [7,11,12,9,5,2,7,17,22] 输出：8 提示： 1 &lt;= arr.length &lt;= 300 1 &lt;= arr[i] &lt;= 10^8 分析：如果从i到k异或等于0，那么这些数字就可以分成k-i种，只要使用O（n^2）的方法就可以遍历全部数字 代码：class Solution { public: int countTriplets(vector&lt;int&gt;&amp; arr) { int z; int ret = 0; for(int i = 0; i &lt; arr.size(); i++){ z = arr[i]; for(int j = i+1; j &lt; arr.size(); j++){ z = z ^ arr[j]; if(z == 0){ ret += j-i; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5404. 用栈操作构建数组]]></title>
    <url>%2F2020%2F05%2F11%2Fleetcode%205404.%20%E7%94%A8%E6%A0%88%E6%93%8D%E4%BD%9C%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个目标数组 target 和一个整数 n。每次迭代，需要从 list = {1,2,3…, n} 中依序读取一个数字。 请使用下述操作来构建目标数组 target ： Push：从 list 中读取一个新元素， 并将其推入数组中。 Pop：删除数组中的最后一个元素。 如果目标数组构建完成，就停止读取更多元素。 题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。 请返回构建目标数组所用的操作序列。 题目数据保证答案是唯一的。 示例：示例 1： 输入：target = [1,3], n = 3 输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;] 解释： 读取 1 并自动推入数组 -&gt; [1] 读取 2 并自动推入数组，然后删除它 -&gt; [1] 读取 3 并自动推入数组 -&gt; [1,3] 示例 2： 输入：target = [1,2,3], n = 3 输出：[&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;] 示例 3： 输入：target = [1,2], n = 4 输出：[&quot;Push&quot;,&quot;Push&quot;] 解释：只需要读取前 2 个数字就可以停止。 示例 4： 输入：target = [2,3,4], n = 4 输出：[&quot;Push&quot;,&quot;Pop&quot;,&quot;Push&quot;,&quot;Push&quot;,&quot;Push&quot;] 提示： 1 &lt;= target.length &lt;= 100 1 &lt;= target[i] &lt;= 100 1 &lt;= n &lt;= 100 target 是严格递增的 分析：遍历所有元素，每个元素都push，如果当前元素不是需要的元素就pop，结束条件元素全部遍历完或者目标数组构建完成 代码：class Solution { public: vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) { vector&lt;string&gt; ret; for(int i = 1, j = 0; i &lt;= n &amp;&amp; j &lt; target.size(); i++){ ret.push_back(&quot;Push&quot;); if(i != target[j]) ret.push_back(&quot;Pop&quot;); else j++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/build-an-array-with-stack-operations/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1439. 有序矩阵中的第 k 个最小数组和]]></title>
    <url>%2F2020%2F05%2F06%2Fleetcode%201439.%20%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E7%AC%AC%20k%20%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0%E7%BB%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个 m * n 的矩阵 mat，以及一个整数 k ，矩阵中的每一行都以非递减的顺序排列。 你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 最小 数组和。 示例：示例 1： 输入：mat = [[1,3,11],[2,4,6]], k = 5 输出：7 解释：从每一行中选出一个元素，前 k 个和最小的数组分别是： [1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。 示例 2： 输入：mat = [[1,3,11],[2,4,6]], k = 9 输出：17 示例 3： 输入：mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7 输出：9 解释：从每一行中选出一个元素，前 k 个和最小的数组分别是： [1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。 示例 4： 输入：mat = [[1,1,10],[2,2,9]], k = 7 输出：12 提示： m == mat.length n == mat.length[i] 1 &lt;= m, n &lt;= 40 1 &lt;= k &lt;= min(200, n ^ m) 1 &lt;= mat[i][j] &lt;= 5000 mat[i] 是一个非递减数组 分析：因为k的最大值只有200，所以可以使用dp来记录200个最小的值 dp[i][j], 表示遍历到第i行时第j个最小的值 dp[i] = dp[i-1]中所有的值和mat[i]的值的组合中前200个最小的值 代码：class Solution { public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) { vector&lt;vector&lt;int&gt;&gt; dp(mat.size()); for(int i = 0; i &lt; mat[0].size(); i++){ dp[0].push_back(mat[0][i]); } for(int i = 1; i &lt; mat.size(); i++){ vector&lt;int&gt; v; for(int j = 0; j &lt; dp[i-1].size(); j++){ for(int k = 0; k &lt; mat[i].size(); k++){ v.push_back(dp[i-1][j] + mat[i][k]); } } sort(v.begin(), v.end()); for(int j = 0; j &lt; 200 &amp;&amp; j &lt; v.size(); j++){ dp[i].push_back(v[j]); } } return dp[mat.size()-1][k-1]; } }; 题目地址:https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1438. 绝对差不超过限制的最长连续子数组]]></title>
    <url>%2F2020%2F05%2F06%2Fleetcode%201438.%20%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。 如果不存在满足条件的子数组，则返回 0 。 示例：示例 1： 输入：nums = [8,2,4,7], limit = 4 输出：2 解释：所有子数组如下： [8] 最大绝对差 |8-8| = 0 &lt;= 4. [8,2] 最大绝对差 |8-2| = 6 &gt; 4. [8,2,4] 最大绝对差 |8-2| = 6 &gt; 4. [8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4. [2] 最大绝对差 |2-2| = 0 &lt;= 4. [2,4] 最大绝对差 |2-4| = 2 &lt;= 4. [2,4,7] 最大绝对差 |2-7| = 5 &gt; 4. [4] 最大绝对差 |4-4| = 0 &lt;= 4. [4,7] 最大绝对差 |4-7| = 3 &lt;= 4. [7] 最大绝对差 |7-7| = 0 &lt;= 4. 因此，满足题意的最长子数组的长度为 2 。 示例 2： 输入：nums = [10,1,2,4,7,2], limit = 5 输出：4 解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。 示例 3： 输入：nums = [4,2,2,2,4,4,2,2], limit = 0 输出：3 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^9 0 &lt;= limit &lt;= 10^9 分析：活动窗口，l表示窗口最左边的下标，r表示窗口最右边的下标使用multiset来按大小存储窗口内的值每添加1个值进窗口就计算一次窗口内的最大值和最小值的差，如果大于limit，l++，再次判断是否大于limit，直到差小于或等于limit为止。中途记录窗口最大时的大小即可 代码：class Solution { public: int longestSubarray(vector&lt;int&gt;&amp; nums, int limit) { multiset&lt;int&gt; m; int ret = 0; for(int l = 0, r = 0; r &lt; nums.size(); r++){ m.insert(nums[r]); if(*--m.end() - *m.begin() &lt;= limit){ ret = max(ret, r-l+1); } else{ while(*--m.end() - *m.begin() &gt; limit){ m.erase(m.find(nums[l])); l++; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1437. 是否所有 1 都至少相隔 k 个元素]]></title>
    <url>%2F2020%2F05%2F06%2Fleetcode%201437.%20%E6%98%AF%E5%90%A6%E6%89%80%E6%9C%89%201%20%E9%83%BD%E8%87%B3%E5%B0%91%E7%9B%B8%E9%9A%94%20k%20%E4%B8%AA%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目：给你一个由若干 0 和 1 组成的数组 nums 以及整数 k。如果所有 1 都至少相隔 k 个元素，则返回 True ；否则，返回 False 。 示例：示例 1： 输入：nums = [1,0,0,0,1,0,0,1], k = 2 输出：true 解释：每个 1 都至少相隔 2 个元素。 示例 2： 输入：nums = [1,0,0,1,0,1], k = 2 输出：false 解释：第二个 1 和第三个 1 之间只隔了 1 个元素。 示例 3： 输入：nums = [1,1,1,1,1], k = 0 输出：true 示例 4： 输入：nums = [0,1,0,1], k = 1 输出：true 提示： 1 &lt;= nums.length &lt;= 10^5 0 &lt;= k &lt;= nums.length nums[i] 的值为 0 或 1 分析：重点就在于第一个1前面和最后一个1后面可以不管，之后只需要统计中间是否相隔大于等于k 代码：class Solution {public: bool kLengthApart(vector&amp; nums, int k) { int z = INT_MAX; bool b = false; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] == 1){ if(z &lt; k) return false; b = true; z = 0; } else if(b){ z++; } } return true; } }; 题目地址:https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1436. 旅行终点站]]></title>
    <url>%2F2020%2F05%2F06%2Fleetcode%201436.%20%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99%2F</url>
    <content type="text"><![CDATA[题目：给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。 题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。 示例：示例 1： 输入：paths = [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]] 输出：&quot;Sao Paulo&quot; 解释：从 &quot;London&quot; 出发，最后抵达终点站 &quot;Sao Paulo&quot; 。本次旅行的路线是 &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot; 。 示例 2： 输入：paths = [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]] 输出：&quot;A&quot; 解释：所有可能的线路是： &quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;. &quot;C&quot; -&gt; &quot;A&quot;. &quot;A&quot;. 显然，旅行终点站是 &quot;A&quot; 。 示例 3： 输入：paths = [[&quot;A&quot;,&quot;Z&quot;]] 输出：&quot;Z&quot; 提示： 1 &lt;= paths.length &lt;= 100 paths[i].length == 2 1 &lt;= cityAi.length, cityBi.length &lt;= 10 cityAi != cityBi 所有字符串均由大小写英文字母和空格字符组成。 分析：遍历所有的旅游路线，找到其中只有起点没有目的的站点 代码：class Solution {public: string destCity(vector&lt;vector&gt;&amp; paths) { map&lt;string, int&gt; m; for(int i = 0; i &lt; paths.size(); i++){ m[paths[i][0]] = 1; } for(int i = 0; i &lt; paths.size(); i++){ if(m[paths[i][1]] == 0) return paths[i][1]; } return “”; }}; 题目地址:https://leetcode-cn.com/problems/destination-city/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5180. 带限制的子序列和]]></title>
    <url>%2F2020%2F04%2F27%2Fleetcode%205180.%20%E5%B8%A6%E9%99%90%E5%88%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 和一个整数 k ，请你返回 非空 子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 nums[i] 和 nums[j] ，它们在原数组中的下标 i 和 j 满足 i &lt; j 且 j - i &lt;= k 。 数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。 示例：示例 1： 输入：nums = [10,2,-10,5,20], k = 2 输出：37 解释：子序列为 [10, 2, 5, 20] 。 示例 2： 输入：nums = [-1,-2,-3], k = 1 输出：-1 解释：子序列必须是非空的，所以我们选择最大的数字。 示例 3： 输入：nums = [10,-2,-10,-5,20], k = 2 输出：23 解释：子序列为 [10, -2, -5, 20] 。 提示： 1 &lt;= k &lt;= nums.length &lt;= 10^5 -10^4 &lt;= nums[i] &lt;= 10^4 分析：使用移动窗口的dp dp[i], 遍历到i的最佳删除方式 dp[i] = max（nums[i]，nums[i] +（dp[i-k]到dp[i-1]中最大的值）) 滑动窗口可以用multiset或者map来存储 代码：class Solution { public: int constrainedSubsetSum(vector&lt;int&gt;&amp; nums, int k) { vector&lt;int&gt; dp(nums.size(), 0); int l = 0; int z = nums[0]; multiset&lt;int&gt; m; m.insert(0); for(int i = 0; i &lt; nums.size(); i++){ if(i-l &gt; k){ m.erase(m.find(dp[l])); l++; } dp[i] = max(nums[i], nums[i] + *--m.end()); z = z &gt; dp[i] ? z : dp[i]; m.insert(dp[i]); } return max(dp[nums.size()-1], z); } }; 题目地址:https://leetcode-cn.com/problems/constrained-subset-sum/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5394. 对角线遍历 II]]></title>
    <url>%2F2020%2F04%2F27%2Fleetcode%205394.%20%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86%20II%2F</url>
    <content type="text"><![CDATA[题目：给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。 示例：示例 1： 输入：nums = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,4,2,7,5,3,8,6,9] 示例 2： 输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]] 输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16] 示例 3： 输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]] 输出：[1,4,2,5,3,8,6,9,7,10,11] 示例 4： 输入：nums = [[1,2,3,4,5,6]] 输出：[1,2,3,4,5,6] 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i].length &lt;= 10^5 1 &lt;= nums[i][j] &lt;= 10^9 nums 中最多有 10^5 个数字。 分析：对角线上的每一个坐标x+y都是相等的，只要从最底下一行开始遍历，就可以按照顺序将对角线上的值依次存放，然后只需要按序输出即可 代码：class Solution { public: vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; v(100001); vector&lt;int&gt; ret; for(int i = nums.size()-1; i &gt;= 0; i--){ for(int j = 0; j &lt; nums[i].size(); j++){ v[i+j].push_back(nums[i][j]); } } for(int i = 0; v[i].size() &gt; 0; i++){ for(int j = 0; j &lt; v[i].size(); j++){ ret.push_back(v[i][j]); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/diagonal-traverse-ii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5393. 可获得的最大点数]]></title>
    <url>%2F2020%2F04%2F27%2Fleetcode%205393.%20%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。 你的点数就是你拿到手中的所有卡牌的点数之和。 给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。 示例：示例 1： 输入：cardPoints = [1,2,3,4,5,6,1], k = 3 输出：12 解释：第一次行动，不管拿哪张牌，你的点数总是 1 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 1 + 6 + 5 = 12 。 示例 2： 输入：cardPoints = [2,2,2], k = 2 输出：4 解释：无论你拿起哪两张卡牌，可获得的点数总是 4 。 示例 3： 输入：cardPoints = [9,7,7,9,7,7,9], k = 7 输出：55 解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。 示例 4： 输入：cardPoints = [1,1000,1], k = 1 输出：1 解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 1 。 示例 5： 输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3 输出：202 提示： 1 &lt;= cardPoints.length &lt;= 10^5 1 &lt;= cardPoints[i] &lt;= 10^4 1 &lt;= k &lt;= cardPoints.length 分析：最终就是左边拿a张牌，右边拿b张牌，a+b=k，尝试各种组合即可 代码：class Solution { public: int maxScore(vector&lt;int&gt;&amp; cardPoints, int k) { int z = 0; int ret = 0; for(int i = 0; i &lt; k; i++){ z += cardPoints[i]; } for(int i = k-1, j = cardPoints.size()-1; i &gt;=0; i--, j--){ ret = max(ret, z); z = z-cardPoints[i]+cardPoints[j]; } ret = max(ret, z); return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5392. 分割字符串的最大得分]]></title>
    <url>%2F2020%2F04%2F27%2Fleetcode%205392.%20%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目：给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。 「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。 示例：示例 1： 输入：s = &quot;011101&quot; 输出：5 解释： 将字符串 s 划分为两个非空子字符串的可行方案有： 左子字符串 = &quot;0&quot; 且 右子字符串 = &quot;11101&quot;，得分 = 1 + 4 = 5 左子字符串 = &quot;01&quot; 且 右子字符串 = &quot;1101&quot;，得分 = 1 + 3 = 4 左子字符串 = &quot;011&quot; 且 右子字符串 = &quot;101&quot;，得分 = 1 + 2 = 3 左子字符串 = &quot;0111&quot; 且 右子字符串 = &quot;01&quot;，得分 = 1 + 1 = 2 左子字符串 = &quot;01110&quot; 且 右子字符串 = &quot;1&quot;，得分 = 2 + 1 = 3 示例 2： 输入：s = &quot;00111&quot; 输出：5 解释：当 左子字符串 = &quot;00&quot; 且 右子字符串 = &quot;111&quot; 时，我们得到最大得分 = 2 + 3 = 5 示例 3： 输入：s = &quot;1111&quot; 输出：3 提示： 2 &lt;= s.length &lt;= 500 字符串 s 仅由字符 ‘0’ 和 ‘1’ 组成。 分析：直接把每种方案试过来即可 代码：class Solution { public: int maxScore(string s) { int l = 0; int r = 0; int ret = 0; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == &apos;1&apos;){ r++; } } for(int i = 0; i &lt; s.size()-1; i++){ if(s[i] == &apos;1&apos;){ r--; } else{ l++; } ret = max(ret, r+l); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5391. 生成数组]]></title>
    <url>%2F2020%2F04%2F20%2Fleetcode%205391.%20%E7%94%9F%E6%88%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你三个整数 n、m 和 k 。下图描述的算法用于找出正整数数组中最大的元素。 请你生成一个具有下述属性的数组 arr ： arr 中有 n 个整数。 1 &lt;= arr[i] &lt;= m 其中 (0 &lt;= i &lt; n) 。 将上面提到的算法应用于 arr ，search_cost 的值等于 k 。 返回上述条件下生成数组 arr 的 方法数 ，由于答案可能会很大，所以 必须 对 10^9 + 7 取余。 示例：示例 1： 输入：n = 2, m = 3, k = 1 输出：6 解释：可能的数组分别为 [1, 1], [2, 1], [2, 2], [3, 1], [3, 2] [3, 3] 示例 2： 输入：n = 5, m = 2, k = 3 输出：0 解释：没有数组可以满足上述条件 示例 3： 输入：n = 9, m = 1, k = 1 输出：1 解释：可能的数组只有 [1, 1, 1, 1, 1, 1, 1, 1, 1] 示例 4： 输入：n = 50, m = 100, k = 25 输出：34549172 解释：不要忘了对 1000000007 取余 示例 5： 输入：n = 37, m = 17, k = 7 输出：418930126 提示： 1 &lt;= n &lt;= 50 1 &lt;= m &lt;= 100 0 &lt;= k &lt;= n 分析：使用动态规划 dp[i][j][k], i表示已经遍历到第i个整数，j表示已经遍历过的数里面最大的数为j，k表示search_cost为k。 代码：class Solution { public: int numOfArrays(int n, int m, int k) { vector&lt;vector&lt;vector&lt;long long&gt;&gt;&gt; dp(n+1, vector&lt;vector&lt;long long&gt;&gt;(m+1, vector&lt;long long&gt;(n+2, 0))); for(int i = 1; i &lt;= m; i++){ // 初始化 dp[0][i][1] = 1; } for(int i = 0; i &lt; n; i++){ for(int j = 1; j &lt;= m; j++){ for(int k1 = 1; k1 &lt;= i+1 &amp;&amp; k1 &lt;= k; k1++){ for(int l = 1; l &lt;= m; l++){ // 有两种可能性：如果要添加的数要大于前面最大的数，那么k就要加一；如果要添加的数小于或等于前面最大的数，那么k就不需要修改 if(l &gt; j) dp[i+1][l][k1+1] = (dp[i+1][l][k1+1] + dp[i][j][k1]) % 1000000007; else dp[i+1][l][k1] = (dp[i+1][l][k1] + dp[i][l][k1]) % 1000000007; } } } } int ret = 0; for(int i = 1; i &lt;= m; i++){ // 将各种最大值的情况全部相加到一起 ret += dp[n-1][i][k]; ret %= 1000000007; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/submissions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5390. 数青蛙]]></title>
    <url>%2F2020%2F04%2F20%2Fleetcode%205390.%20%E6%95%B0%E9%9D%92%E8%9B%99%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 “croak” ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 croakOfFrogs 中会混合多个 “croak” 。请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。 注意：要想发出蛙鸣 “croak”，青蛙必须 依序 输出 ‘c’, ’r’, ’o’, ’a’, ’k’ 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。 如果字符串 croakOfFrogs 不是由若干有效的 “croak” 字符混合而成，请返回 -1 。 示例：示例 1： 输入：croakOfFrogs = &quot;croakcroak&quot; 输出：1 解释：一只青蛙 “呱呱” 两次 示例 2： 输入：croakOfFrogs = &quot;crcoakroak&quot; 输出：2 解释：最少需要两只青蛙，“呱呱” 声用黑体标注 第一只青蛙 &quot;crcoakroak&quot; 第二只青蛙 &quot;crcoakroak&quot; 示例 3： 输入：croakOfFrogs = &quot;croakcrook&quot; 输出：-1 解释：给出的字符串不是 &quot;croak&quot; 的有效组合。 示例 4： 输入：croakOfFrogs = &quot;croakcroa&quot; 输出：-1 提示： 1 &lt;= croakOfFrogs.length &lt;= 10^5 字符串中的字符只有 ‘c’, ‘r’, ‘o’, ‘a’ 或者 ‘k’ 分析：申明一个变量用来统计青蛙个数 建立5种状态，分别为已经输出c,r,o,a,k。每进入一个新的状态时，比如，从c进入r，c–，r++。每当c增加时，青蛙个数++，当k增加时青蛙个数–，记录下青蛙个数最多时达到的值即可。 全部遍历完后还要记得判断前面四种状态是否有剩余，如果有剩余，返回-1，不然返回青蛙个数最多时的值 代码：class Solution { public: int minNumberOfFrogs(string croakOfFrogs) { map&lt;char, int&gt; m; int ret = 0; int z = 0; for(int i = 0; i &lt; croakOfFrogs.size(); i++){ if(croakOfFrogs[i] == &apos;c&apos;){ z++; m[&apos;c&apos;]++; } else if(croakOfFrogs[i] == &apos;r&apos;){ if(m[&apos;c&apos;] == 0) return -1; m[&apos;c&apos;]--; m[&apos;r&apos;]++; } else if(croakOfFrogs[i] == &apos;o&apos;){ if(m[&apos;r&apos;] == 0) return -1; m[&apos;r&apos;]--; m[&apos;o&apos;]++; } else if(croakOfFrogs[i] == &apos;a&apos;){ if(m[&apos;o&apos;] == 0) return -1; m[&apos;o&apos;]--; m[&apos;a&apos;]++; } else if(croakOfFrogs[i] == &apos;k&apos;){ if(m[&apos;a&apos;] == 0) return -1; m[&apos;a&apos;]--; m[&apos;k&apos;]++; ret = ret &gt; z ? ret : z; z--; } } if(m[&apos;c&apos;] == 0 &amp;&amp; m[&apos;r&apos;] == 0 &amp;&amp; m[&apos;o&apos;] == 0 &amp;&amp; m[&apos;a&apos;] == 0){ return ret; } return -1; } }; 题目地址:https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5389. 点菜展示表]]></title>
    <url>%2F2020%2F04%2F20%2Fleetcode%205389.%20%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 orders，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。 请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。 注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。 示例：示例 1： 输入：orders = [[&quot;David&quot;,&quot;3&quot;,&quot;Ceviche&quot;],[&quot;Corina&quot;,&quot;10&quot;,&quot;Beef Burrito&quot;],[&quot;David&quot;,&quot;3&quot;,&quot;Fried Chicken&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Water&quot;],[&quot;Carla&quot;,&quot;5&quot;,&quot;Ceviche&quot;],[&quot;Rous&quot;,&quot;3&quot;,&quot;Ceviche&quot;]] 输出：[[&quot;Table&quot;,&quot;Beef Burrito&quot;,&quot;Ceviche&quot;,&quot;Fried Chicken&quot;,&quot;Water&quot;],[&quot;3&quot;,&quot;0&quot;,&quot;2&quot;,&quot;1&quot;,&quot;0&quot;],[&quot;5&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;],[&quot;10&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]] 解释： 点菜展示表如下所示： Table,Beef Burrito,Ceviche,Fried Chicken,Water 3 ,0 ,2 ,1 ,0 5 ,0 ,1 ,0 ,1 10 ,1 ,0 ,0 ,0 对于餐桌 3：David 点了 &quot;Ceviche&quot; 和 &quot;Fried Chicken&quot;，而 Rous 点了 &quot;Ceviche&quot; 而餐桌 5：Carla 点了 &quot;Water&quot; 和 &quot;Ceviche&quot; 餐桌 10：Corina 点了 &quot;Beef Burrito&quot; 示例 2： 输入：orders = [[&quot;James&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Ratesh&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Amadeus&quot;,&quot;12&quot;,&quot;Fried Chicken&quot;],[&quot;Adam&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;],[&quot;Brianna&quot;,&quot;1&quot;,&quot;Canadian Waffles&quot;]] 输出：[[&quot;Table&quot;,&quot;Canadian Waffles&quot;,&quot;Fried Chicken&quot;],[&quot;1&quot;,&quot;2&quot;,&quot;0&quot;],[&quot;12&quot;,&quot;0&quot;,&quot;3&quot;]] 解释： 对于餐桌 1：Adam 和 Brianna 都点了 &quot;Canadian Waffles&quot; 而餐桌 12：James, Ratesh 和 Amadeus 都点了 &quot;Fried Chicken&quot; 示例 3： 输入：orders = [[&quot;Laura&quot;,&quot;2&quot;,&quot;Bean Burrito&quot;],[&quot;Jhon&quot;,&quot;2&quot;,&quot;Beef Burrito&quot;],[&quot;Melissa&quot;,&quot;2&quot;,&quot;Soda&quot;]] 输出：[[&quot;Table&quot;,&quot;Bean Burrito&quot;,&quot;Beef Burrito&quot;,&quot;Soda&quot;],[&quot;2&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;]] 提示： 1 &lt;= orders.length &lt;= 5 * 10^4orders[i].length == 3 1 &lt;= customerNamei.length, foodItemi.length &lt;= 20 customerNamei 和 foodItemi 由大小写英文字母及空格字符 ‘ ‘ 组成。 tableNumberi 是 1 到 500 范围内的整数。 分析：使用map记录各桌点菜的数量 使用set记录所有的菜名和桌号，这样可以去重并且排序，按序填入二维数组。最后根据map往二维数组填入合适的值 代码：class Solution { public: string zh(int a){ string z = &quot;&quot;; while(a &gt; 0){ z = char(a % 10 + &apos;0&apos;) + z; a/=10; } return z; } int zh1(string s){ int z = 0; for(int i = 0; i &lt; s.size(); i++){ z*=10; z += s[i]-&apos;0&apos;; } return z; } vector&lt;vector&lt;string&gt;&gt; displayTable(vector&lt;vector&lt;string&gt;&gt;&amp; orders) { set&lt;int&gt; z; set&lt;string&gt; s; map&lt;string, map&lt;string, int&gt;&gt; m; for(int i = 0; i &lt; orders.size(); i++){ z.insert(zh1(orders[i][1])); s.insert(orders[i][2]); m[orders[i][1]][orders[i][2]]++; } vector&lt;vector&lt;string&gt;&gt; ret(z.size()+1, vector&lt;string&gt;(s.size()+1, &quot;&quot;)); ret[0][0] = &quot;Table&quot;; int a1 = 1; for(auto a = s.begin(); a != s.end(); a++, a1++){ ret[0][a1] = *a; } a1 = 1; for(auto a = z.begin(); a != z.end(); a++, a1++){ ret[a1][0] = zh(*a); } for(int i = 1; i &lt; ret.size(); i++){ for(int j = 1; j &lt; ret[i].size(); j++){ if(m[ret[i][0]].count(ret[0][j]) == 0) ret[i][j] = &apos;0&apos;; else ret[i][j] = zh(m[ret[i][0]][ret[0][j]]); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/solution/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5388. 重新格式化字符串]]></title>
    <url>%2F2020%2F04%2F20%2Fleetcode%205388.%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。 请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。 请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。 示例：示例 1： 输入：s = &quot;a0b1c2&quot; 输出：&quot;0a1b2c&quot; 解释：&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。 示例 2： 输入：s = &quot;leetcode&quot; 输出：&quot;&quot; 解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。 示例 3： 输入：s = &quot;1229857369&quot; 输出：&quot;&quot; 解释：&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。 示例 4： 输入：s = &quot;covid2019&quot; 输出：&quot;c2o0v1i9d&quot; 示例 5： 输入：s = &quot;ab123&quot; 输出：&quot;1a2b3&quot; 提示： 1 &lt;= s.length &lt;= 500 s 仅由小写英文字母和/或数字组成。 分析：统计数字和字母出现的次数，如果相差大于1返回空字符串，如果相差等于1，先输出多的那个，如果相等，随意选一个输出 代码：class Solution { public: string reformat(string s) { vector&lt;char&gt; v; vector&lt;char&gt; v1; string str = &quot;&quot;; for(int i = 0; i &lt; s.size(); i++){ if(s[i] &gt;= &apos;0&apos; &amp;&amp; s[i] &lt;= &apos;9&apos;){ v.push_back(s[i]); } else{ v1.push_back(s[i]); } } if(v1.size() - v.size() == 0){ while(v.size() != 0){ str += v1[v1.size()-1]; str += v[v.size()-1]; v1.pop_back(); v.pop_back(); } } else if(v1.size() - v.size() &lt;= 1 &amp;&amp; v1.size() - v.size() &gt; 0){ while(v.size() != 0){ str += v1[v1.size()-1]; str += v[v.size()-1]; v1.pop_back(); v.pop_back(); } str += v1[0]; } else if(v.size() - v1.size() &lt;= 1 &amp;&amp; v.size() - v1.size() &gt; 0){ while(v1.size() != 0){ str += v[v.size()-1]; str += v1[v1.size()-1]; v1.pop_back(); v.pop_back(); } str += v[0]; } return str; } }; 题目地址:https://leetcode-cn.com/problems/reformat-the-string/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1411. 给 N x 3 网格图涂色的方案数]]></title>
    <url>%2F2020%2F04%2F13%2Fleetcode%201411.%20%E7%BB%99%20N%20x%203%20%E7%BD%91%E6%A0%BC%E5%9B%BE%E6%B6%82%E8%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：你有一个 n x 3 的网格图 grid ，你需要用 红，黄，绿 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。 给你网格图的行数 n 。 请你返回给 grid 涂色的方案数。由于答案可能会非常大，请你返回答案对 10^9 + 7 取余的结果。 示例：示例 1： 输入：n = 1 输出：12 解释：总共有 12 种可行的方法 示例 2： 输入：n = 2 输出：54 示例 3： 输入：n = 3 输出：246 示例 4： 输入：n = 7 输出：106494 示例 5： 输入：n = 5000 输出：30228214 提示： n == grid.length grid[i].length == 3 1 &lt;= n &lt;= 5000 分析：可以有两个方法 一个是找规律，总共种格式abc和aba 另一个使用动态规划，枚举相邻两行的状态，判断是否符合条件 dp[z][i][j][k] z表示第z行，ijk分别表示一行的三个格子的三个状态 代码：class Solution { public: int numOfWays(int n) { long long dp[5001][3][3][3] = {0}; // 初始化第一行，将符合条件的格式初始化为1 for(int i = 0; i &lt; 3; i++){ for(int j = 0; j &lt; 3; j++){ for(int k = 0; k &lt; 3; k++){ if(i != j &amp;&amp; j != k){ dp[1][i][j][k] = 1; } } } } // 根据当前行的状态和上一行的状态，判断是否符合条件 for(int z = 2; z &lt;= n; z++){ for(int i = 0; i &lt; 3; i++) for(int j = 0; j &lt; 3; j++) for(int k = 0; k &lt; 3; k++) for(int ii = 0; ii &lt; 3; ii++) for(int jj = 0; jj &lt; 3; jj++) for(int kk = 0; kk &lt; 3; kk++) if(i != j &amp;&amp; j != k &amp;&amp; i != ii &amp;&amp; j != jj &amp;&amp; k != kk) dp[z][i][j][k] = (dp[z][i][j][k] + dp[z-1][ii][jj][kk]) % 1000000007; } long long ret = 0; // 将最后一行的各种状态数量相加 for(int i = 0; i &lt; 3; i++){ for(int j = 0; j &lt; 3; j++){ for(int k = 0; k &lt; 3; k++){ ret = (ret + dp[n][i][j][k]) % 1000000007; } } } return int(ret); } }; 题目地址:https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1410. HTML 实体解析器]]></title>
    <url>%2F2020%2F04%2F13%2Fleetcode%201410.%20HTML%20%E5%AE%9E%E4%BD%93%E8%A7%A3%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目：「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。 HTML 里这些特殊字符和它们对应的字符实体包括： 双引号：字符实体为 &quot; ，对应的字符是 “ 。 单引号：字符实体为 &apos; ，对应的字符是 ‘ 。 与符号：字符实体为 &amp; ，对应对的字符是 &amp; 。 大于号：字符实体为 &gt; ，对应的字符是 &gt; 。 小于号：字符实体为 &lt; ，对应的字符是 &lt; 。 斜线号：字符实体为 &frasl; ，对应的字符是 / 。 给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。 示例：示例 1： 输入：text = &quot;&amp;amp; is an HTML entity but &amp;ambassador; is not.&quot; 输出：&quot;&amp; is an HTML entity but &amp;ambassador; is not.&quot; 解释：解析器把字符实体 &amp;amp; 用 &amp; 替换 示例 2： 输入：text = &quot;and I quote: &amp;quot;...&amp;quot;&quot; 输出：&quot;and I quote: \&quot;...\&quot;&quot; 示例 3： 输入：text = &quot;Stay home! Practice on Leetcode :)&quot; 输出：&quot;Stay home! Practice on Leetcode :)&quot; 示例 4： 输入：text = &quot;x &amp;gt; y &amp;amp;&amp;amp; x &amp;lt; y is always false&quot; 输出：&quot;x &gt; y &amp;&amp; x &lt; y is always false&quot; 示例 5： 输入：text = &quot;leetcode.com&amp;frasl;problemset&amp;frasl;all&quot; 输出：&quot;leetcode.com/problemset/all&quot; 提示： 1 &lt;= text.length &lt;= 10^5 字符串可能包含 256 个ASCII 字符中的任意字符。 分析：声明两个字符串，一个ret用来存储最后处理过的字符串，一个str用来临时存储字符串 在遇到正常字符时加入str，遇到&amp;将str添加到ret之后并清空str。遇到；查找str是否和特殊字符实体相同：若相同，转化str对应的字符添加到ret之后并清空str，若不相同，将str直接添加到ret之后并清空str 代码：class Solution { public: string entityParser(string text) { string ret = &quot;&quot;; string str = &quot;&quot;; map&lt;string, char&gt; m; m[&quot;&amp;quot;&quot;] = &apos;&quot;&apos;; m[&quot;&amp;apos;&quot;] = &apos;\&apos;&apos;; m[&quot;&amp;amp;&quot;] = &apos;&amp;&apos;; m[&quot;&amp;gt;&quot;] = &apos;&gt;&apos;; m[&quot;&amp;lt;&quot;] = &apos;&lt;&apos;; m[&quot;&amp;frasl;&quot;] = &apos;/&apos;; for(int i= 0; i &lt; text.size(); i++){ if(text[i] == &apos;&amp;&apos;){ ret += str; str.clear(); str += &apos;&amp;&apos;; } else if(text[i] == &apos;;&apos;){ str += &apos;;&apos;; if(str[0] == &apos;&amp;&apos;){ if(m.count(str) == 1){ ret += m[str]; str.clear(); continue; } } ret += str; str.clear(); } else{ str += text[i]; } } ret += str; return ret; } }; 题目地址:https://leetcode-cn.com/problems/html-entity-parser/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1409. 查询带键的排列]]></title>
    <url>%2F2020%2F04%2F13%2Fleetcode%201409.%20%E6%9F%A5%E8%AF%A2%E5%B8%A6%E9%94%AE%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个待查数组 queries ，数组中的元素为 1 到 m 之间的正整数。 请你根据以下规则处理所有待查项 queries[i]（从 i=0 到 i=queries.length-1）： 一开始，排列 P=[1,2,3,…,m]。 对于当前的 i ，请你找出待查项 queries[i] 在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列 P 的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是 queries[i] 的查询结果。 请你以数组形式返回待查数组 queries 的查询结果。 示例：示例 1： 输入：queries = [3,1,2,1], m = 5 输出：[2,1,2,1] 解释：待查数组 queries 处理如下： 对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 2，接着我们把 3 移动到 P 的起始位置，得到 P=[3,1,2,4,5] 。 对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,3,2,4,5] 。 对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 2，接着我们把 2 移动到 P 的起始位置，得到 P=[2,1,3,4,5] 。 对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,2,3,4,5] 。 因此，返回的结果数组为 [2,1,2,1] 。 示例 2： 输入：queries = [4,1,2,2], m = 4 输出：[3,1,2,0] 示例 3： 输入：queries = [7,5,5,8,3], m = 8 输出：[6,5,0,7,5] 提示： 1 &lt;= m &lt;= 10^3 1 &lt;= queries.length &lt;= m 1 &lt;= queries[i] &lt;= m 分析：按照题意，声明一个vecotr用来存储排列p，按照规则进行删除添加即可 代码：class Solution { public: vector&lt;int&gt; processQueries(vector&lt;int&gt;&amp; queries, int m) { vector&lt;int&gt; ret; vector&lt;int&gt; vi(m, 0); for(int i = 0; i &lt; m; i++){ vi[i] = i+1; } for(int i = 0; i &lt; queries.size(); i++){ for(int j = 0; j &lt; m; j++){ if(vi[j] == queries[i]){ ret.push_back(j); vi.erase(vi.begin()+j); vi.insert(vi.begin(), queries[i]); break; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/queries-on-a-permutation-with-key/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1408. 数组中的字符串匹配]]></title>
    <url>%2F2020%2F04%2F13%2Fleetcode%201408.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。 如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。 示例：示例 1： 输入：words = [&quot;mass&quot;,&quot;as&quot;,&quot;hero&quot;,&quot;superhero&quot;] 输出：[&quot;as&quot;,&quot;hero&quot;] 解释：&quot;as&quot; 是 &quot;mass&quot; 的子字符串，&quot;hero&quot; 是 &quot;superhero&quot; 的子字符串。 [&quot;hero&quot;,&quot;as&quot;] 也是有效的答案。 示例 2： 输入：words = [&quot;leetcode&quot;,&quot;et&quot;,&quot;code&quot;] 输出：[&quot;et&quot;,&quot;code&quot;] 解释：&quot;et&quot; 和 &quot;code&quot; 都是 &quot;leetcode&quot; 的子字符串。 示例 3： 输入：words = [&quot;blue&quot;,&quot;green&quot;,&quot;bu&quot;] 输出：[] 提示： 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 30 words[i] 仅包含小写英文字母。 题目数据 保证 每个 words[i] 都是独一无二的。 分析：直接暴力循环比较 代码：class Solution { public: vector&lt;string&gt; stringMatching(vector&lt;string&gt;&amp; words) { vector&lt;string&gt; vs; for(int i = 0; i &lt; words.size(); i++){ for(int j = 0; j &lt; words.size(); j++){ if(i != j){ if(words[j].find(words[i]) != string::npos){ vs.push_back(words[i]); break; } } } } return vs; } }; 题目地址:https://leetcode-cn.com/problems/string-matching-in-an-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1406. 石子游戏 III]]></title>
    <url>%2F2020%2F04%2F07%2Fleetcode%201406.%20%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%20III%2F</url>
    <content type="text"><![CDATA[题目：Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 stoneValue 给出。 Alice 和 Bob 轮流取石子，Alice 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 1、2 或 3 堆石子 。比赛一直持续到所有石头都被拿走。 每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 0 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。 假设 Alice 和 Bob 都采取 最优策略 。如果 Alice 赢了就返回 “Alice” ，Bob 赢了就返回 “Bob”，平局（分数相同）返回 “Tie” 。 示例：示例 1： 输入：values = [1,2,3,7] 输出：&quot;Bob&quot; 解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。 示例 2： 输入：values = [1,2,3,-9] 输出：&quot;Alice&quot; 解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。 如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。 如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。 注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。 示例 3： 输入：values = [1,2,3,6] 输出：&quot;Tie&quot; 解释：Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。 示例 4： 输入：values = [1,2,3,-1,-2,-3,7] 输出：&quot;Alice&quot; 示例 5： 输入：values = [-1,-2,-3] 输出：&quot;Tie&quot; 提示： 1 &lt;= values.length &lt;= 50000 -1000 &lt;= values[i] &lt;= 1000 分析：倒着进行dp dp[i] 表示当从第i个石子堆开始时候的最优选择 dp[i] = min(dp[i+1], dp[i+2], dp[i+3]) 代码：class Solution { public: string stoneGameIII(vector&lt;int&gt;&amp; stoneValue) { vector&lt;int&gt; dp(stoneValue.size(), 0); int h = 0; for(int i = stoneValue.size()-1; i &gt;= 0; i--){ int a1 = 0; int a2 = 0; int a3 = 0; h += stoneValue[i]; if(i+1 &lt; stoneValue.size()) a1 = dp[i+1]; if(i+2 &lt; stoneValue.size()) a2 = dp[i+2]; if(i+3 &lt; stoneValue.size()) a3 = dp[i+3]; dp[i] = h - min(a1, min(a2, a3)); } if(dp[0] &gt; h - dp[0]) return &quot;Alice&quot;; if(dp[0] &lt; h - dp[0]) return &quot;Bob&quot;; return &quot;Tie&quot;; } }; 题目地址:https://leetcode-cn.com/problems/stone-game-iii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1405. 最长快乐字符串]]></title>
    <url>%2F2020%2F04%2F07%2Fleetcode%201405.%20%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：如果字符串中不含有任何 ‘aaa’，’bbb’ 或 ‘ccc’ 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。 给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s： s 是一个尽可能长的快乐字符串。 s 中 最多 有a 个字母 ‘a’、b 个字母 ‘b’、c 个字母 ‘c’ 。 s 中只含有 ‘a’、’b’ 、’c’ 三种字母。 如果不存在这样的字符串 s ，请返回一个空字符串 “”。 示例：示例 1： 输入：a = 1, b = 1, c = 7 输出：&quot;ccaccbcc&quot; 解释：&quot;ccbccacc&quot; 也是一种正确答案。 示例 2： 输入：a = 2, b = 2, c = 1 输出：&quot;aabbc&quot; 示例 3： 输入：a = 7, b = 1, c = 0 输出：&quot;aabaa&quot; 解释：这是该测试用例的唯一正确答案。 提示： 0 &lt;= a, b, c &lt;= 100 a + b + c &gt; 0 分析：先统计各个字符的大小，每次选择数量最多的字符加入字符串，如果前两个都是同样字符，下一个选择第二多的字符加入字符串，直到全部字符使用完或者除了最多数量的字符外，其余两个字符数量为0 代码：class Solution { public: string longestDiverseString(int a, int b, int c) { string str = &quot; &quot;; int z = 0; while(a &gt; 0 || b &gt; 0 || c &gt; 0){ if(a &gt;= b &amp;&amp; a &gt;= c){ if(str[str.size()-1] == &apos;a&apos; &amp;&amp; z == 2){ if(b &gt; c){ str += &apos;b&apos;; b--; } else if(c == 0){ break; } else{ str += &apos;c&apos;; c--; } } else{ if(str[str.size()-1] == &apos;a&apos;){ z++; } else z = 1; str += &apos;a&apos;; a--; } } else if(b &gt;= a &amp;&amp; b &gt;= c){ if(str[str.size()-1] == &apos;b&apos; &amp;&amp; z == 2){ if(a &gt; c){ str += &apos;a&apos;; a--; } else if(c == 0){ break; } else{ str += &apos;c&apos;; c--; } } else{ if(str[str.size()-1] == &apos;b&apos;){ z++; } else z = 1; str += &apos;b&apos;; b--; } } else if(c &gt;= a &amp;&amp; c &gt;= b){ cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; &quot;\n&quot; ; if(str[str.size()-1] == &apos;c&apos; &amp;&amp; z == 2){ if(b &gt; a){ str += &apos;b&apos;; b--; } else if(a == 0){ break; } else{ str += &apos;a&apos;; a--; } } else{ if(str[str.size()-1] == &apos;c&apos;){ z++; } else z = 1; str += &apos;c&apos;; c--; } } } str.erase(str.begin()); return str; } }; 题目地址:https://leetcode-cn.com/problems/longest-happy-string/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1404. 将二进制表示减到 1 的步骤数]]></title>
    <url>%2F2020%2F04%2F07%2Fleetcode%201404.%20%E5%B0%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E5%87%8F%E5%88%B0%201%20%E7%9A%84%E6%AD%A5%E9%AA%A4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个以二进制形式表示的数字 s 。请你返回按下述规则将其减少到 1 所需要的步骤数： 如果当前数字为偶数，则将其除以 2 。 如果当前数字为奇数，则将其加上 1 。 题目保证你总是可以按上述规则将测试用例变为 1 。 示例：示例 1： 输入：s = &quot;1101&quot; 输出：6 解释：&quot;1101&quot; 表示十进制数 13 。 Step 1) 13 是奇数，加 1 得到 14 Step 2) 14 是偶数，除 2 得到 7 Step 3) 7 是奇数，加 1 得到 8 Step 4) 8 是偶数，除 2 得到 4 Step 5) 4 是偶数，除 2 得到 2 Step 6) 2 是偶数，除 2 得到 1 示例 2： 输入：s = &quot;10&quot; 输出：1 解释：&quot;10&quot; 表示十进制数 2 。 Step 1) 2 是偶数，除 2 得到 1 示例 3： 输入：s = &quot;1&quot; 输出：0 提示： 1 &lt;= s.length &lt;= 500 s 由字符 ‘0’ 或 ‘1’ 组成。 s[0] == ‘1’ 分析： 如果当前数字为奇数，则将其加上 1 。 末尾如果为1，就进位将前面连续的1改为0，第一个0改为1，步骤+1 如果当前数字为偶数，则将其除以 2 。 如果末尾为0，就将最后一个0去掉，步骤+1 代码：class Solution { public: int numSteps(string s) { vector&lt;int&gt; vi(1, 0); int ret = 0; for(int i = 0; i &lt; s.size(); i++){ vi.push_back(s[i]-&apos;0&apos;); } while(!((vi.size() == 1 &amp;&amp; vi[0] == 1) || (vi.size() == 2 &amp;&amp; vi[0] == 0))){ if(vi[vi.size()-1] == 0) vi.pop_back(); else{ for(int i = vi.size()-1; i &gt;= 0; i--){ if(vi[i] == 0){ vi[i] = 1; break; } else{ vi[i] = 0; } } } ret++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1403. 非递增顺序的最小子序列]]></title>
    <url>%2F2020%2F04%2F07%2Fleetcode%201403.%20%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。 如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。 与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。 注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。 示例：示例 1： 输入：nums = [4,3,10,9,8] 输出：[10,9] 解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 示例 2： 输入：nums = [4,4,7,6,7] 输出：[7,7,6] 解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。 示例 3： 输入：nums = [6] 输出：[6] 提示： 1 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 100 分析：直接从大到小排序，按要求找出合适的子序列即可 代码：bool bj(int a, int b){ return a &gt; b; } class Solution { public: vector&lt;int&gt; minSubsequence(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ret; int h = 0; int h1 = 0; sort(nums.begin(), nums.end(), bj); for(int i = 0; i &lt; nums.size(); i++){ h += nums[i]; } for(int i = 0; h1 &lt;= h; i++){ h1 += nums[i]; h -= nums[i]; ret.push_back(nums[i]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-subsequence-in-non-increasing-order/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5371. 找到所有好字符串]]></title>
    <url>%2F2020%2F03%2F30%2Fleetcode%205371.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E5%A5%BD%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你两个长度为 n 的字符串 s1 和 s2 ，以及一个字符串 evil 。请你返回 好字符串 的数目。 好字符串 的定义为：它的长度为 n ，字典序大于等于 s1 ，字典序小于等于 s2 ，且不包含 evil 为子字符串。 由于答案可能很大，请你返回答案对 10^9 + 7 取余的结果。 示例：示例 1： 输入：n = 2, s1 = &quot;aa&quot;, s2 = &quot;da&quot;, evil = &quot;b&quot; 输出：51 解释：总共有 25 个以 &apos;a&apos; 开头的好字符串：&quot;aa&quot;，&quot;ac&quot;，&quot;ad&quot;，...，&quot;az&quot;。还有 25 个以 &apos;c&apos; 开头的好字符串：&quot;ca&quot;，&quot;cc&quot;，&quot;cd&quot;，...，&quot;cz&quot;。最后，还有一个以 &apos;d&apos; 开头的好字符串：&quot;da&quot;。 示例 2： 输入：n = 8, s1 = &quot;leetcode&quot;, s2 = &quot;leetgoes&quot;, evil = &quot;leet&quot; 输出：0 解释：所有字典序大于等于 s1 且小于等于 s2 的字符串都以 evil 字符串 &quot;leet&quot; 开头。所以没有好字符串。 示例 3： 输入：n = 2, s1 = &quot;gx&quot;, s2 = &quot;gz&quot;, evil = &quot;x&quot; 输出：2 提示： s1.length == n s2.length == n 1 &lt;= n &lt;= 500 1 &lt;= evil.length &lt;= 50 所有字符串都只包含小写英文字母。 分析：使用数位dp和kmp 将这个问题简化一下，求出字典序小于等于s2的字符串数量，再求出字典序小于等于s1的字符串数量，将两个相减，然后根据s1是否有子字符串evil来判断是否是好字符串 dp[i][j][k] i表示已经遍历到的位置 j表示两种状态 0，表示字符串的前缀比所对比的字符串小 1，表示字符串的前缀与所对比的字符串相同 y表示当前字符串后缀与evil的前缀重合长度 代码：class Solution { public: void sl(int n, string s, string evil, vector&lt;int&gt; next, long &amp;l1, long &amp;l2){ vector&lt;vector&lt;vector&lt;long&gt;&gt;&gt; dp(n+1, vector&lt;vector&lt;long&gt;&gt;(2, vector&lt;long&gt;(evil.size()+1, 0))); dp[0][1][0] = 1; // 在i等于0的时候只有和dp[0][1][0]才为1，别的都为0（原因：只有在j等于1的时候之后的判断才会考虑j等于1和j等于0的状态，不然之后就全是j等于0的状态，没有最大字符串的限制了） for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; 2; j++){ for(int k = 0; k &lt; evil.size(); k++){ for(char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++){ int i1 = i+1; int j1 = 0; int k1 = 0; if(j == 0){ // 之前的字符串前缀比s小，之后就不用考虑字符的限制 j1 = 0; } else{ // 之前的字符串前缀和s相同，之后还需要考虑字符的最大限制 if(c &gt; s[i]){ // 当前字符串与s前缀相同，不能拼接更大的c break; } if(c == s[i]) // 拼接完后前缀依旧相同，所以还需要考虑最大限制 j1 = 1; else // 拼接完后当前字符串前缀小于s的前缀，之后就不用考虑字符的限制 j1 = 0; } if(evil[k] == c){ // 已经重叠了k个字符，第k+1个字符如果相等k1就要在增长一个 k1 = k+1; } else{ // 如果当前不重叠了，就利用kmp算法的next数组来找出最大的和evil相重叠的长度 k1 = k; while(k1 != -1 &amp;&amp; evil[k1] != c){ k1 = next[k1]; } if(k1 == -1){ // 如果没有相同的前缀下一个就重新从0开始匹配 k1 = 0; } else k1++; // k表示的是当前需要匹配的evil的指针，所以需要++ } if(k1 == evil.size()) // 如果evil全匹配上了，那么说明当前字符串包含了evil，所以不能算入总数 continue; dp[i1][j1][k1] = (dp[i1][j1][k1] + dp[i][j][k]) % 1000000007; } } } } long ret = 0; for(int i = 0; i &lt; evil.size(); i++){ l1 = (l1 + (dp[n][0][i] + dp[n][1][i])) % 1000000007; l2 = (l2 + dp[n][1][i]) % 1000000007; // l2表示s中是否有子字符串evil } } int findGoodStrings(int n, string s1, string s2, string evil) { vector&lt;int&gt; next(evil.size(), 0); next[0] = -1; for(int i = 0, j = -1; i &lt; evil.size()-1;){ if(j == -1 || evil[i] == evil[j]){ i++; j++; next[i] = j; } else j = next[j]; } long l1 = 0; long l2 = 0; long l3 = 0; long l4 = 0; sl(n, s1, evil, next, l1, l2); sl(n, s2, evil, next, l3, l4); return (l3 + 1000000007 - l1 + l2) % 1000000007; // 加这个1000000007是为了避免l3取余后小于l1 } }; 题目地址:https://leetcode-cn.com/problems/find-all-good-strings/submissions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5370. 设计地铁系统]]></title>
    <url>%2F2020%2F03%2F30%2Fleetcode%205370.%20%E8%AE%BE%E8%AE%A1%E5%9C%B0%E9%93%81%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[题目：请你实现一个类 UndergroundSystem ，它支持以下 3 种方法： checkIn(int id, string stationName, int t) 编号为 id 的乘客在 t 时刻进入地铁站 stationName 。 一个乘客在同一时间只能在一个地铁站进入或者离开。 checkOut(int id, string stationName, int t) 编号为 id 的乘客在 t 时刻离开地铁站 stationName 。 getAverageTime(string startStation, string endStation) 返回从地铁站 startStation 到地铁站 endStation 的平均花费时间。 平均时间计算的行程包括当前为止所有从 startStation 直接到达 endStation 的行程。 调用 getAverageTime 时，询问的路线至少包含一趟行程。 你可以假设所有对 checkIn 和 checkOut 的调用都是符合逻辑的。也就是说，如果一个顾客在 t1 时刻到达某个地铁站，那么他离开的时间 t2 一定满足 t2 &gt; t1 。所有的事件都按时间顺序给出。 示例：输入： [&quot;UndergroundSystem&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkIn&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;,&quot;getAverageTime&quot;,&quot;checkIn&quot;,&quot;getAverageTime&quot;,&quot;checkOut&quot;,&quot;getAverageTime&quot;] [[],[45,&quot;Leyton&quot;,3],[32,&quot;Paradise&quot;,8],[27,&quot;Leyton&quot;,10],[45,&quot;Waterloo&quot;,15],[27,&quot;Waterloo&quot;,20],[32,&quot;Cambridge&quot;,22],[&quot;Paradise&quot;,&quot;Cambridge&quot;],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Leyton&quot;,24],[&quot;Leyton&quot;,&quot;Waterloo&quot;],[10,&quot;Waterloo&quot;,38],[&quot;Leyton&quot;,&quot;Waterloo&quot;]] 输出： [null,null,null,null,null,null,null,14.0,11.0,null,11.0,null,12.0] 解释： UndergroundSystem undergroundSystem = new UndergroundSystem(); undergroundSystem.checkIn(45, &quot;Leyton&quot;, 3); undergroundSystem.checkIn(32, &quot;Paradise&quot;, 8); undergroundSystem.checkIn(27, &quot;Leyton&quot;, 10); undergroundSystem.checkOut(45, &quot;Waterloo&quot;, 15); undergroundSystem.checkOut(27, &quot;Waterloo&quot;, 20); undergroundSystem.checkOut(32, &quot;Cambridge&quot;, 22); undergroundSystem.getAverageTime(&quot;Paradise&quot;, &quot;Cambridge&quot;); // 返回 14.0。从 &quot;Paradise&quot;（时刻 8）到 &quot;Cambridge&quot;(时刻 22)的行程只有一趟 undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;); // 返回 11.0。总共有 2 躺从 &quot;Leyton&quot; 到 &quot;Waterloo&quot; 的行程，编号为 id=45 的乘客出发于 time=3 到达于 time=15，编号为 id=27 的乘客于 time=10 出发于 time=20 到达。所以平均时间为 ( (15-3) + (20-10) ) / 2 = 11.0 undergroundSystem.checkIn(10, &quot;Leyton&quot;, 24); undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;); // 返回 11.0 undergroundSystem.checkOut(10, &quot;Waterloo&quot;, 38); undergroundSystem.getAverageTime(&quot;Leyton&quot;, &quot;Waterloo&quot;); // 返回 12.0 提示： 总共最多有 20000 次操作。 1 &lt;= id, t &lt;= 10^6 所有的字符串包含大写字母，小写字母和数字。 1 &lt;= stationName.length &lt;= 10 与标准答案误差在 10^-5 以内的结果都视为正确结果。 分析：定义三个map m 存储两个地点之间的所有所花的时间 mi 上车的id和时间 ms 上车的id和地名 上车的时候想mi和ms中添加数据，下车时将时间差存入m 需要输出时计算平均值即可 代码：class UndergroundSystem { private: map&lt;string, map&lt;string, vector&lt;int&gt;&gt;&gt; m; map&lt;int, int&gt; mi; map&lt;int, string&gt; ms; public: UndergroundSystem() { } void checkIn(int id, string stationName, int t) { mi[id] = t; ms[id] = stationName; } void checkOut(int id, string stationName, int t) { m[ms[id]][stationName].push_back(t - mi[id]); } double getAverageTime(string startStation, string endStation) { double z = 0; for(int i = 0; i &lt; m[startStation][endStation].size(); i++){ z += m[startStation][endStation][i]; } return z / m[startStation][endStation].size(); } }; /** * Your UndergroundSystem object will be instantiated and called as such: * UndergroundSystem* obj = new UndergroundSystem(); * obj-&gt;checkIn(id,stationName,t); * obj-&gt;checkOut(id,stationName,t); * double param_3 = obj-&gt;getAverageTime(startStation,endStation); */ 题目地址:https://leetcode-cn.com/problems/design-underground-system/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5369. 统计作战单位数]]></title>
    <url>%2F2020%2F03%2F30%2Fleetcode%205369.%20%E7%BB%9F%E8%AE%A1%E4%BD%9C%E6%88%98%E5%8D%95%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目： n 名士兵站成一排。每个士兵都有一个 独一无二 的评分 rating 。 每 3 个士兵可以组成一个作战单位，分组规则如下： 从队伍中选出下标分别为 i、j、k 的 3 名士兵，他们的评分分别为 rating[i]、rating[j]、rating[k] 作战单位需满足： rating[i] &lt; rating[j] &lt; rating[k] 或者 rating[i] &gt; rating[j] &gt; rating[k] ，其中 0 &lt;= i &lt; j &lt; k &lt; n 请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。 示例：示例 1： 输入：rating = [2,5,3,4,1] 输出：3 解释：我们可以组建三个作战单位 (2,3,4)、(5,4,1)、(5,3,1) 。 示例 2： 输入：rating = [2,1,3] 输出：0 解释：根据题目条件，我们无法组建作战单位。 示例 3： 输入：rating = [1,2,3,4] 输出：4 提示： n == rating.length 1 &lt;= n &lt;= 200 1 &lt;= rating[i] &lt;= 10^5 分析：暴力循环O(n^3)复杂度 或者以每个士兵为中间，可以组队的方式为： 左边比他评分小的人数 × 右边比他评分大的人数 + 左边比他评分大的人数 × 右边比他评分小的人数 代码：class Solution { public: int numTeams(vector&lt;int&gt;&amp; rating) { int ret = 0; for(int i = 0; i &lt; rating.size(); i++){ int z = rating[i]; for(int j = i+1; j &lt; rating.size(); j++){ int x = rating[j]; for(int k = j+1; k &lt; rating.size(); k++){ if(z &lt; x &amp;&amp; rating[k] &gt; x) ret++; if(z &gt; x &amp;&amp; rating[k] &lt; x) ret++; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-number-of-teams/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5368. 找出数组中的幸运数]]></title>
    <url>%2F2020%2F03%2F30%2Fleetcode%205368.%20%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。 给你一个整数数组 arr，请你从中找出并返回一个幸运数。 如果数组中存在多个幸运数，只需返回 最大 的那个。 如果数组中不含幸运数，则返回 -1 。 示例：示例 1： 输入：arr = [2,2,3,4] 输出：2 解释：数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。 示例 2： 输入：arr = [1,2,2,3,3,3] 输出：3 解释：1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。 示例 3： 输入：arr = [2,2,2,3,3] 输出：-1 解释：数组中不存在幸运数。 示例 4： 输入：arr = [5] 输出：-1 示例 5： 输入：arr = [7,7,7,7,7,7,7] 输出：7 提示： 1 &lt;= arr.length &lt;= 500 1 &lt;= arr[i] &lt;= 500 分析：直接统计出现次数，然后遍历一遍找出符合要求的最大数即可 代码：class Solution { public: int findLucky(vector&lt;int&gt;&amp; arr) { int ret = -1; vector&lt;int&gt; vi(501, 0); for(int i = 0; i &lt; arr.size(); i++){ vi[arr[i]]++; } for(int i = 1; i &lt; vi.size(); i++){ if(vi[i] == i) ret = i; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-lucky-integer-in-an-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5367. 最长快乐前缀]]></title>
    <url>%2F2020%2F03%2F23%2Fleetcode%205367.%20%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[题目：「快乐前缀」是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。 给你一个字符串 s，请你返回它的 最长快乐前缀。 如果不存在满足题意的前缀，则返回一个空字符串。 示例：示例 1： 输入：s = &quot;level&quot; 输出：&quot;l&quot; 解释：不包括 s 自己，一共有 4 个前缀（&quot;l&quot;, &quot;le&quot;, &quot;lev&quot;, &quot;leve&quot;）和 4 个后缀（&quot;l&quot;, &quot;el&quot;, &quot;vel&quot;, &quot;evel&quot;）。最长的既是前缀也是后缀的字符串是 &quot;l&quot; 。 示例 2： 输入：s = &quot;ababab&quot; 输出：&quot;abab&quot; 解释：&quot;abab&quot; 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。 示例 3： 输入：s = &quot;leetcodeleet&quot; 输出：&quot;leet&quot; 示例 4： 输入：s = &quot;a&quot; 输出：&quot;&quot; 提示： 1 &lt;= s.length &lt;= 10^5 s 只含有小写英文字母 分析：使用c++17的string_view即可 或者可以看看大佬的字符串hash，https://leetcode-cn.com/problems/longest-happy-prefix/solution/zui-chang-kuai-le-qian-zhui-zi-fu-chuan-hashjian-j/ 代码：class Solution { public: string longestPrefix(string s) { string_view s1 = s; string_view s2 = s; for (int i = s.size() - 1; i &gt; 0; --i) { s1.remove_prefix(1); s2.remove_suffix(1); if (s1 == s2) { return string(s1); } } return &quot;&quot;; } }; 题目地址:https://leetcode-cn.com/problems/longest-happy-prefix/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5366. 检查网格中是否存在有效路径]]></title>
    <url>%2F2020%2F03%2F23%2Fleetcode%205366.%20%E6%A3%80%E6%9F%A5%E7%BD%91%E6%A0%BC%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个 m x n 的网格 grid。网格里的每个单元都代表一条街道。grid[i][j] 的街道可以是： 1 表示连接左单元格和右单元格的街道。 2 表示连接上单元格和下单元格的街道。 3 表示连接左单元格和下单元格的街道。 4 表示连接右单元格和下单元格的街道。 5 表示连接左单元格和上单元格的街道。 6 表示连接右单元格和上单元格的街道。 你最开始从左上角的单元格 (0,0) 开始出发，网格中的「有效路径」是指从左上方的单元格 (0,0) 开始、一直到右下方的 (m-1,n-1) 结束的路径。该路径必须只沿着街道走。 注意：你 不能 变更街道。 如果网格中存在有效的路径，则返回 true，否则返回 false 。 示例：示例 1： 输入：grid = [[2,4,3],[6,5,2]] 输出：true 解释：如图所示，你可以从 (0, 0) 开始，访问网格中的所有单元格并到达 (m - 1, n - 1) 。 示例 2： 输入：grid = [[1,2,1],[1,2,1]] 输出：false 解释：如图所示，单元格 (0, 0) 上的街道没有与任何其他单元格上的街道相连，你只会停在 (0, 0) 处。 示例 3： 输入：grid = [[1,1,2]] 输出：false 解释：你会停在 (0, 1)，而且无法到达 (0, 2) 。 示例 4： 输入：grid = [[1,1,1,1,1,1,3]] 输出：true 示例 5： 输入：grid = [[2],[2],[2],[2],[2],[2],[6]] 输出：true 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 1 &lt;= grid[i][j] &lt;= 6 分析：0,0位置只有4号的情况下才可能有两条路到达最右下方，其他情况下只需要沿着一条路走下去即可。需要注意中途道路是否可以接上 代码：class Solution { public: bool pd(vector&lt;vector&lt;int&gt;&gt; grid, int x1, int y1){ while(1){ if(x1 == grid.size()-1 &amp;&amp; y1 == grid[0].size()-1){ return true; } if(grid[x1][y1] == 1){ if(y1-1 &gt;= 0 &amp;&amp; grid[x1][y1-1] != 0 &amp;&amp; (grid[x1][y1-1] == 1 || grid[x1][y1-1] == 4 || grid[x1][y1-1] == 6)){ grid[x1][y1] = 0; y1 = y1-1; continue; } if(y1+1 &lt; grid[0].size() &amp;&amp; grid[x1][y1+1] != 0 &amp;&amp; (grid[x1][y1+1] == 1 || grid[x1][y1+1] == 3 || grid[x1][y1+1] == 5)){ grid[x1][y1] = 0; y1 = y1+1; continue; } return false; } if(grid[x1][y1] == 2){ if(x1-1 &gt;= 0 &amp;&amp; grid[x1-1][y1] != 0 &amp;&amp; (grid[x1-1][y1] == 2 || grid[x1-1][y1] == 3 || grid[x1-1][y1] == 4)){ grid[x1][y1] = 0; x1 = x1-1; continue; } if(x1+1 &lt; grid.size() &amp;&amp; grid[x1+1][y1] != 0 &amp;&amp; (grid[x1+1][y1] == 2 || grid[x1+1][y1] == 5 || grid[x1+1][y1] == 6)){ grid[x1][y1] = 0; x1 = x1+1; continue; } return false; } if(grid[x1][y1] == 3){ if(y1-1 &gt;= 0 &amp;&amp; grid[x1][y1-1] != 0 &amp;&amp; (grid[x1][y1-1] == 1 || grid[x1][y1-1] == 4 || grid[x1][y1-1] == 6)){ grid[x1][y1] = 0; y1 = y1-1; continue; } if(x1+1 &lt; grid.size() &amp;&amp; grid[x1+1][y1] != 0 &amp;&amp; (grid[x1+1][y1] == 2 || grid[x1+1][y1] == 5 || grid[x1+1][y1] == 6)){ grid[x1][y1] = 0; x1 = x1+1; continue; } return false; } if(grid[x1][y1] == 4){ if(y1+1 &lt; grid[0].size() &amp;&amp; grid[x1][y1+1] != 0 &amp;&amp; (grid[x1][y1+1] == 1 || grid[x1][y1+1] == 3 || grid[x1][y1+1] == 5)){ grid[x1][y1] = 0; y1 = y1+1; continue; } if(x1+1 &lt; grid.size() &amp;&amp; grid[x1+1][y1] != 0 &amp;&amp; (grid[x1+1][y1] == 2 || grid[x1+1][y1] == 5 || grid[x1+1][y1] == 6)){ grid[x1][y1] = 0; x1 = x1+1; continue; } return false; } if(grid[x1][y1] == 5){ if(x1-1 &gt;= 0 &amp;&amp; grid[x1-1][y1] != 0 &amp;&amp; (grid[x1-1][y1] == 2 || grid[x1-1][y1] == 3 || grid[x1-1][y1] == 4)){ grid[x1][y1] = 0; x1 = x1-1; continue; } if(y1-1 &gt;= 0 &amp;&amp; grid[x1][y1-1] != 0 &amp;&amp; (grid[x1][y1-1] == 1 || grid[x1][y1-1] == 4 || grid[x1][y1-1] == 6)){ grid[x1][y1] = 0; y1 = y1-1; continue; } return false; } if(grid[x1][y1] == 6){ if(y1+1 &lt; grid[0].size() &amp;&amp; grid[x1][y1+1] != 0 &amp;&amp; (grid[x1][y1+1] == 1 || grid[x1][y1+1] == 3 || grid[x1][y1+1] == 5)){ grid[x1][y1] = 0; y1 = y1+1; continue; } if(x1-1 &gt;= 0 &amp;&amp; grid[x1-1][y1] != 0 &amp;&amp; (grid[x1-1][y1] == 2 || grid[x1-1][y1] == 3 || grid[x1-1][y1] == 4)){ grid[x1][y1] = 0; x1 = x1-1; continue; } return false; } } } bool hasValidPath(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { if(grid[0][0] == 4){ grid[0][0] = 0; if(pd(grid, 0, 1)) return true; if(pd(grid, 1, 0)) return true; } else{ if(pd(grid, 0, 0)) return true; } return false; } }; 题目地址:https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5178. 四因数]]></title>
    <url>%2F2020%2F03%2F23%2Fleetcode%205178.%20%E5%9B%9B%E5%9B%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums，请你返回该数组中恰有四个因数的这些整数的各因数之和。 如果数组中不存在满足题意的整数，则返回 0 。 示例：示例： 输入：nums = [21,4,7] 输出：32 解释： 21 有 4 个因数：1, 3, 7, 21 4 有 3 个因数：1, 2, 4 7 有 2 个因数：1, 7 答案仅为 21 的所有因数的和。 提示： 1 &lt;= nums.length &lt;= 10^4 1 &lt;= nums[i] &lt;= 10^5 分析：从1遍历到开根号即可 注意记录因数数量的时候需要注意两个因数相同的时候只能算成一个因数 代码：class Solution { public: int sumFourDivisors(vector&lt;int&gt;&amp; nums) { int ret = 0; for(int i = 0; i &lt; nums.size(); i++){ int z = 0; int x = 0; for(int j = 1; j*j &lt;= nums[i]; j++){ if(nums[i] % j == 0){ if(nums[i] / j == j){ z++; x += j; } else{ z += 2; x += j; x += (nums[i] / j); } } } if(z == 4){ ret += x; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/four-divisors/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5364. 按既定顺序创建目标数组]]></title>
    <url>%2F2020%2F03%2F23%2Fleetcode%205364.%20%E6%8C%89%E6%97%A2%E5%AE%9A%E9%A1%BA%E5%BA%8F%E5%88%9B%E5%BB%BA%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组： 目标数组 target 最初为空。 按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。 重复上一步，直到在 nums 和 index 中都没有要读取的元素。 请你返回目标数组。 题目保证数字插入位置总是存在。 示例：示例 1： 输入：nums = [0,1,2,3,4], index = [0,1,2,2,1] 输出：[0,4,1,3,2] 解释： nums index target 0 0 [0] 1 1 [0,1] 2 2 [0,1,2] 3 2 [0,1,3,2] 4 1 [0,4,1,3,2] 示例 2： 输入：nums = [1,2,3,4,0], index = [0,1,2,3,0] 输出：[0,1,2,3,4] 解释： nums index target 1 0 [1] 2 1 [1,2] 3 2 [1,2,3] 4 3 [1,2,3,4] 0 0 [0,1,2,3,4] 示例 3： 输入：nums = [1], index = [0] 输出：[1] 提示： 1 &lt;= nums.length, index.length &lt;= 100 nums.length == index.length 0 &lt;= nums[i] &lt;= 100 0 &lt;= index[i] &lt;= i 分析：如果index[i]所指向的位置已经有数字了，将已填入的数字向后移动，依次类推直到遇到空的位置，如果没有数字，直接填入 还可以直接使用insert来插入 代码：class Solution { public: vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) { vector&lt;int&gt; vi(nums.size(), 0); for(int i = 0; i &lt; nums.size(); i++){ if(vi[index[i]] == 0){ vi[index[i]] = nums[i]; } else{ int z = nums[i]; int j; for(j = index[i]; j &lt; nums.size() &amp;&amp; vi[j] != 0; j++){ int x = vi[j]; vi[j] = z; z = x; } vi[j] = z; } } return vi; } }; 题目地址:https://leetcode-cn.com/problems/create-target-array-in-the-given-order/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5359. 最大的团队表现值]]></title>
    <url>%2F2020%2F03%2F16%2Fleetcode%205359.%20%E6%9C%80%E5%A4%A7%E7%9A%84%E5%9B%A2%E9%98%9F%E8%A1%A8%E7%8E%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：公司有编号为 1 到 n 的 n 个工程师，给你两个数组 speed 和 efficiency ，其中 speed[i] 和 efficiency[i] 分别代表第 i 位工程师的速度和效率。请你返回由最多 k 个工程师组成的 ​​​​​​最大团队表现值 ，由于答案可能很大，请你返回结果对 10^9 + 7 取余后的结果。 团队表现值 的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。 示例：示例 1： 输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2 输出：60 解释： 我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。 示例 2： 输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3 输出：68 解释： 此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。 示例 3： 输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4 输出：72 提示： 1 &lt;= n &lt;= 10^5 speed.length == n efficiency.length == n 1 &lt;= speed[i] &lt;= 10^5 1 &lt;= efficiency[i] &lt;= 10^8 1 &lt;= k &lt;= n 分析： 将speed和efficiency同步按照efficiency从大到小排序 遍历 所有工程师速度的和 取已经遍历过的speed中最大的k个数之和，可以使用multiset来得出最大的k个数 效率值中的最小值 取已经遍历过的efficiency中最小的也就是最后一个 将两个数相乘即可 最后取余 代码：bool bj(vector&lt;int&gt; a, vector&lt;int&gt; b){ if(a[1] &gt; b[1]){ return true; } else if(a[1] &lt; b[1]){ return false; } else{ return a[0] &gt; b[0]; } } class Solution { public: int maxPerformance(int n, vector&lt;int&gt;&amp; speed, vector&lt;int&gt;&amp; efficiency, int k) { vector&lt;vector&lt;int&gt;&gt; vvi(n, vector&lt;int&gt;(2, 0)); multiset&lt;int&gt; vs; long s = 0; long e = 0; long m = 0; for(int i = 0; i &lt; n; i++){ vvi[i][0] = speed[i]; vvi[i][1] = efficiency[i]; } sort(vvi.begin(), vvi.end(), bj); for(int i = 0; i &lt; n; i++){ if(vs.size() &lt; k){ vs.insert(vvi[i][0]); s += vvi[i][0]; } else{ vs.insert(vvi[i][0]); s = s - *vs.begin() + vvi[i][0]; vs.erase(vs.begin()); } e = vvi[i][1]; m = m &gt; e*s ? m : e*s; } return m % 1000000007; } }; 题目地址:https://leetcode-cn.com/problems/maximum-performance-of-a-team/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5179. 将二叉搜索树变平衡]]></title>
    <url>%2F2020%2F03%2F16%2Fleetcode%205179.%20%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[题目：给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。 如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。 如果有多种构造方法，请你返回任意一种。 示例：输入：root = [1,null,2,null,3,null,4,null,null] 输出：[2,1,3,null,null,null,4] 解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。 提示： 树节点的数目在 1 到 10^4 之间。 树节点的值互不相同，且在 1 到 10^5 之间。 分析：首先使用中序遍历按从小到大保存至数组 递归构建二叉平衡树 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { vector&lt;int&gt; vi; public: void dfs1(TreeNode* root){ if(root == NULL){ return; } dfs1(root-&gt;left); vi.push_back(root-&gt;val); dfs1(root-&gt;right); } TreeNode* dfs2(int l, int r){ if(l &gt; r) return NULL; int z = (l+r)/2; TreeNode* t = new TreeNode(vi[z]); t-&gt;left = dfs2(l, z-1); t-&gt;right = dfs2(z+1, r); return t; } TreeNode* balanceBST(TreeNode* root) { dfs1(root); return dfs2(0, vi.size()-1); } }; 题目地址:https://leetcode-cn.com/problems/balance-a-binary-search-tree/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2020%2F03%2F16%2Fleetcode%205357.%20%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[题目：请你设计一个支持下述操作的栈。 实现自定义栈类 CustomStack ： CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。 void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。 int pop()：返回栈顶的值，或栈为空时返回 -1 。 void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。 示例：输入： [&quot;CustomStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;pop&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;increment&quot;,&quot;increment&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;] [[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]] 输出： [null,null,null,2,null,null,null,null,null,103,202,201,-1] 解释： CustomStack customStack = new CustomStack(3); // 栈是空的 [] customStack.push(1); // 栈变为 [1] customStack.push(2); // 栈变为 [1, 2] customStack.pop(); // 返回 2 --&gt; 返回栈顶值 2，栈变为 [1] customStack.push(2); // 栈变为 [1, 2] customStack.push(3); // 栈变为 [1, 2, 3] customStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4 customStack.increment(5, 100); // 栈变为 [101, 102, 103] customStack.increment(2, 100); // 栈变为 [201, 202, 103] customStack.pop(); // 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202] customStack.pop(); // 返回 202 --&gt; 返回栈顶值 202，栈变为 [201] customStack.pop(); // 返回 201 --&gt; 返回栈顶值 201，栈变为 [] customStack.pop(); // 返回 -1 --&gt; 栈为空，返回 -1 提示： 1 &lt;= maxSize &lt;= 1000 1 &lt;= x &lt;= 1000 1 &lt;= k &lt;= 1000 0 &lt;= val &lt;= 100 每种方法 increment，push 以及 pop 分别最多调用 1000 次 分析：直接照要求写，记得处理细节 代码：class CustomStack { private: vector&lt;int&gt; vi; int z = 0; public: CustomStack(int maxSize) { for(int i = 0; i &lt; maxSize; i++){ vi.push_back(-1); } } void push(int x) { if(z == vi.size()) return; vi[z] = x; z++; } int pop() { if(z == 0) return -1; z--; return vi[z]; } void increment(int k, int val) { for(int i = 0; i &lt; z &amp;&amp; i &lt; k; i++){ vi[i] += val; } } }; /** * Your CustomStack object will be instantiated and called as such: * CustomStack* obj = new CustomStack(maxSize); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * obj-&gt;increment(k,val); */ 题目地址:https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5356. 矩阵中的幸运数]]></title>
    <url>%2F2020%2F03%2F16%2Fleetcode%205356.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。 幸运数是指矩阵中满足同时下列两个条件的元素： 在同一行的所有元素中最小 在同一列的所有元素中最大 示例：示例 1： 输入：matrix = [[3,7,8],[9,11,13],[15,16,17]] 输出：[15] 解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 2： 输入：matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]] 输出：[12] 解释：12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。 示例 3： 输入：matrix = [[7,8],[1,2]] 输出：[7] 提示： m == mat.length n == mat[i].length 1 &lt;= n, m &lt;= 50 1 &lt;= matrix[i][j] &lt;= 10^5 矩阵中的所有元素都是不同的 分析：直接遍历，然后对同行和同列进行比较 代码：class Solution { public: vector&lt;int&gt; luckyNumbers (vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { vector&lt;int&gt; ret; for(int i = 0; i &lt; matrix.size(); i++){ for(int j = 0; j &lt; matrix[0].size(); j++){ bool b1 = true; bool b2 = true; for(int x = 0; x &lt; matrix.size(); x++){ if(x != i){ if(matrix[i][j] &gt; matrix[x][j]){ b1 = true; } else{ b1 = false; break; } } } for(int y = 0; y &lt; matrix[0].size(); y++){ if(y != j){ if(matrix[i][j] &lt; matrix[i][y]){ b2 = true; } else{ b2 = false; break; } } } if(b1 &amp;&amp; b2){ ret.push_back(matrix[i][j]); } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5355. T 秒后青蛙的位置]]></title>
    <url>%2F2020%2F03%2F09%2Fleetcode%205355.%20T%20%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 n。青蛙从 顶点 1 开始起跳。规则如下： 在一秒内，青蛙从它所在的当前顶点跳到另一个 未访问 过的顶点（如果它们直接相连）。 青蛙无法跳回已经访问过的顶点。 如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。 如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。无向树的边用数组 edges 描述，其中 edges[i] = [fromi, toi] 意味着存在一条直接连通 fromi 和 toi 两个顶点的边。 返回青蛙在 t 秒后位于目标顶点 target 上的概率。 示例：示例 1： 输入：n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4 输出：0.16666666666666666 解释：上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，第 1 秒 有 1/3 的概率跳到顶点 2 ，然后第 2 秒 有 1/2 的概率跳到顶点 4，因此青蛙在 2 秒后位于顶点 4 的概率是 1/3 * 1/2 = 1/6 = 0.16666666666666666 。 示例 2： 输入：n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7 输出：0.3333333333333333 解释：上图显示了青蛙的跳跃路径。青蛙从顶点 1 起跳，有 1/3 = 0.3333333333333333 的概率能够 1 秒 后跳到顶点 7 。 示例 3： 输入：n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 20, target = 6 输出：0.16666666666666666 提示： 1 &lt;= n &lt;= 100 edges.length == n-1 edges[i].length == 2 1 &lt;= edges[i][0], edges[i][1] &lt;= n 1 &lt;= t &lt;= 50 1 &lt;= target &lt;= n 与准确值误差在 10^-5 之内的结果将被判定为正确。 分析：先将edges数组转换成每个结点的子节点形式。 使用dfs，每次往下遍历的时候将概率除以所有可以跳到的结点的数量，查找时间结束时如果能跳到结点target，就返回这时候的概率 代码：class Solution { public: double ret; bool b; void dfs(int z, vector&lt;vector&lt;int&gt;&gt;&amp; vi, int target, int t, double q){ if(t == 0) return; for(int i = 0; i &lt; vi[z].size(); i++){ if(target == vi[z][i] &amp;&amp; (t == 1 || vi[target].size() == 0)){ b = true; ret = q / vi[z].size(); } dfs(vi[z][i], vi, target, t-1, q / vi[z].size()); } } double frogPosition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int t, int target) { b = false; if(n == 1) return 1; vector&lt;vector&lt;int&gt;&gt; vi(n+1); for(int i = 0; i &lt; edges.size(); i++){ if(edges[i][0] &lt; edges[i][1]) vi[edges[i][0]].push_back(edges[i][1]); else vi[edges[i][1]].push_back(edges[i][0]); } dfs(1, vi, target, t, 1); if(b == false) return 0; return ret; } }; 题目地址:https://leetcode-cn.com/problems/frog-position-after-t-seconds/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5354. 通知所有员工所需的时间]]></title>
    <url>%2F2020%2F03%2F09%2Fleetcode%205354.%20%E9%80%9A%E7%9F%A5%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：公司里有 n 名员工，每个员工的 ID 都是独一无二的，编号从 0 到 n - 1。公司的总负责人通过 headID 进行标识。 在 manager 数组中，每个员工都有一个直属负责人，其中 manager[i] 是第 i 名员工的直属负责人。对于总负责人，manager[headID] = -1。题目保证从属关系可以用树结构显示。 公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。 第 i 名员工需要 informTime[i] 分钟来通知它的所有直属下属（也就是说在 informTime[i] 分钟后，他的所有直属下属都可以开始传播这一消息）。 返回通知所有员工这一紧急消息所需要的 分钟数 。 示例：示例 1： 输入：n = 1, headID = 0, manager = [-1], informTime = [0] 输出：0 解释：公司总负责人是该公司的唯一一名员工。 示例 2： 输入：n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0] 输出：1 解释：id = 2 的员工是公司的总负责人，也是其他所有员工的直属负责人，他需要 1 分钟来通知所有员工。 上图显示了公司员工的树结构。 示例 3： 输入：n = 7, headID = 6, manager = [1,2,3,4,5,6,-1], informTime = [0,6,5,4,3,2,1] 输出：21 解释：总负责人 id = 6。他将在 1 分钟内通知 id = 5 的员工。 id = 5 的员工将在 2 分钟内通知 id = 4 的员工。 id = 4 的员工将在 3 分钟内通知 id = 3 的员工。 id = 3 的员工将在 4 分钟内通知 id = 2 的员工。 id = 2 的员工将在 5 分钟内通知 id = 1 的员工。 id = 1 的员工将在 6 分钟内通知 id = 0 的员工。 所需时间 = 1 + 2 + 3 + 4 + 5 + 6 = 21 。 示例 4： 输入：n = 15, headID = 0, manager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6], informTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0] 输出：3 解释：第一分钟总负责人通知员工 1 和 2 。 第二分钟他们将会通知员工 3, 4, 5 和 6 。 第三分钟他们将会通知剩下的员工。 示例 5： 输入：n = 4, headID = 2, manager = [3,3,-1,2], informTime = [0,0,162,914] 输出：1076 提示： 1 &lt;= n &lt;= 10^5 0 &lt;= headID &lt; n manager.length == n 0 &lt;= manager[i] &lt; n manager[headID] == -1 informTime.length == n 0 &lt;= informTime[i] &lt;= 1000 如果员工 i 没有下属，informTime[i] == 0 。 题目 保证 所有员工都可以收到通知。 分析：将员工的直属负责人表转换成负责人的手下表。 使用dfs，求出到达叶节点所需要的最大时间 代码：class Solution { public: int ret; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; vvi, int ID, vector&lt;int&gt;&amp; informTime, int time){ if(vvi[ID].size() == 0){ ret = ret &gt; time ? ret : time; return; } for(int i = 0; i &lt; vvi[ID].size(); i++){ dfs(vvi, vvi[ID][i], informTime, time + informTime[ID]); } } int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) { ret = 0; vector&lt;vector&lt;int&gt;&gt; vvi(n); for(int i = 0; i &lt; n; i++){ if(i != headID) vvi[manager[i]].push_back(i); } dfs(vvi, headID, informTime, 0); return ret; } }; 题目地址:https://leetcode-cn.com/problems/time-needed-to-inform-all-employees/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5353. 灯泡开关 III]]></title>
    <url>%2F2020%2F03%2F09%2Fleetcode%205353.%20%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3%20III%2F</url>
    <content type="text"><![CDATA[题目：房间中有 n 枚灯泡，编号从 1 到 n，自左向右排成一排。最初，所有的灯都是关着的。 在 k 时刻（ k 的取值范围是 0 到 n - 1），我们打开 light[k] 这个灯。 灯的颜色要想 变成蓝色 就必须同时满足下面两个条件： 灯处于打开状态。 排在它之前（左侧）的所有灯也都处于打开状态。 请返回能够让 所有开着的 灯都 变成蓝色 的时刻 数目 。 示例：示例 1： 输入：light = [2,1,3,5,4] 输出：3 解释：所有开着的灯都变蓝的时刻分别是 1，2 和 4 。 示例 2： 输入：light = [3,2,4,1,5] 输出：2 解释：所有开着的灯都变蓝的时刻分别是 3 和 4（index-0）。 示例 3： 输入：light = [4,1,2,3] 输出：1 解释：所有开着的灯都变蓝的时刻是 3（index-0）。 第 4 个灯在时刻 3 变蓝。 示例 4： 输入：light = [2,1,4,3,6,5] 输出：3 示例 5： 输入：light = [1,2,3,4,5,6] 输出：6 提示： n == light.length 1 &lt;= n &lt;= 5 * 10^4 light 是 [1, 2, …, n] 的一个排列。 分析：可以利用累加之前已经出现的亮灯编号以及最大的亮灯编号时全亮的累加和，只要两个值相等，返回值加1 也可以只统计亮灯数目和最大亮灯编号，这个方法更好 代码：class Solution { public: int numTimesAllBlue(vector&lt;int&gt;&amp; light) { int z = 0; int z1 = 0; int ret = 0; for(int i = 0; i &lt; light.size(); i++){ int x = long(1 + light[i]) * light[i] / 2; z = x &gt; z ? x : z; z1 += light[i]; if(z1 == z) ret++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/bulb-switcher-iii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5352. 生成每种字符都是奇数个的字符串]]></title>
    <url>%2F2020%2F03%2F09%2Fleetcode%205352.%20%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。 返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。 示例：示例 1： 输入：n = 4 输出：&quot;pppz&quot; 解释：&quot;pppz&quot; 是一个满足题目要求的字符串，因为 &apos;p&apos; 出现 3 次，且 &apos;z&apos; 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ohhh&quot; 和 &quot;love&quot;。 示例 2： 输入：n = 2 输出：&quot;xy&quot; 解释：&quot;xy&quot; 是一个满足题目要求的字符串，因为 &apos;x&apos; 和 &apos;y&apos; 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ag&quot; 和 &quot;ur&quot;。 示例 3： 输入：n = 7 输出：&quot;holasss&quot; 提示： 1 &lt;= n &lt;= 500 分析：如果n是偶数，输出n-1个a，一个b 如果n是奇数，输出n个a 代码：class Solution { public: string generateTheString(int n) { string str = &quot;&quot;; if(n % 2 == 0){ for(int i = 0; i &lt; n-1; i++){ str += &apos;a&apos;; } str += &apos;b&apos;; } else { for(int i = 0; i &lt; n; i++){ str += &apos;a&apos;; } } return str; } }; 题目地址:https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1368. 使网格图至少有一条有效路径的最小代价]]></title>
    <url>%2F2020%2F03%2F02%2Fleetcode%201368.%20%E4%BD%BF%E7%BD%91%E6%A0%BC%E5%9B%BE%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E6%9D%A1%E6%9C%89%E6%95%88%E8%B7%AF%E5%BE%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[题目：给你一个 m x n 的网格图 grid 。 grid 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 grid[i][j] 中的数字可能为以下几种情况： 1 ，下一步往右走，也就是你会从 grid[i][j] 走到 grid[i][j + 1] 2 ，下一步往左走，也就是你会从 grid[i][j] 走到 grid[i][j - 1] 3 ，下一步往下走，也就是你会从 grid[i][j] 走到 grid[i + 1][j] 4 ，下一步往上走，也就是你会从 grid[i][j] 走到 grid[i - 1][j] 注意网格图中可能会有 无效数字 ，因为它们可能指向 grid 以外的区域。 一开始，你会从最左上角的格子 (0,0) 出发。我们定义一条 有效路径 为从格子 (0,0) 出发，每一步都顺着数字对应方向走，最终在最右下角的格子 (m - 1, n - 1) 结束的路径。有效路径 不需要是最短路径 。 你可以花费 cost = 1 的代价修改一个格子中的数字，但每个格子中的数字 只能修改一次 。 请你返回让网格图至少有一条有效路径的最小代价。 示例：示例 1： 输入：grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]] 输出：3 解释：你将从点 (0, 0) 出发。 到达 (3, 3) 的路径为： (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) 花费代价 cost = 1 使方向向下 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) 花费代价 cost = 1 使方向向下 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) 花费代价 cost = 1 使方向向下 --&gt; (3, 3) 总花费为 cost = 3. 示例 2： 输入：grid = [[1,1,3],[3,2,2],[1,1,4]] 输出：0 解释：不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。 示例 3： 输入：grid = [[1,2],[4,3]] 输出：1 示例 4： 输入：grid = [[2,2,2],[2,2,2]] 输出：3 示例 5： 输入：grid = [[4]] 输出：0 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 100 分析：使用bfs 找到cost为0时能遍历的点，再将这些点设置成可以向四个方向扩展的点，这样找到的点就是cost为1的点，循环此操作直到求出最右下的点到达时所需要cost的值。 代码：class Solution { public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { vector&lt;vector&lt;int&gt;&gt; vvi(grid.size(), vector&lt;int&gt;(grid[0].size(), -1)); int z[5] = {0, 0, 0, 1, -1}; int z1[5] = {0, 1, -1, 0, 0}; int cost = 0; queue&lt;vector&lt;int&gt;&gt; q; q.push(vector&lt;int&gt;{0,0}); while(vvi[grid.size()-1][grid[0].size()-1] == -1){ // 不能到达右下角格子就一直循环 while(q.size() != 0){ // 遍历队列 vector&lt;int&gt; v = q.front(); vector&lt;int&gt; v1{0,0}; q.pop(); if(vvi[v[0]][v[1]] == cost) // 当前修改次数下已经遍历过就不需要再遍历了 continue; if(vvi[v[0]][v[1]] == -1) // 新的未到达过的格子赋值为现修改次数 vvi[v[0]][v[1]] = cost; if(grid[v[0]][v[1]] == 0){ // 修改后的格子可以向四个方向走 for(int i = 1; i &lt; 5; i++){ v1[0] = v[0] + z[i]; v1[1] = v[1] + z1[i]; if(v1[0] &gt;= 0 &amp;&amp; v1[0] &lt; grid.size() &amp;&amp; v1[1] &gt;= 0 &amp;&amp; v1[1] &lt; grid[0].size()){ // 判溢出 if(grid[v1[0]][v1[1]] != 0) // 如果下一个格子是修改过的就不需要入列，因为下一个格子已经入列过了 q.push(v1); } } } else{ // 没修改过只能向一个方向走 v1[0] = v[0] + z[grid[v[0]][v[1]]]; v1[1] = v[1] + z1[grid[v[0]][v[1]]]; if(v1[0] &gt;= 0 &amp;&amp; v1[0] &lt; grid.size() &amp;&amp; v1[1] &gt;= 0 &amp;&amp; v1[1] &lt; grid[0].size()){ if(grid[v1[0]][v1[1]] != 0) q.push(v1); } } grid[v[0]][v[1]] = 0; // 已经走过的格子下次经过时就已经修改成四个方向的，这一步可以放在p1处 } for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ if(vvi[i][j] == cost){ // 将最后一次修改的格子放入队列 // p1，可以在遍历完一次后修改刚刚遍历过的格子 q.push(vector&lt;int&gt;{i, j}); } } } cost++; // 一次遍历完毕修改次数要加一 } return vvi[grid.size()-1][grid[0].size()-1]; } }; 题目地址:https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1367. 二叉树中的列表]]></title>
    <url>%2F2020%2F03%2F02%2Fleetcode%201367.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目：给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。 如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。 一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。 示例：示例 1： 输入：head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3] 输出：true 解释：树中蓝色的节点构成了与链表对应的子路径。 示例 2： 输入：head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3] 输出：true 示例 3： 输入：head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3] 输出：false 解释：二叉树中不存在一一对应链表的路径。 提示： 二叉树和链表中的每个节点的值都满足 1 &lt;= node.val &lt;= 100 。 链表包含的节点数目在 1 到 100 之间。 二叉树包含的节点数目在 1 到 2500 之间。 分析：dfs，从每个节点开始比较，找到连续的和链表相同的值 代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { private: bool b; ListNode* head1; public: void dfs(ListNode* head, TreeNode* root, bool a){ if(b == true) return; if(head == NULL){ b = true; return; } if(root == NULL) return; if(head-&gt;val == root-&gt;val){ dfs(head-&gt;next, root-&gt;left, true); dfs(head-&gt;next, root-&gt;right, true); } if(a == true){ return; } dfs(head1, root-&gt;left, false); dfs(head1, root-&gt;right, false); } bool isSubPath(ListNode* head, TreeNode* root) { b = false; head1 = head; dfs(head, root, false); return b; } }; 题目地址:https://leetcode-cn.com/problems/linked-list-in-binary-tree/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1366. 通过投票对团队排名]]></title>
    <url>%2F2020%2F03%2F02%2Fleetcode%201366.%20%E9%80%9A%E8%BF%87%E6%8A%95%E7%A5%A8%E5%AF%B9%E5%9B%A2%E9%98%9F%E6%8E%92%E5%90%8D%2F</url>
    <content type="text"><![CDATA[题目：现在有一个特殊的排名系统，依据参赛团队在投票人心中的次序进行排名，每个投票者都需要按从高到低的顺序对参与排名的所有团队进行排位。 排名规则如下： 参赛团队的排名次序依照其所获「排位第一」的票的多少决定。如果存在多个团队并列的情况，将继续考虑其「排位第二」的票的数量。以此类推，直到不再存在并列的情况。 如果在考虑完所有投票情况后仍然出现并列现象，则根据团队字母的字母顺序进行排名。给你一个字符串数组 votes 代表全体投票者给出的排位情况，请你根据上述排名规则对所有参赛团队进行排名。 请你返回能表示按排名系统 排序后 的所有团队排名的字符串。 示例：示例 1： 输入：votes = [&quot;ABC&quot;,&quot;ACB&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;ACB&quot;] 输出：&quot;ACB&quot; 解释：A 队获得五票「排位第一」，没有其他队获得「排位第一」，所以 A 队排名第一。 B 队获得两票「排位第二」，三票「排位第三」。 C 队获得三票「排位第二」，两票「排位第三」。 由于 C 队「排位第二」的票数较多，所以 C 队排第二，B 队排第三。 示例 2： 输入：votes = [&quot;WXYZ&quot;,&quot;XYZW&quot;] 输出：&quot;XWYZ&quot; 解释：X 队在并列僵局打破后成为排名第一的团队。X 队和 W 队的「排位第一」票数一样，但是 X 队有一票「排位第二」，而 W 没有获得「排位第二」。 示例 3： 输入：votes = [&quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot;] 输出：&quot;ZMNAGUEDSJYLBOPHRQICWFXTVK&quot; 解释：只有一个投票者，所以排名完全按照他的意愿。 示例 4： 输入：votes = [&quot;BCA&quot;,&quot;CAB&quot;,&quot;CBA&quot;,&quot;ABC&quot;,&quot;ACB&quot;,&quot;BAC&quot;] 输出：&quot;ABC&quot; 解释： A 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。 B 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。 C 队获得两票「排位第一」，两票「排位第二」，两票「排位第三」。 完全并列，所以我们需要按照字母升序排名。 示例 5： 输入：votes = [&quot;M&quot;,&quot;M&quot;,&quot;M&quot;,&quot;M&quot;] 输出：&quot;M&quot; 解释：只有 M 队参赛，所以它排名第一。 提示： 1 &lt;= votes.length &lt;= 1000 1 &lt;= votes[i].length &lt;= 26 votes[i].length == votes[j].length for 0 &lt;= i, j &lt; votes.length votes[i][j] 是英文 大写 字母 votes[i] 中的所有字母都是唯一的 votes[0] 中出现的所有字母 同样也 出现在 votes[j] 中，其中 1 &lt;= j &lt; votes.length 分析：定义一个结构，包含队伍名和排名 统计每一个队伍各个排名的数量 定义一个排序方式，依次从第一开始比较 按照排序后队伍顺序输出 代码：struct n{ char c; int p[26]; n(){ for(int i = 0; i &lt; 26; i++){ p[i] = 0; } } }; bool bj(n a, n b){ for(int i = 0; i &lt; 26; i++){ if(a.p[i] &gt; b.p[i]){ return true; } else if(a.p[i] &lt; b.p[i]){ return false; } } if(a.c &lt; b.c){ return true; } return false; } class Solution { public: string rankTeams(vector&lt;string&gt;&amp; votes) { vector&lt;n&gt; n1(26); string s = &quot;&quot;; for(int i = 0; i &lt; 26; i++){ n1[i].c = i+&apos;A&apos;; } for(int i = 0; i &lt; votes.size(); i++){ for(int j = 0; j &lt; votes[0].size(); j++){ n1[votes[i][j]-&apos;A&apos;].p[j]++; } } sort(n1.begin(), n1.end(), bj); for(int i = 0; i &lt; votes[0].size(); i++){ s += n1[i].c; } return s; } }; 题目地址:https://leetcode-cn.com/problems/rank-teams-by-votes/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1365. 有多少小于当前数字的数字]]></title>
    <url>%2F2020%2F03%2F02%2Fleetcode%201365.%20%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。 换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。 以数组形式返回答案。 示例：示例 1： 输入：nums = [8,1,2,2,3] 输出：[4,0,1,1,3] 解释： 对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 对于 nums[1]=1 不存在比它小的数字。 对于 nums[2]=2 存在一个比它小的数字：（1）。 对于 nums[3]=2 存在一个比它小的数字：（1）。 对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。 示例 2： 输入：nums = [6,5,4,8] 输出：[2,1,0,3] 示例 3： 输入：nums = [7,7,7,7] 输出：[0,0,0,0] 提示： 2 &lt;= nums.length &lt;= 500 0 &lt;= nums[i] &lt;= 100 分析：数据量不大，直接两个循环解决 代码：class Solution { public: vector&lt;int&gt; smallerNumbersThanCurrent(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; ret(nums.size(), 0); for(int i = 0; i &lt; nums.size(); i++){ for(int j = 0; j &lt; nums.size(); j++){ if(j == i) continue; if(nums[j] &lt; nums[i]) ret[i]++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1363. 形成三的最大倍数]]></title>
    <url>%2F2020%2F02%2F24%2Fleetcode%201363.%20%E5%BD%A2%E6%88%90%E4%B8%89%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 digits，你可以通过按任意顺序连接其中某些数字来形成 3 的倍数，请你返回所能得到的最大的 3 的倍数。 由于答案可能不在整数数据类型范围内，请以字符串形式返回答案。 如果无法得到答案，请返回一个空字符串。 示例：示例 1： 输入：digits = [8,1,9] 输出：&quot;981&quot; 示例 2： 输入：digits = [8,6,7,1,0] 输出：&quot;8760&quot; 示例 3： 输入：digits = [1] 输出：&quot;&quot; 示例 4： 输入：digits = [0,0,0,0,0,0] 输出：&quot;0&quot; 提示： 1 &lt;= digits.length &lt;= 10^4 0 &lt;= digits[i] &lt;= 9 返回的结果不应包含不必要的前导零。 分析：将所有的数相加 取模3 等于0，那么这个数本身就可以被3整除 等于1，可以去掉一个模为1的数，或者去掉两个个模为2的数 等于2，可以去掉一个模为2的数，或者去掉两个个模为1的数 最后将剩余的数从大到小排序即可。 注意如果只有0的话，只需要返回一个0即可 代码：class Solution { private: string ans; int sum; int cnt[10]; public: bool del(int a){ for(int i = a; i &lt; 9; i+=3){ if(cnt[i] &gt; 0){ cnt[i]--; return true; } } return false; } string largestMultipleOfThree(vector&lt;int&gt;&amp; digits) { ans = &quot;&quot;; sum = 0; memset(cnt, 0, sizeof(cnt)); for(int i = 0; i &lt; digits.size(); i++){ cnt[digits[i]]++; sum += digits[i]; } if(sum % 3 == 1){ // 如果无法得到答案的话，在这一步就已经会将字符串清空，因为只有小于等于两个数才可能没答案 if(!del(1)){ del(2); del(2); } } else if(sum % 3 == 2){ if(!del(2)){ del(1); del(1); } } for(int i = 9; i &gt;= 0; i--){ while(cnt[i]){ ans += &apos;0&apos;+i; cnt[i]--; } } for(int i = 0; i &lt; ans.size(); i++){ if(ans[i] != 0) break; else if(i+1 == ans.size()) return &quot;0&quot;; } return ans; } }; 题目地址:https://leetcode-cn.com/problems/largest-multiple-of-three/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1362. 最接近的因数]]></title>
    <url>%2F2020%2F02%2F24%2Fleetcode%201362.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%9B%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 num，请你找出同时满足下面全部要求的两个整数： 两数乘积等于 num + 1 或 num + 2 以绝对差进行度量，两数大小最接近 你可以按任意顺序返回这两个整数。 示例：示例 1： 输入：num = 8 输出：[3,3] 解释：对于 num + 1 = 9，最接近的两个因数是 3 &amp; 3；对于 num + 2 = 10, 最接近的两个因数是 2 &amp; 5，因此返回 3 &amp; 3 。 示例 2： 输入：num = 123 输出：[5,25] 示例 3： 输入：num = 999 输出：[40,25] 提示： 1 &lt;= num &lt;= 10^9 分析：申明两个数，i从1开始加，j从num+2开始减，直到i&gt;j。每找到一个接近的因数就记录下来。i一直保持++，j在i++的时候需要按比例缩小，这样可以避免没有必要的j–。 有一个更好的办法,直接i从根号n向1遍历，对应的j = n/i，只要找到能整除就记录下来，比较差值即可:https://leetcode-cn.com/problems/closest-divisors/solution/zui-jie-jin-de-yin-shu-by-leetcode-solution/ 代码：class Solution { public: vector&lt;int&gt; closestDivisors(int num) { int m = INT_MAX; vector&lt;int&gt; v(2, 0); for(int i = 1, j = num+2; i &lt;= j; ){ if(i*j == num+1 || i*j == num+2){ if((i-j &gt; 0 ? i-j : j-i) &lt; m){ m = (i-j &gt; 0 ? i-j : j-i); v[0] = i; v[1] = j; } j--; } else if(i*j &gt; num){ j--; } else{ j = j * i/(i+1)+1; // 因为i++相当于i*(i+1)/i, 所以当j*i/(i+1)时，两个值是相等的，+1是为了恢复到大于num+2的情况以防漏掉可能满足要求的情况 i++; } } return v; } }; 题目地址:https://leetcode-cn.com/problems/closest-divisors/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1361. 验证二叉树]]></title>
    <url>%2F2020%2F02%2F24%2Fleetcode%201361.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目：二叉树上有 n 个节点，按从 0 到 n - 1 编号，其中节点 i 的两个子节点分别是 leftChild[i] 和 rightChild[i]。 只有 所有 节点能够形成且 只 形成 一颗 有效的二叉树时，返回 true；否则返回 false。 如果节点 i 没有左子节点，那么 leftChild[i] 就等于 -1。右子节点也符合该规则。 注意：节点没有值，本问题中仅仅使用节点编号。 示例：示例 1： 输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1] 输出：true 示例 2： 输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1] 输出：false 示例 3： 输入：n = 2, leftChild = [1,0], rightChild = [-1,-1] 输出：false 示例 4： 输入：n = 6, leftChild = [1,-1,-1,4,-1,-1], rightChild = [2,-1,-1,5,-1,-1] 输出：false 提示： 1 &lt;= n &lt;= 10^4 leftChild.length == rightChild.length == n -1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1 分析：使用一个map用来记录结点是否出现过 对每个节点进行三次判断： 如果当前节点没有出现过，说明这是一个新的二叉树，返回false 如果左子树结点已经出现过，说明这个子节点已经是别的结点的子节点，返回false 右子树同理 最后返回ture 还有一个网上看到的方法（这个方法更好），计算每个节点的入度。根节点入度为0，每个非空节点的入度都为1。这样只要判断入度为0的结点是否只有一个，是否有入度大于1的结点即可，方法地址：https://leetcode-cn.com/problems/validate-binary-tree-nodes/solution/zhuan-huan-cheng-tu-de-si-xiang-ji-suan-mei-ge-jie/ 代码：class Solution { public: bool validateBinaryTreeNodes(int n, vector&lt;int&gt;&amp; leftChild, vector&lt;int&gt;&amp; rightChild) { map&lt;int, int&gt; m; m[0] = 0; for(int i = 0; i &lt; leftChild.size(); i++){ if(m.count(i) == 0){ return false; } if(leftChild[i] != -1 &amp;&amp; m.count(leftChild[i]) != 0){ return false; } m[leftChild[i]] = 1; if(rightChild[i] != -1 &amp;&amp; m.count(rightChild[i]) != 0){ return false; } m[rightChild[i]] = 1; } return true; } }; 题目地址:https://leetcode-cn.com/problems/validate-binary-tree-nodes/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1360. 日期之间隔几天]]></title>
    <url>%2F2020%2F02%2F24%2Fleetcode%201360.%20%E6%97%A5%E6%9C%9F%E4%B9%8B%E9%97%B4%E9%9A%94%E5%87%A0%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[题目：请你编写一个程序来计算两个日期之间隔了多少天。 日期以字符串形式给出，格式为 YYYY-MM-DD，如示例所示。 示例：示例 1： 输入：date1 = &quot;2019-06-29&quot;, date2 = &quot;2019-06-30&quot; 输出：1 示例 2： 输入：date1 = &quot;2020-01-15&quot;, date2 = &quot;2019-12-31&quot; 输出：15 提示： 给定的日期是 1971 年到 2100 年之间的有效日期。 分析：直接计算，记得计算闰年。 可以使用时间库函数 代码：class Solution { public: int daysBetweenDates(string date1, string date2) { int z[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; int z1[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; int ret = 0; int y1 = date1[0] - &apos;0&apos;; y1 = y1*10 + date1[1] - &apos;0&apos;; y1 = y1*10 + date1[2] - &apos;0&apos;; y1 = y1*10 + date1[3] - &apos;0&apos;; int m1 = date1[5] - &apos;0&apos;; m1 = m1*10 + date1[6] - &apos;0&apos;; int d1 = date1[8] - &apos;0&apos;; d1 = d1*10 + date1[9] - &apos;0&apos;; int y2 = date2[0] - &apos;0&apos;; y2 = y2*10 + date2[1] - &apos;0&apos;; y2 = y2*10 + date2[2] - &apos;0&apos;; y2 = y2*10 + date2[3] - &apos;0&apos;; int m2 = date2[5] - &apos;0&apos;; m2 = m2*10 + date2[6] - &apos;0&apos;; int d2 = date2[8] - &apos;0&apos;; d2 = d2*10 + date2[9] - &apos;0&apos;; if(y1 &gt; y2){ int x = y1; y1 = y2; y2 = x; x = m1; m1 = m2; m2 = x; x = d1; d1 = d2; d2 = x; } else if(y1 == y2){ if(m1 &gt; m2){ int x = y1; y1 = y2; y2 = x; x = m1; m1 = m2; m2 = x; x = d1; d1 = d2; d2 = x; } else if(m1 == m2){ if(d1 &gt; d2){ int x = y1; y1 = y2; y2 = x; x = m1; m1 = m2; m2 = x; x = d1; d1 = d2; d2 = x; } } } for(int i = y1+1; i &lt; y2; i++){ if(i % 4 == 0 &amp;&amp; i % 100 != 0 || i % 400 == 0){ ret += 366; } else ret += 365; } int da1 = 0; for(int i = 1; i &lt; m1; i++){ if(y1 % 4 == 0 &amp;&amp; y1 % 100 != 0 || y1 % 400 == 0){ da1 += z1[i-1]; } else{ da1 += z[i-1]; } } da1 += d1; int da2 = 0; for(int i = 1; i &lt; m2; i++){ if(y2 % 4 == 0 &amp;&amp; y2 % 100 != 0 || y2 % 400 == 0){ da2 += z1[i-1]; } else{ da2 += z[i-1]; } } da2 += d2; if(y1 == y2){ return da2 - da1 + ret; } else{ if(y1 % 4 == 0 &amp;&amp; y1 % 100 != 0 || y1 % 400 == 0){ ret += 366 - da1; } else{ ret += 365 - da1; } return ret + da2; } } }; 题目地址:https://leetcode-cn.com/problems/number-of-days-between-two-dates/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2020%2F02%2F17%2Fleetcode%205343.%20%E5%A4%9A%E6%AC%A1%E6%B1%82%E5%92%8C%E6%9E%84%E9%80%A0%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 target 。一开始，你有一个数组 A ，它的所有元素均为 1 ，你可以执行以下操作： 令 x 为你数组里所有元素的和 选择满足 0 &lt;= i &lt; target.size 的任意下标 i ，并让 A 数组里下标为 i 处的值为 x 。 你可以重复该过程任意次 如果能从 A 开始构造出目标数组 target ，请你返回 True ，否则返回 False 。 示例：示例 1： 输入：target = [9,3,5] 输出：true 解释：从 [1, 1, 1] 开始 [1, 1, 1], 和为 3 ，选择下标 1 [1, 3, 1], 和为 5， 选择下标 2 [1, 3, 5], 和为 9， 选择下标 0 [9, 3, 5] 完成 示例 2： 输入：target = [1,1,1,2] 输出：false 解释：不可能从 [1,1,1,1] 出发构造目标数组。 示例 3： 输入：target = [8,5] 输出：true 提示： N == target.length 1 &lt;= target.length &lt;= 5 * 10^4 1 &lt;= target[i] &lt;= 10^9 分析：如果正着思考很难，但是反着想，数组中最大的数就是累加后的值，反着一步步拆分即可。 代码：class Solution { public: bool dg(priority_queue&lt;int&gt; p, int tsum, int tsize){ if(tsum == tsize){ return true; } int t = p.top(); p.pop(); int t1 = t - (tsum - t); if(t1 &lt; 1){ return false; } p.push(t1); tsum = tsum - t + t1; return dg(p, tsum, tsize); } bool isPossible(vector&lt;int&gt;&amp; target) { priority_queue&lt;int&gt; p; int tsize = target.size(); long tsum = 0; for(int i = 0; i &lt; tsize; i++){ p.push(target[i]); tsum += target[i]; if(tsum &gt; INT_MAX) return false; } return dg(p, tsum, tsize); } }; 题目地址:https://leetcode-cn.com/problems/construct-target-array-with-multiple-sums/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1353. 最多可以参加的会议数目]]></title>
    <url>%2F2020%2F02%2F17%2Fleetcode%201353.%20%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。 你可以在满足 startDayi &lt;= d &lt;= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。 请你返回你可以参加的 最大 会议数目。 示例：示例 1： 输入：events = [[1,2],[2,3],[3,4]] 输出：3 解释：你可以参加所有的三个会议。 安排会议的一种方案如上图。 第 1 天参加第一个会议。 第 2 天参加第二个会议。 第 3 天参加第三个会议。 示例 2： 输入：events= [[1,2],[2,3],[3,4],[1,2]] 输出：4 示例 3： 输入：events = [[1,4],[4,4],[2,2],[3,4],[1,1]] 输出：4 示例 4： 输入：events = [[1,100000]] 输出：1 示例 5： 输入：events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]] 输出：7 提示： 1 &lt;= events.length &lt;= 10^5 events[i].length == 2 1 &lt;= events[i][0] &lt;= events[i][1] &lt;= 10^5 分析：可以使用优先队列priority_queue（做的时候没想到优先队列就用了vector加sort）加贪心的方法 先将events按照开始时间排序 按天进行遍历，如果有当天开始的会议，将会议的结束时间添加进优先队列（按结束时间从小到大、排），每天可以pop一个会议，如果过了结束时间，就将超时的会议pop 代码：class Solution { public: static bool bj(vector&lt;int&gt; a, vector&lt;int&gt; b){ return a[0] &lt; b[0]; } static bool bj1(int a, int b){ return a &gt; b; } int maxEvents(vector&lt;vector&lt;int&gt;&gt;&amp; events) { sort(events.begin(), events.end(), bj); vector&lt;int&gt; v; int j = 0; int ret = 0; for(int i = 1; i &lt;= 100000; i++){ while(events.size() &gt; j &amp;&amp; events[j][0] == i){ v.push_back(events[j][1]); j++; } sort(v.begin(), v.end(), bj1); if(v.size() &gt; 0){ ret++; v.pop_back(); } for(int k = v.size()-1; k &gt;= 0; k--){ if(v[k] &lt;= i){ v.pop_back(); } else{ break; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5341. 最后 K 个数的乘积]]></title>
    <url>%2F2020%2F02%2F17%2Fleetcode%205341.%20%E6%9C%80%E5%90%8E%20K%20%E4%B8%AA%E6%95%B0%E7%9A%84%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目：请你实现一个「数字乘积类」ProductOfNumbers，要求支持下述两种方法： add(int num) 将数字 num 添加到当前数字列表的最后面。 getProduct(int k) 返回当前数字列表中，最后 k 个数字的乘积。你可以假设当前列表中始终 至少 包含 k 个数字。题目数据保证：任何时候，任一连续数字序列的乘积都在 32-bit 整数范围内，不会溢出。 示例：输入： [&quot;ProductOfNumbers&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;add&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;getProduct&quot;,&quot;add&quot;,&quot;getProduct&quot;] [[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]] 输出： [null,null,null,null,null,null,20,40,0,null,32] 解释： ProductOfNumbers productOfNumbers = new ProductOfNumbers(); productOfNumbers.add(3); // [3] productOfNumbers.add(0); // [3,0] productOfNumbers.add(2); // [3,0,2] productOfNumbers.add(5); // [3,0,2,5] productOfNumbers.add(4); // [3,0,2,5,4] productOfNumbers.getProduct(2); // 返回 20 。最后 2 个数字的乘积是 5 * 4 = 20 productOfNumbers.getProduct(3); // 返回 40 。最后 3 个数字的乘积是 2 * 5 * 4 = 40 productOfNumbers.getProduct(4); // 返回 0 。最后 4 个数字的乘积是 0 * 2 * 5 * 4 = 0 productOfNumbers.add(8); // [3,0,2,5,4,8] productOfNumbers.getProduct(2); // 返回 32 。最后 2 个数字的乘积是 4 * 8 = 32 提示： add 和 getProduct 两种操作加起来总共不会超过 40000 次。 0 &lt;= num &lt;= 100 1 &lt;= k &lt;= 40000 分析：正常的解决方式是使用前缀和，只要当遇到0时将数据重置为1，然后记录一下0的位置，但凡需要返回0之前的数据时，直接返回0 这里的方法为，在add是记录数据，然后在getProduct时计算，这样遇到连续的getProduct就不用重复计算了 代码：class ProductOfNumbers { vector&lt;int&gt; vi; vector&lt;int&gt; vi1; bool b; public: ProductOfNumbers() { b = false; } void add(int num) { vi.push_back(num); vi1.push_back(0); b = false; } int getProduct(int k) { if(b == false){ vi1[vi.size()-1] = vi[vi.size()-1]; for(int i = vi.size()-2; i &gt;= 0; i--){ vi1[i] = vi[i] * vi1[i+1]; } } b = true; return vi1[vi.size()-k]; } }; /** * Your ProductOfNumbers object will be instantiated and called as such: * ProductOfNumbers* obj = new ProductOfNumbers(); * obj-&gt;add(num); * int param_2 = obj-&gt;getProduct(k); */ 题目地址:https://leetcode-cn.com/problems/product-of-the-last-k-numbers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5340. 统计有序矩阵中的负数]]></title>
    <url>%2F2020%2F02%2F17%2Fleetcode%205340.%20%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个 m * n 的矩阵 grid，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 请你统计并返回 grid 中 负数 的数目。 示例：示例 1： 输入：grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]] 输出：8 解释：矩阵中共有 8 个负数。 示例 2： 输入：grid = [[3,2],[1,0]] 输出：0 示例 3： 输入：grid = [[1,-1],[-1,-1]] 输出：3 示例 4： 输入：grid = [[-1]] 输出：1 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 100 -100 &lt;= grid[i][j] &lt;= 100 分析：直接全部遍历，统计负数数量 代码：class Solution { public: int countNegatives(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int ret = 0; for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ if(grid[i][j] &lt; 0){ ret++; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1349. 参加考试的最大学生数]]></title>
    <url>%2F2020%2F02%2F10%2Fleetcode%201349.%20%E5%8F%82%E5%8A%A0%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个 m * n 的矩阵 seats 表示教室中的座位分布。如果座位是坏的（不可用），就用 ‘#’ 表示；否则，用 ‘.’ 表示。 学生可以看到左侧、右侧、左上、右上这四个方向上紧邻他的学生的答卷，但是看不到直接坐在他前面或者后面的学生的答卷。请你计算并返回该考场可以容纳的一起参加考试且无法作弊的最大学生人数。 学生必须坐在状况良好的座位上。 示例：示例 1： 输入：seats = [[&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;]] 输出：4 解释：教师可以让 4 个学生坐在可用的座位上，这样他们就无法在考试中作弊。 示例 2： 输入：seats = [[&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;], [&quot;#&quot;,&quot;#&quot;], [&quot;.&quot;,&quot;#&quot;]] 输出：3 解释：让所有学生坐在可用的座位上。 示例 3： 输入：seats = [[&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;]] 输出：10 解释：让学生坐在第 1、3 和 5 列的可用座位上。 提示： seats 只包含字符 ‘.’ 和’#’ m == seats.length n == seats[i].length 1 &lt;= m &lt;= 8 1 &lt;= n &lt;= 8 分析：使用状态压缩dp 因为n只有8，所以一行最多也就2的8次方种可能，可以用一个8位的数来表示状态 dp[i][j] = max(dp[i][j], dp[i-1][k] + rs[j]) dp[i][j]表示第i行，状态为j的最多可坐学生数量，k为2^8中的其中一种状态 代码：class Solution { public: int rs(int a){ // 统计一行的人数 int i = 0; while(a != 0){ if(a % 2 == 1){ i++; } a/=2; } return i; } bool zw(int a, int b){ // 判断a状态下学生是否坐在正确的座位上 if((a | b) == b){ return true; } return false; } bool zb1(int a){ // 判断一行内学生是否有作弊可能 bool b = false; while(a != 0){ if(a % 2 == 1){ if(b) return false; b = true; } else{ b = false; } a/=2; } return true; } bool zb(int a, int b){ // 根据上一行和当前行判断当前行中学生是否有作弊可能 if(b == -1){ if(!zb1(a)){ return false; } } else{ if(!zb1(a)){ return false; } if(!zb1(b)){ return false; } if(((a&lt;&lt;1) &amp; b) &gt; 0){ return false; } if(((a&gt;&gt;1) &amp; b) &gt; 0){ return false; } } return true; } int maxStudents(vector&lt;vector&lt;char&gt;&gt;&amp; seats) { int m = seats.size(); int n = seats[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(1&lt;&lt;n, 0)); vector&lt;int&gt; vi(m, 0); for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ vi[i] = (vi[i] &lt;&lt; 1); if(seats[i][j] == &apos;.&apos;){ vi[i] += 1; } } } for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; (1&lt;&lt;n); j++){ for(int k = 0; k &lt; (1&lt;&lt;n); k++){ if(i == 0){ if(zw(j, vi[i]) &amp;&amp; zb(j, -1)){ dp[i][j] = rs(j); } } else if(zw(j, vi[i]) &amp;&amp; zw(k, vi[i-1]) &amp;&amp; zb(j, k)){ dp[i][j] = max(dp[i][j], dp[i-1][k] + rs(j)); } } } } int ret = 0; for(int i = 0; i &lt; (1&lt;&lt;n); i++){ ret = ret &gt; dp[m-1][i] ? ret : dp[m-1][i]; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-students-taking-exam/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1348. 推文计数]]></title>
    <url>%2F2020%2F02%2F10%2Fleetcode%201348.%20%E6%8E%A8%E6%96%87%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：请你实现一个能够支持以下两种方法的推文计数类 TweetCounts： recordTweet(string tweetName, int time) 记录推文发布情况：用户 tweetName 在 time（以 秒 为单位）时刻发布了一条推文。 getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) 返回从开始时间 startTime（以 秒 为单位）到结束时间 endTime（以 秒 为单位）内，每 分 minute，时 hour 或者 日 day （取决于 freq）内指定用户 tweetName 发布的推文总数。 freq 的值始终为 分 minute，时 hour 或者 日 day 之一，表示获取指定用户 tweetName 发布推文次数的时间间隔。 第一个时间间隔始终从 startTime 开始，因此时间间隔为 [startTime, startTime + delta*1&gt;, [startTime + delta*1, startTime + delta*2&gt;, [startTime + delta*2, startTime + delta*3&gt;, ... , [startTime + delta*i, min(startTime + delta*(i+1), endTime + 1)&gt;，其中 i 和 delta（取决于 freq）都是非负整数。 示例：输入： [&quot;TweetCounts&quot;,&quot;recordTweet&quot;,&quot;recordTweet&quot;,&quot;recordTweet&quot;,&quot;getTweetCountsPerFrequency&quot;,&quot;getTweetCountsPerFrequency&quot;,&quot;recordTweet&quot;,&quot;getTweetCountsPerFrequency&quot;] [[],[&quot;tweet3&quot;,0],[&quot;tweet3&quot;,60],[&quot;tweet3&quot;,10],[&quot;minute&quot;,&quot;tweet3&quot;,0,59],[&quot;minute&quot;,&quot;tweet3&quot;,0,60],[&quot;tweet3&quot;,120],[&quot;hour&quot;,&quot;tweet3&quot;,0,210]] 输出： [null,null,null,null,[2],[2,1],null,[4]] 解释： TweetCounts tweetCounts = new TweetCounts(); tweetCounts.recordTweet(&quot;tweet3&quot;, 0); tweetCounts.recordTweet(&quot;tweet3&quot;, 60); tweetCounts.recordTweet(&quot;tweet3&quot;, 10); // &quot;tweet3&quot; 发布推文的时间分别是 0, 10 和 60 。 tweetCounts.getTweetCountsPerFrequency(&quot;minute&quot;, &quot;tweet3&quot;, 0, 59); // 返回 [2]。统计频率是每分钟（60 秒），因此只有一个有效时间间隔 [0,60&gt; - &gt; 2 条推文。 tweetCounts.getTweetCountsPerFrequency(&quot;minute&quot;, &quot;tweet3&quot;, 0, 60); // 返回 [2,1]。统计频率是每分钟（60 秒），因此有两个有效时间间隔 1) [0,60&gt; - &gt; 2 条推文，和 2) [60,61&gt; - &gt; 1 条推文。 tweetCounts.recordTweet(&quot;tweet3&quot;, 120); // &quot;tweet3&quot; 发布推文的时间分别是 0, 10, 60 和 120 。 tweetCounts.getTweetCountsPerFrequency(&quot;hour&quot;, &quot;tweet3&quot;, 0, 210); // 返回 [4]。统计频率是每小时（3600 秒），因此只有一个有效时间间隔 [0,211&gt; - &gt; 4 条推文。 提示： 同时考虑 recordTweet 和 getTweetCountsPerFrequency，最多有 10000 次操作。 0 &lt;= time, startTime, endTime &lt;= 10^9 0 &lt;= endTime - startTime &lt;= 10^4 分析：使用map和vector记录每个用户发布推文的时间。 使用双指针，来判断每段时间间隔中用户的发布推文次数 代码：class TweetCounts { public: map&lt;string, vector&lt;int&gt;&gt; m; // map&lt;string, int&gt; ms; TweetCounts() { // ms[&quot;minute&quot;] = 60; // ms[&quot;hour&quot;] = 3600; // ms[&quot;day&quot;] = 86400; } void recordTweet(string tweetName, int time) { m[tweetName].push_back(time); } vector&lt;int&gt; getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) { vector&lt;int&gt; vi; int d; if(freq[0] == &apos;m&apos;) d = 60; if(freq[0] == &apos;h&apos;) d = 3600; if(freq[0] == &apos;d&apos;) d = 24 * 3600; if(m[tweetName].size() == 0){ return vi; } sort(m[tweetName].begin(), m[tweetName].end()); int q = 0; vi.push_back(0); bool b = false; for(int i = startTime; i &lt;= endTime; i += d){ while(q &lt; m[tweetName].size() &amp;&amp; m[tweetName][q] &lt; i){ q++; } while(q &lt; m[tweetName].size() &amp;&amp; m[tweetName][q] &lt;= (i+d-1 &gt; endTime ? endTime : i+d-1)){ vi[vi.size()-1]++; b = true; q++; } vi.push_back(0); } vi.pop_back(); return vi; } }; /** * Your TweetCounts object will be instantiated and called as such: * TweetCounts* obj = new TweetCounts(); * obj-&gt;recordTweet(tweetName,time); * vector&lt;int&gt; param_2 = obj-&gt;getTweetCountsPerFrequency(freq,tweetName,startTime,endTime); */ 题目地址:https://leetcode-cn.com/problems/tweet-counts-per-frequency/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1347. 制造字母异位词的最小步骤数]]></title>
    <url>%2F2020%2F02%2F10%2Fleetcode%201347.%20%E5%88%B6%E9%80%A0%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AD%A5%E9%AA%A4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你两个长度相等的字符串 s 和 t。每一个步骤中，你可以选择将 t 中的 任一字符 替换为 另一个字符。 返回使 t 成为 s 的字母异位词的最小步骤数。 字母异位词 指字母相同，但排列不同的字符串。 示例：示例 1： 输出：s = &quot;bab&quot;, t = &quot;aba&quot; 输出：1 提示：用 &apos;b&apos; 替换 t 中的第一个 &apos;a&apos;，t = &quot;bba&quot; 是 s 的一个字母异位词。 示例 2： 输出：s = &quot;leetcode&quot;, t = &quot;practice&quot; 输出：5 提示：用合适的字符替换 t 中的 &apos;p&apos;, &apos;r&apos;, &apos;a&apos;, &apos;i&apos; 和 &apos;c&apos;，使 t 变成 s 的字母异位词。 示例 3： 输出：s = &quot;anagram&quot;, t = &quot;mangaar&quot; 输出：0 提示：&quot;anagram&quot; 和 &quot;mangaar&quot; 本身就是一组字母异位词。 示例 4： 输出：s = &quot;xxyyzz&quot;, t = &quot;xxyyzz&quot; 输出：0 示例 5： 输出：s = &quot;friend&quot;, t = &quot;family&quot; 输出：4 提示： 1 &lt;= s.length &lt;= 50000 s.length == t.length s 和 t 只包含小写英文字母 分析：统计s和t，26个字母出现的次数，统计s字母出现次数大于t的次数即可 代码：class Solution { public: int minSteps(string s, string t) { int s1[26] = {0}; int t1[26] = {0}; int ret = 0; for(int i = 0; i &lt; s.size(); i++){ s1[s[i] - &apos;a&apos;]++; t1[t[i] - &apos;a&apos;]++; } for(int i = 0; i &lt; 26; i++){ ret += s1[i] - t1[i] &gt; 0 ? s1[i] - t1[i] : 0; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1346. 检查整数及其两倍数是否存在]]></title>
    <url>%2F2020%2F02%2F10%2Fleetcode%201346.%20%E6%A3%80%E6%9F%A5%E6%95%B4%E6%95%B0%E5%8F%8A%E5%85%B6%E4%B8%A4%E5%80%8D%E6%95%B0%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 arr，请你检查是否存在两个整数 N 和 M，满足 N 是 M 的两倍（即，N = 2 * M）。 更正式地，检查是否存在两个下标 i 和 j 满足： i != j 0 &lt;= i, j &lt; arr.length arr[i] == 2 * arr[j] 示例：示例 1： 输入：arr = [10,2,5,3] 输出：true 解释：N = 10 是 M = 5 的两倍，即 10 = 2 * 5 。 示例 2： 输入：arr = [7,1,14,11] 输出：true 解释：N = 14 是 M = 7 的两倍，即 14 = 2 * 7 。 示例 3： 输入：arr = [3,1,7,11] 输出：false 解释：在该情况下不存在 N 和 M 满足 N = 2 * M 。 提示： 2 &lt;= arr.length &lt;= 500 -10^3 &lt;= arr[i] &lt;= 10^3 分析：定义一个map，用来存储出现过的数字，对每个数字乘2，去map中寻找，有就返回true。注意0比较特殊，需要出现两次0才可以返回ture 代码：class Solution { public: bool checkIfExist(vector&lt;int&gt;&amp; arr) { map&lt;int, int&gt; m; for(int i = 0; i &lt; arr.size(); i++){ if(arr[i] == 0){ if(m[arr[i]] &gt;= 1){ m[arr[i]] = 2; } else{ m[arr[i]] = 1; } } else{ m[arr[i]] = 2; } } for(int i = 0; i &lt; arr.size(); i++){ if(m[arr[i]*2] == 2){ return true; } } return false; } }; 题目地址:https://leetcode-cn.com/problems/check-if-n-and-its-double-exist/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1344. 跳跃游戏 V]]></title>
    <url>%2F2020%2F02%2F03%2Fleetcode%201344.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20V%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 arr 和一个整数 d 。每一步你可以从下标 i 跳到： i + x ，其中 i + x &lt; arr.length 且 0 &lt; x &lt;= d 。 i - x ，其中 i - x &gt;= 0 且 0 &lt; x &lt;= d 。 除此以外，你从下标 i 跳到下标 j 需要满足：arr[i] &gt; arr[j] 且 arr[i] &gt; arr[k] ，其中下标 k 是所有 i 到 j 之间的数字（更正式的，min(i, j) &lt; k &lt; max(i, j)）。 你可以选择数组的任意下标开始跳跃。请你返回你 最多 可以访问多少个下标。 请注意，任何时刻你都不能跳到数组的外面。 示例：示例 1： 输入：arr = [6,4,14,6,8,13,9,7,10,6,12], d = 2 输出：4 解释：你可以从下标 10 出发，然后如上图依次经过 10 --&gt; 8 --&gt; 6 --&gt; 7 。 注意，如果你从下标 6 开始，你只能跳到下标 7 处。你不能跳到下标 5 处因为 13 &gt; 9 。你也不能跳到下标 4 处，因为下标 5 在下标 4 和 6 之间且 13 &gt; 9 。 类似的，你不能从下标 3 处跳到下标 2 或者下标 1 处。 示例 2： 输入：arr = [3,3,3,3,3], d = 3 输出：1 解释：你可以从任意下标处开始且你永远无法跳到任何其他坐标。 示例 3： 输入：arr = [7,6,5,4,3,2,1], d = 1 输出：7 解释：从下标 0 处开始，你可以按照数值从大到小，访问所有的下标。 示例 4： 输入：arr = [7,1,7,1,7,1], d = 2 输出：2 示例 5： 输入：arr = [66], d = 1 输出：1 提示： 1 &lt;= arr.length &lt;= 1000 1 &lt;= arr[i] &lt;= 10^5 1 &lt;= d &lt;= arr.length 分析：使用dfs，同时使用一个map进行记录，防止重复计算 代码：class Solution { map&lt;int, int&gt; m; // 用来存储已经计算过的起点的最大跳跃值 public: int dg(vector&lt;int&gt;&amp; arr, int d, int z){ if(m[z] != 0) // 如果已经计算过的直接返回，不重复计算 return m[z]; int a = 1; for(int i = 1; i &lt;= d; i++){ // 对范围内所有的位置进行跳跃 if(z - i &gt;= 0 &amp;&amp; arr[z - i] &lt; arr[z]){ // 判断是否可以跳跃 int b = dg(arr, d, z-i); a = a &gt; b+1 ? a : b+1; // 记录最大跳跃过的次数 } else{ break; } } for(int i = 1; i &lt;= d; i++){ if(z + i &lt; arr.size() &amp;&amp; arr[z + i] &lt; arr[z]){ int b = dg(arr, d, z+i); a = a &gt; b+1 ? a : b+1; } else{ break; } } m[z] = a; // 防止重复计算 return m[z]; } int maxJumps(vector&lt;int&gt;&amp; arr, int d) { int a = 0; for(int i = 0; i &lt; arr.size(); i++){ // 对每个下标为起点进行运算 int b = dg(arr, d, i); a = a &gt; b ? a : b; } return a; } }; 题目地址:https://leetcode-cn.com/problems/jump-game-v/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1343. 分裂二叉树的最大乘积]]></title>
    <url>%2F2020%2F02%2F03%2Fleetcode%201343.%20%E5%88%86%E8%A3%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%2F</url>
    <content type="text"><![CDATA[题目：给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。 由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。 示例：示例 1： 输入：root = [1,2,3,4,5,6] 输出：110 解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10） 示例 2： 输入：root = [1,null,2,3,4,null,null,5,6] 输出：90 解释：移除红色的边，得到 2 棵子树，和分别是 15 和 6 。它们的乘积为 90 （15*6） 示例 3： 输入：root = [2,3,9,10,7,8,6,5,4,11,1] 输出：1025 示例 4： 输入：root = [1,1] 输出：1 提示： 每棵树最多有 50000 个节点，且至少有 2 个节点。 每个节点的值在 [1, 10000] 之间。 分析：使用dfs遍历全树，获得所有节点之和 再次遍历，对左子树或右子树进行分割，找到子树*（所有节点之和-子树）最大的值即可 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { int a; int b1; int b2; public: int jdz(int i){ return i &lt; 0 ? i*-1 : i; } int dfs(TreeNode* root){ if(root == NULL) return 0; int l = dfs(root-&gt;left); int r = dfs(root-&gt;right); if(jdz(a - l - l) &lt; jdz(b1 - b2)){ b1 = a-l; b2 = l; } if(jdz(a - r - r) &lt; jdz(b1 - b2)){ b1 = a-r; b2 = r; } return l + r + root-&gt;val; } int maxProduct(TreeNode* root) { a = dfs(root); b1 = 0; b2 = 500000000; dfs(root); long l = long(b1)*b2; cout &lt;&lt; b1 &lt;&lt; &quot; &quot; &lt;&lt; b2; l %= 1000000007; return int(l); } }; 题目地址:https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1342. 数组大小减半]]></title>
    <url>%2F2020%2F02%2F03%2Fleetcode%201342.%20%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%8D%8A%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 arr。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。 返回 至少 能删除数组中的一半整数的整数集合的最小大小。 示例：示例 1： 输入：arr = [3,3,3,3,5,5,5,2,2,7] 输出：2 解释：选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。 大小为 2 的可行集合有 {3,5},{3,2},{5,2}。 选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。 示例 2： 输入：arr = [7,7,7,7,7,7] 输出：1 解释：我们只能选择集合 {7}，结果数组为空。 示例 3： 输入：arr = [1,9] 输出：1 示例 4： 输入：arr = [1000,1000,3,7] 输出：1 示例 5： 输入：arr = [1,2,3,4,5,6,7,8,9,10] 输出：5 提示： 1 &lt;= arr.length &lt;= 10^5 arr.length 为偶数 1 &lt;= arr[i] &lt;= 10^5 分析：使用map存储整数和整数的出现次数，将map中整数的出现次数导入vector中，对vector按从大到小排序。依次删除直至删除值数组的一半大小 代码：bool bj(int i, int j){ return i &gt; j; } class Solution { public: int minSetSize(vector&lt;int&gt;&amp; arr) { map&lt;int, int&gt; mi; vector&lt;int&gt; vi; int a = arr.size(); for(int i = 0; i &lt; arr.size(); i++){ mi[arr[i]]++; } for(auto a = mi.begin(); a != mi.end(); a++){ vi.push_back(a-&gt;second); } sort(vi.begin(), vi.end(), bj); for(int i = 0; i &lt; vi.size(); i++){ a -= vi[i]; if(a &lt;= arr.size()/2) return i+1; } return 0; } }; 题目地址:https://leetcode-cn.com/problems/reduce-array-size-to-the-half/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1341. 方阵中战斗力最弱的 K 行]]></title>
    <url>%2F2020%2F02%2F03%2Fleetcode%201341.%20%E6%96%B9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84%20K%20%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个大小为 m * n 的方阵 mat，方阵由若干军人和平民组成，分别用 0 和 1 表示。 请你返回方阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。 示例：示例 1： 输入：mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3 输出：[2,0,3] 解释： 每行中的军人数目： 行 0 -&gt; 2 行 1 -&gt; 4 行 2 -&gt; 1 行 3 -&gt; 2 行 4 -&gt; 5 从最弱到最强对这些行排序后得到 [2,0,3,1,4] 示例 2： 输入：mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2 输出：[0,2] 解释： 每行中的军人数目： 行 0 -&gt; 1 行 1 -&gt; 4 行 2 -&gt; 1 行 3 -&gt; 1 从最弱到最强对这些行排序后得到 [0,2,3,1] 提示： m == mat.length n == mat[i].length 2 &lt;= n, m &lt;= 100 1 &lt;= k &lt;= m matrix[i][j] 不是 0 就是 1 分析：两种办法 第一种，使用二维数组记录行号和每行军人数量，使用sort排序 第二种，按列判断，按遇到0，或者最后一列也为1就输出当前行号，直到输出个数达到K 代码：class Solution { public: vector&lt;int&gt; kWeakestRows(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) { vector&lt;int&gt; ret; for(int j = 0; j &lt; mat[0].size(); j++){ for(int i = 0; i &lt; mat.size(); i++){ if(mat[i][j] == 0 &amp;&amp; (j == 0 || mat[i][j-1] != 0)){ ret.push_back(i); if(ret.size() == k) return ret; } } } for(int i = 0; i &lt; mat.size(); i++){ if(mat[i][mat[0].size()-1] == 1){ ret.push_back(i); if(ret.size() == k) return ret; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1335. 工作计划的最低难度]]></title>
    <url>%2F2020%2F01%2F31%2Fleetcode%201335.%20%E5%B7%A5%E4%BD%9C%E8%AE%A1%E5%88%92%E7%9A%84%E6%9C%80%E4%BD%8E%E9%9A%BE%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目：你需要制定一份 d 天的工作计划表。工作之间存在依赖，要想执行第 i 项工作，你必须完成全部 j 项工作（ 0 &lt;= j &lt; i）。 你每天 至少 需要完成一项任务。工作计划的总难度是这 d 天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。 给你一个整数数组 jobDifficulty 和一个整数 d，分别代表工作难度和需要计划的天数。第 i 项工作的难度是 jobDifficulty[i]。 返回整个工作计划的 最小难度 。如果无法制定工作计划，则返回 -1 。 示例：示例 1： 输入：jobDifficulty = [6,5,4,3,2,1], d = 2 输出：7 解释：第一天，您可以完成前 5 项工作，总难度 = 6. 第二天，您可以完成最后一项工作，总难度 = 1. 计划表的难度 = 6 + 1 = 7 示例 2： 输入：jobDifficulty = [9,9,9], d = 4 输出：-1 解释：就算你每天完成一项工作，仍然有一天是空闲的，你无法制定一份能够满足既定工作时间的计划表。 示例 3： 输入：jobDifficulty = [1,1,1], d = 3 输出：3 解释：工作计划为每天一项工作，总难度为 3 。 示例 4： 输入：jobDifficulty = [7,1,7,1,7,1], d = 3 输出：15 示例 5： 输入：jobDifficulty = [11,111,22,222,33,333,44,444], d = 6 输出：843 提示： 1 &lt;= jobDifficulty.length &lt;= 300 0 &lt;= jobDifficulty[i] &lt;= 1000 1 &lt;= d &lt;= 10 分析：动态规划 dp[j][i] 表示第i天完成j项任务所需最小难度 maxi[i][j] 表示从i到j项任务中的最大难度 dp[j][i] = min(dp[k][i-1] + maxi[k+1][j], dp[j][i]) k从i-1遍历到j 代码：class Solution { public: int minDifficulty(vector&lt;int&gt;&amp; jobDifficulty, int d) { if(jobDifficulty.size() &lt; d) return -1; vector&lt;vector&lt;int&gt;&gt; dp(jobDifficulty.size(), vector&lt;int&gt;(d, INT_MAX)); vector&lt;vector&lt;int&gt;&gt; maxi(jobDifficulty.size(), vector&lt;int&gt;(jobDifficulty.size(), 0)); for(int i = 0; i &lt; jobDifficulty.size(); i++){ maxi[i][i] = jobDifficulty[i]; } for(int i = 0; i &lt; jobDifficulty.size(); i++){ for(int j = i+1; j &lt; jobDifficulty.size(); j++){ maxi[i][j] = max(maxi[i][j-1], jobDifficulty[j]); } } for(int i = 0; i &lt; jobDifficulty.size(); i++){ dp[i][0] = maxi[0][i]; } for(int i = 1; i &lt; d; i++){ for(int j = i; j &lt; jobDifficulty.size(); j++){ for(int k = i-1; k &lt; j; k++){ if(dp[k][i-1] != INT_MAX) dp[j][i] = min(dp[k][i-1] + maxi[k+1][j], dp[j][i]); } } } return dp[jobDifficulty.size()-1][d-1]; } }; 题目地址:https://leetcode-cn.com/problems/minimum-difficulty-of-a-job-schedule/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1334. 阈值距离内邻居最少的城市]]></title>
    <url>%2F2020%2F01%2F31%2Fleetcode%201334.%20%E9%98%88%E5%80%BC%E8%B7%9D%E7%A6%BB%E5%86%85%E9%82%BB%E5%B1%85%E6%9C%80%E5%B0%91%E7%9A%84%E5%9F%8E%E5%B8%82%2F</url>
    <content type="text"><![CDATA[题目：有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。 返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。 注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。 示例：示例 1： 输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4 输出：3 解释：城市分布图如上。 每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是： 城市 0 -&gt; [城市 1, 城市 2] 城市 1 -&gt; [城市 0, 城市 2, 城市 3] 城市 2 -&gt; [城市 0, 城市 1, 城市 3] 城市 3 -&gt; [城市 1, 城市 2] 城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。 示例 2： 输入：n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2 输出：0 解释：城市分布图如上。 每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是： 城市 0 -&gt; [城市 1] 城市 1 -&gt; [城市 0, 城市 4] 城市 2 -&gt; [城市 3, 城市 4] 城市 3 -&gt; [城市 2, 城市 4] 城市 4 -&gt; [城市 1, 城市 2, 城市 3] 城市 0 在阈值距离 4 以内只有 1 个邻居城市。 提示： 2 &lt;= n &lt;= 100 1 &lt;= edges.length &lt;= n * (n - 1) / 2 edges[i].length == 3 0 &lt;= fromi &lt; toi &lt; n 1 &lt;= weighti, distanceThreshold &lt;= 10^4 所有 (fromi, toi) 都是不同的。 分析：使用弗洛伊德算法（动态规划）计算出每两个城市之间的最近距离，然后再遍历所有城市路径距离最大为distanceThreshold 的城市，找出其中城市数目最少的城市 代码：class Solution { public: int findTheCity(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int distanceThreshold) { vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, INT_MAX)); for(int i = 0; i &lt; n; i++){ dp[i][i] = 0; } for(int i = 0; i &lt; edges.size(); i++){ dp[edges[i][0]][edges[i][1]] = edges[i][2]; dp[edges[i][1]][edges[i][0]] = edges[i][2]; } for(int k = 0; k &lt; n; k++){ for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; n; j++){ if(dp[i][k] != INT_MAX &amp;&amp; dp[k][j] != INT_MAX){ dp[i][j] = min(dp[i][k] + dp[k][j], dp[i][j]); dp[j][i] = dp[i][j]; } } } } int m = INT_MAX; int ret; for(int i = 0; i &lt; n; i++){ int s = -1; for(int j = 0; j &lt; n; j++){ if(dp[i][j] &lt;= distanceThreshold) s++; } if(m &gt;= s){ m = s; ret = i; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1332. 删除回文子序列]]></title>
    <url>%2F2020%2F01%2F31%2Fleetcode%201332.%20%E5%88%A0%E9%99%A4%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s，它仅由字母 ‘a’ 和 ‘b’ 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。 返回删除给定字符串中所有字符（字符串为空）的最小删除次数。 「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。 「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。 示例：示例 1： 输入：s = &quot;ababa&quot; 输出：1 解释：字符串本身就是回文序列，只需要删除一次。 示例 2： 输入：s = &quot;abb&quot; 输出：2 解释：&quot;abb&quot; -&gt; &quot;bb&quot; -&gt; &quot;&quot;. 先删除回文子序列 &quot;a&quot;，然后再删除 &quot;bb&quot;。 示例 3： 输入：s = &quot;baabb&quot; 输出：2 解释：&quot;baabb&quot; -&gt; &quot;b&quot; -&gt; &quot;&quot;. 先删除回文子序列 &quot;baab&quot;，然后再删除 &quot;b&quot;。 示例 4： 输入：s = &quot;&quot; 输出：0 提示： 0 &lt;= s.length &lt;= 1000 s 仅包含字母 ‘a’ 和 ‘b’ 分析：注意是子序列，不是子字符串。 只有三种可能 字符串为空，返回0 字符串本身就为回文序列，返回1 剩下的所有可能都返回2，因为字符串只有a和b，不管怎么样，两次都够删除了 代码：class Solution { public: int removePalindromeSub(string s) { if(s.size() == 0) return 0; for(int i = 0, j = s.size()-1; i &lt; j; i++, j--){ if(s[i] != s[j]) return 2; } return 1; } }; 题目地址:https://leetcode-cn.com/problems/remove-palindromic-subsequences/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1333. 餐厅过滤器]]></title>
    <url>%2F2020%2F01%2F31%2Fleetcode%201333.%20%E9%A4%90%E5%8E%85%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目：给你一个餐馆信息数组 restaurants，其中 restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]。你必须使用以下三个过滤器来过滤这些餐馆信息。 其中素食者友好过滤器 veganFriendly 的值可以为 true 或者 false，如果为 true 就意味着你应该只包括 veganFriendlyi 为 true 的餐馆，为 false 则意味着可以包括任何餐馆。此外，我们还有最大价格 maxPrice 和最大距离 maxDistance 两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。 过滤后返回餐馆的 id，按照 rating 从高到低排序。如果 rating 相同，那么按 id 从高到低排序。简单起见， veganFriendlyi 和 veganFriendly 为 true 时取值为 1，为 false 时，取值为 0 。 示例：示例 1： 输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10 输出：[3,1,5] 解释： 这些餐馆为： 餐馆 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10] 餐馆 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5] 餐馆 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4] 餐馆 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3] 餐馆 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] 在按照 veganFriendly = 1, maxPrice = 50 和 maxDistance = 10 进行过滤后，我们得到了餐馆 3, 餐馆 1 和 餐馆 5（按评分从高到低排序）。 示例 2： 输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10 输出：[4,3,2,1,5] 解释：餐馆与示例 1 相同，但在 veganFriendly = 0 的过滤条件下，应该考虑所有餐馆。 示例 3： 输入：restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3 输出：[4,5] 提示： 1 &lt;= restaurants.length &lt;= 10^4 restaurants[i].length == 5 1 &lt;= idi, ratingi, pricei, distancei &lt;= 10^5 1 &lt;= maxPrice, maxDistance &lt;= 10^5 veganFriendlyi 和 veganFriendly 的值为 0 或 1 。 所有 idi 各不相同。 分析：直接按要求过滤，然后使用sort排序即可 代码：bool bj(vector&lt;int&gt; v1, vector&lt;int&gt; v2){ if(v1[1] == v2[1]) return v1[0] &gt; v2[0]; return v1[1] &gt; v2[1]; } class Solution { public: vector&lt;int&gt; filterRestaurants(vector&lt;vector&lt;int&gt;&gt;&amp; restaurants, int veganFriendly, int maxPrice, int maxDistance) { vector&lt;vector&lt;int&gt;&gt; vvi; vector&lt;int&gt; ret; for(int i = 0; i &lt; restaurants.size(); i++){ bool b1 = false; bool b2 = false; bool b3 = false; if(veganFriendly == 1){ if(restaurants[i][2] == 1) b1 = true; } else{ b1 = true; } if(restaurants[i][3] &lt;= maxPrice) b2 = true; if(restaurants[i][4] &lt;= maxDistance) b3 = true; if(b1 &amp;&amp; b2 &amp;&amp; b3) vvi.push_back(restaurants[i]); } sort(vvi.begin(), vvi.end(), bj); for(int i = 0; i &lt; vvi.size(); i++){ ret.push_back(vvi[i][0]); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2020%2F01%2F20%2Fleetcode%201326.%20%E7%81%8C%E6%BA%89%E8%8A%B1%E5%9B%AD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B0%B4%E9%BE%99%E5%A4%B4%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。 花园里总共有 n + 1 个水龙头，分别位于 [0, 1, …, n] 。 给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i - ranges[i], i + ranges[i]] 。 请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。 示例：示例 1： 输入：n = 5, ranges = [3,4,1,1,0,0] 输出：1 解释： 点 0 处的水龙头可以灌溉区间 [-3,3] 点 1 处的水龙头可以灌溉区间 [-3,5] 点 2 处的水龙头可以灌溉区间 [1,3] 点 3 处的水龙头可以灌溉区间 [2,4] 点 4 处的水龙头可以灌溉区间 [4,4] 点 5 处的水龙头可以灌溉区间 [5,5] 只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。 示例 2： 输入：n = 3, ranges = [0,0,0,0] 输出：-1 解释：即使打开所有水龙头，你也无法灌溉整个花园。 示例 3： 输入：n = 7, ranges = [1,2,1,0,2,1,0,1] 输出：3 示例 4： 输入：n = 8, ranges = [4,0,0,0,0,0,0,0,4] 输出：2 示例 5： 输入：n = 8, ranges = [4,0,0,0,4,0,0,0,4] 输出：1 提示： 1 &lt;= n &lt;= 10^4 ranges.length == n + 1 0 &lt;= ranges[i] &lt;= 100 分析：这题和 45. 跳跃游戏II 差不多 将浇灌范围转换成跳跃距离即可 代码：class Solution { public: int minTaps(int n, vector&lt;int&gt;&amp; ranges) { vector&lt;int&gt; vi(ranges.size(), 0); for(int i = 0; i &lt; ranges.size(); i++){ // 转换的时候去掉小于0的范围 int l = i - ranges[i] &gt; 0 ? i - ranges[i] : 0; int r = i + ranges[i] - l; vi[l] = r &gt; vi[l] ? r : vi[l]; } int ret = 1; for(int i = 0; i &lt; ranges.size();){ if(i + vi[i] &gt;= n) // 灌溉范围覆盖到最结尾返回灌溉次数 return ret; int m = 0; int m1 = 0; for(int j = i+1; j &lt;= i+vi[i]; j++){ // 寻找一次灌溉范围内的最远灌溉距离 if(m &lt; vi[j]+j){ m = vi[j]+j; m1 = j; } } if(m &lt;= vi[i]+i){ // 如果一次灌溉范围内的最远距离没有超越第一个灌溉距离，即无法覆盖整个花园 return -1; } i = m1; ret++; } return -1; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-172/problems/minimum-number-of-taps-to-open-to-water-a-garden/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2020%2F01%2F20%2Fleetcode%201324.%20%E7%AB%96%E7%9B%B4%E6%89%93%E5%8D%B0%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s。请你按照单词在 s 中的出现顺序将它们全部竖直返回。单词应该以字符串列表的形式返回，必要时用空格补位，但输出尾部的空格需要删除（不允许尾随空格）。每个单词只能放在一列上，每一列中也只能有一个单词。 示例：示例 1： 输入：s = &quot;HOW ARE YOU&quot; 输出：[&quot;HAY&quot;,&quot;ORO&quot;,&quot;WEU&quot;] 解释：每个单词都应该竖直打印。 &quot;HAY&quot; &quot;ORO&quot; &quot;WEU&quot; 示例 2： 输入：s = &quot;TO BE OR NOT TO BE&quot; 输出：[&quot;TBONTB&quot;,&quot;OEROOE&quot;,&quot; T&quot;] 解释：题目允许使用空格补位，但不允许输出末尾出现空格。 &quot;TBONTB&quot; &quot;OEROOE&quot; &quot; T&quot; 示例 3： 输入：s = &quot;CONTEST IS COMING&quot; 输出：[&quot;CIC&quot;,&quot;OSO&quot;,&quot;N M&quot;,&quot;T I&quot;,&quot;E N&quot;,&quot;S G&quot;,&quot;T&quot;] 提示： 1 &lt;= s.length &lt;= 200 s 仅含大写英文字母。 题目数据保证两个单词之间只有一个空格。 分析：将字符串分割成字符串数组 将每个字符串的同一列字符保存为一个字符串，如果为空的话添加一个空格 最后去掉每个字符串最后的空格 代码：class Solution { public: vector&lt;string&gt; printVertically(string s) { vector&lt;string&gt; vs; string str = &quot;&quot;; int m = 0; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == &apos; &apos;){ m = m &gt; str.size() ? m : str.size(); vs.push_back(str); str = &quot;&quot;; } else{ str += s[i]; } } m = m &gt; str.size() ? m : str.size(); vs.push_back(str); vector&lt;string&gt; ret(m, &quot;&quot;); for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; vs.size(); j++){ if(i &gt;= vs[j].size()){ ret[i] += &apos; &apos;; continue; } else{ ret[i] += vs[j][i]; } } } cout &lt;&lt; ret.size(); for(int i = 0; i &lt; ret.size(); i++){ for(auto a = ret[i].end()-1; a != ret[i].begin()-1; a--){ if(*a != &apos; &apos;){ if(a == ret[i].end()-1) break; ret[i].erase(a+1, ret[i].end()); break; } } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-172/problems/print-words-vertically/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2020%2F01%2F20%2Fleetcode%201323.%206%20%E5%92%8C%209%20%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个仅由数字 6 和 9 组成的正整数 num。 你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。 请返回你可以得到的最大数字。 示例：示例 1： 输入：num = 9669 输出：9969 解释： 改变第一位数字可以得到 6669 。 改变第二位数字可以得到 9969 。 改变第三位数字可以得到 9699 。 改变第四位数字可以得到 9666 。 其中最大的数字是 9969 。 示例 2： 输入：num = 9996 输出：9999 解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。 示例 3： 输入：num = 9999 输出：9999 解释：无需改变就已经是最大的数字了。 提示： 1 &lt;= num &lt;= 10^4 num 每一位上的数字都是 6 或者 9 。 分析：转换成数组形式，然后找到第一个6，将其修改为9，再次转回int类型 代码：class Solution { public: int maximum69Number (int num) { vector&lt;int&gt; vi; while(num &gt; 0){ vi.push_back(num % 10); num /= 10; } for(int i = vi.size()-1; i &gt;= 0; i--){ if(vi[i] == 6){ vi[i] = 9; break; } } for(int i = vi.size()-1; i &gt;= 0; i--){ num += vi[i]; num *= 10; } num /= 10; return num; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-172/problems/maximum-69-number/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1320. 二指输入的的最小距离]]></title>
    <url>%2F2020%2F01%2F13%2Fleetcode%201320.%20%E4%BA%8C%E6%8C%87%E8%BE%93%E5%85%A5%E7%9A%84%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题目： 二指输入法定制键盘在 XY 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处，例如字母 A 位于坐标 (0,0)，字母 B 位于坐标 (0,1)，字母 P 位于坐标 (2,3) 且字母 Z 位于坐标 (4,1)。 给你一个待输入字符串 word，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。坐标 (x1,y1) 和 (x2,y2) 之间的距离是 |x1 - x2| + |y1 - y2|。 注意，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。 示例：示例 1： 输入：word = &quot;CAKE&quot; 输出：3 解释： 使用两根手指输入 &quot;CAKE&quot; 的最佳方案之一是： 手指 1 在字母 &apos;C&apos; 上 -&gt; 移动距离 = 0 手指 1 在字母 &apos;A&apos; 上 -&gt; 移动距离 = 从字母 &apos;C&apos; 到字母 &apos;A&apos; 的距离 = 2 手指 2 在字母 &apos;K&apos; 上 -&gt; 移动距离 = 0 手指 2 在字母 &apos;E&apos; 上 -&gt; 移动距离 = 从字母 &apos;K&apos; 到字母 &apos;E&apos; 的距离 = 1 总距离 = 3 示例 2： 输入：word = &quot;HAPPY&quot; 输出：6 解释： 使用两根手指输入 &quot;HAPPY&quot; 的最佳方案之一是： 手指 1 在字母 &apos;H&apos; 上 -&gt; 移动距离 = 0 手指 1 在字母 &apos;A&apos; 上 -&gt; 移动距离 = 从字母 &apos;H&apos; 到字母 &apos;A&apos; 的距离 = 2 手指 2 在字母 &apos;P&apos; 上 -&gt; 移动距离 = 0 手指 2 在字母 &apos;P&apos; 上 -&gt; 移动距离 = 从字母 &apos;P&apos; 到字母 &apos;P&apos; 的距离 = 0 手指 1 在字母 &apos;Y&apos; 上 -&gt; 移动距离 = 从字母 &apos;A&apos; 到字母 &apos;Y&apos; 的距离 = 4 总距离 = 6 示例 3： 输入：word = &quot;NEW&quot; 输出：3 示例 4： 输入：word = “YEAR” 输出：7 提示： 2 &lt;= word.length &lt;= 300 每个 word[i] 都是一个大写英文字母。 分析：动态规划dp[i][j][k], 表示当计算到第i个字母，左指在j上，右指在k上的时候使用的最小移动距离 移动左指：dp[i][w][r] = min(dp[i][w][r], dp[i-1][l][r] + move(l, w))， w表示当前需要移动到的字母，move表示移动距离，移动右指同理。 代码：class Solution { public: int move(int a, int b){ int a1 = a / 6; int a2 = a % 6; int b1 = b / 6; int b2 = b % 6; return abs(a1-b1) + abs(a2-b2); } int minimumDistance(string word) { int ret = INT_MAX; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(word.size()+1, vector&lt;vector&lt;int&gt;&gt;(26, vector&lt;int&gt;(26, INT_MAX))); for(int l = 0; l &lt; 26; l++){ for(int r = 0; r &lt; 26; r++){ dp[0][l][r] = 0; } } for(int i = 1; i &lt;= word.size(); i++){ int w = word[i-1] - &apos;A&apos;; for(int l = 0; l &lt; 26; l++){ for(int r = 0; r &lt; 26; r++){ if(dp[i-1][l][r] != INT_MAX){ dp[i][w][r] = min(dp[i][w][r], dp[i-1][l][r] + move(l, w)); dp[i][l][w] = min(dp[i][l][w], dp[i-1][l][r] + move(r, w)); } if(i == word.size()){ ret = min(ret, dp[i][w][r]); ret = min(ret, dp[i][l][w]); } } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-distance-to-type-a-word-using-two-fingers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1319. 连通网络的操作次数]]></title>
    <url>%2F2020%2F01%2F13%2Fleetcode%201319.%20%E8%BF%9E%E9%80%9A%E7%BD%91%E7%BB%9C%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。 网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。 给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。 示例：示例 1： 输入：n = 4, connections = [[0,1],[0,2],[1,2]] 输出：1 解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。 示例 2： 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]] 输出：2 示例 3： 输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]] 输出：-1 解释：线缆数量不足。 示例 4： 输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]] 输出：0 提示： 1 &lt;= n &lt;= 10^5 1 &lt;= connections.length &lt;= min(n*(n-1)/2, 10^5) connections[i].length == 2 0 &lt;= connections[i][0], connections[i][1] &lt; n connections[i][0] != connections[i][1] 没有重复的连接。 两台计算机不会通过多条线缆连接。 分析：使用并查集如果线缆数量小于电脑数量-1，就不可能全部链接 代码：class Solution { vector&lt;int&gt; vi; // 用来保存每个节点的代表节点（用来代表互相连通的电脑） public: int ys(int a){ // 用来寻找连通的电脑中的代表，顺便压缩路径 if(vi[a] == a) return a; return vi[a] = ys(vi[a]); } int makeConnected(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) { int s = connections.size(); int ret = -1; if(s+1 &lt; n){ return -1; } for(int i = 0; i &lt; n; i++){ // 初始化 vi.push_back(i); } for(int i = 0; i &lt; s; i++){ // 将互相连通的电脑的代表节点改为同一个 vi[ys(connections[i][0])] = ys(connections[i][1]); } for(int i = 0; i &lt; n; i++){ // 所有的节点中还指向自己的都为一群互相连通电脑的代表 if(vi[i] == i) ret++; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2020%2F01%2F13%2Fleetcode%201325.%20%E5%88%A0%E9%99%A4%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。 注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。 也就是说，你需要重复此过程直到不能继续删除。 示例：示例 1： 输入：root = [1,2,3,2,null,2,4], target = 2 输出：[1,null,3,null,4] 解释： 上面左边的图中，绿色节点为叶子节点，且它们的值与 target 相同（同为 2 ），它们会被删除，得到中间的图。 有一个新的节点变成了叶子节点且它的值与 target 相同，所以将再次进行删除，从而得到最右边的图。 示例 2： 输入：root = [1,3,3,3,2], target = 3 输出：[1,3,null,null,2] 示例 3： 输入：root = [1,2,null,2,null,2], target = 2 输出：[1] 解释：每一步都删除一个绿色的叶子节点（值为 2）。 示例 4： 输入：root = [1,1,1], target = 1 输出：[] 示例 5： 输入：root = [1,2,3], target = 1 输出：[1,2,3] 提示： 1 &lt;= target &lt;= 1000 每一棵树最多有 3000 个节点。 每一个节点值的范围是 [1, 1000] 。 分析：dfs，使用后序遍历，找到叶子节点，判断是否可以删除 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool dfs(TreeNode* root, int target){ if(root-&gt;left != NULL){ if(dfs(root-&gt;left, target)){ root-&gt;left = NULL; } } if(root-&gt;right != NULL){ dfs(root-&gt;right, target); if(dfs(root-&gt;right, target)){ root-&gt;right = NULL; } } if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL &amp;&amp; root-&gt;val == target){ return true; } return false; } TreeNode* removeLeafNodes(TreeNode* root, int target) { if(dfs(root, target)) return NULL; return root; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-172/problems/delete-leaves-with-a-given-value/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1318. 或运算的最小翻转次数]]></title>
    <url>%2F2020%2F01%2F13%2Fleetcode%201318.%20%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你三个正整数 a、b 和 c。 你可以对 a 和 b 的二进制表示进行位翻转操作，返回能够使按位或运算 a OR b == c 成立的最小翻转次数。 「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1 。 示例：示例 1： 输入：a = 2, b = 6, c = 5输出：3解释：翻转后 a = 1 , b = 4 , c = 5 使得 a OR b == c示例 2： 输入：a = 4, b = 2, c = 7输出：1示例 3： 输入：a = 1, b = 2, c = 3输出：0 提示： 1 &lt;= a &lt;= 10^9 1 &lt;= b &lt;= 10^9 1 &lt;= c &lt;= 10^9 分析：按位运算如果c对应位为0，那么将a和b的对应位置为0如果c对应位为1，如果a和b对应位有1，就不修改，否则修改其中一位为1 代码：class Solution { public: int minFlips(int a, int b, int c) { int ret = 0; for(int i = 0; i &lt; 31; i++){ int a1 = a % 2; int b1 = b % 2; int c1 = c % 2; a/=2; b/=2; c/=2; if(c1 == 1){ if(a1 == 0 &amp;&amp; b1 == 0) ret++; } else{ if(a1 == 1) ret++; if(b1 == 1) ret++; } } return ret; } }; // 还可以用（num &amp; 1）取出第一位，（num &gt;&gt;= 1）将数字向右移动一位，最后通过判断数字是否等于0来判断是否结束 题目地址:https://leetcode-cn.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1317. 将整数转换为两个无零整数的和]]></title>
    <url>%2F2020%2F01%2F13%2Fleetcode%201317.%20%E5%B0%86%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%A4%E4%B8%AA%E6%97%A0%E9%9B%B6%E6%95%B4%E6%95%B0%E7%9A%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：「无零整数」是十进制表示中 不含任何 0 的正整数。 给你一个整数 n，请你返回一个 由两个整数组成的列表 [A, B]，满足： A 和 B 都是无零整数 A + B = n 题目数据保证至少有一个有效的解决方案。 如果存在多个有效解决方案，你可以返回其中任意一个。 示例：示例 1： 输入：n = 2 输出：[1,1] 解释：A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0 。 示例 2： 输入：n = 11 输出：[2,9] 示例 3： 输入：n = 10000 输出：[1,9999] 示例 4： 输入：n = 69 输出：[1,68] 示例 5： 输入：n = 1010 输出：[11,999] 提示： 2 &lt;= n &lt;= 10^4 分析：枚举所有加起来等于n的数字，分别判断是否有0 代码：class Solution { public: vector&lt;int&gt; getNoZeroIntegers(int n) { for(int i = 1; i &lt; n; i++){ int j = i; bool b = true; while(j / 10 != 0){ if(j % 10 == 0){ b = false; break; } j /= 10; } if(b == true){ j = n-i; while(j / 10 != 0){ if(j % 10 == 0){ b = false; break; } j /= 10; } if(b == true){ return vector&lt;int&gt;{i, n-i}; } } } return vector&lt;int&gt;(); } }; 题目地址:https://leetcode-cn.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1312. 让字符串成为回文串的最少插入次数]]></title>
    <url>%2F2020%2F01%2F06%2Fleetcode%201312.%20%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%90%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。 请你返回让 s 成为回文串的 最少操作次数 。 「回文串」是正读和反读都相同的字符串。 示例：示例 1： 输入：s = &quot;zzazz&quot; 输出：0 解释：字符串 &quot;zzazz&quot; 已经是回文串了，所以不需要做任何插入操作。 示例 2： 输入：s = &quot;mbadm&quot; 输出：2 解释：字符串可变为 &quot;mbdadbm&quot; 或者 &quot;mdbabdm&quot; 。 示例 3： 输入：s = &quot;leetcode&quot; 输出：5 解释：插入 5 个字符后字符串变为 &quot;leetcodocteel&quot; 。 示例 4： 输入：s = &quot;g&quot; 输出：0 示例 5： 输入：s = &quot;no&quot; 输出：1 提示： 1 &lt;= s.length &lt;= 500 s 中所有字符都是小写字母。 分析：使用dp，dp[i][j], 表示从j开始长度为i的字符串形成回文串需要添加的字符数如果s[j] == s[j+i-1]（字符串最两边的字符是否相等），dp[i][j] = dp[i-2][j+1]如果不相等，dp[i][j] = min(dp[i-1][j], dp[i-1][j+1])+1; 代码：class Solution { public: int minInsertions(string s) { vector&lt;vector&lt;int&gt;&gt; dp(s.size()+1, vector&lt;int&gt;(s.size())); // dp[i][j], 表示从j开始长度为i的字符串形成回文串需要添加的字符数 for(int i = 2; i &lt;= s.size(); i++){ for(int j = 0; j+i-1 &lt; s.size(); j++){ if(s[j] == s[j+i-1]){ dp[i][j] = dp[i-2][j+1]; } else{ dp[i][j] = min(dp[i-1][j], dp[i-1][j+1])+1; } } } return dp[s.size()][0]; } }; 题目地址:https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1311. 获取你好友已观看的视频]]></title>
    <url>%2F2020%2F01%2F06%2Fleetcode%201311.%20%E8%8E%B7%E5%8F%96%E4%BD%A0%E5%A5%BD%E5%8F%8B%E5%B7%B2%E8%A7%82%E7%9C%8B%E7%9A%84%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[题目：有 n 个人，每个人都有一个 0 到 n-1 的唯一 id 。 给你数组 watchedVideos 和 friends ，其中 watchedVideos[i] 和 friends[i] 分别表示 id = i 的人观看过的视频列表和他的好友列表。 Level 1 的视频包含所有你好友观看过的视频，level 2 的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 k 的视频包含所有从你出发，最短距离为 k 的好友观看过的视频。 给定你的 id 和一个 level 值，请你找出所有指定 level 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按名字字典序从小到大排列。 示例：示例 1： 输入：watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1 输出：[&quot;B&quot;,&quot;C&quot;] 解释： 你的 id 为 0 ，你的朋友包括： id 为 1 -&gt; watchedVideos = [&quot;C&quot;] id 为 2 -&gt; watchedVideos = [&quot;B&quot;,&quot;C&quot;] 你朋友观看过视频的频率为： B -&gt; 1 C -&gt; 2 示例 2： 输入：watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2 输出：[&quot;D&quot;] 解释： 你的 id 为 0 ，你朋友的朋友只有一个人，他的 id 为 3 。 提示： n == watchedVideos.length == friends.length 2 &lt;= n &lt;= 100 1 &lt;= watchedVideos[i].length &lt;= 100 1 &lt;= watchedVideos[i][j].length &lt;= 8 0 &lt;= friends[i].length &lt; n 0 &lt;= friends[i][j] &lt; n 0 &lt;= id &lt; n 1 &lt;= level &lt; n 如果 friends[i] 包含 j ，那么 friends[j] 包含 i 分析：使用bfs来获取最后一层好友观看的视频使用一个map来存储中间层好友观看的视频最后从最后一层中好友观看的视频里去掉map中存储的视频，在使用sort排序即可 代码：class Solution { private: set&lt;int&gt; si; struct s{ int z; string c; s(int q, string e){ z = q; c = e; } }; map&lt;int, int&gt; mii; public: static bool pd(s q, s w){ if(q.z == w.z){ return q.c &lt; w.c; } return q.z &lt; w.z; } void bfs(vector&lt;vector&lt;int&gt;&gt;&amp; friends, int id, int level, int z){ queue&lt;int&gt; qi1; queue&lt;int&gt; qi2; qi1.push(id); qi2.push(z); while(qi1.size() != 0){ int z = qi1.front(); qi1.pop(); int x = qi2.front(); qi2.pop(); if(x == level){ if(mii[z] == 0) si.insert(z); continue; } if(x != level) mii[z] = 1; for(int i = 0; i &lt; friends[z].size(); i++){ qi1.push(friends[z][i]); qi2.push(x+1); } } } vector&lt;string&gt; watchedVideosByFriends(vector&lt;vector&lt;string&gt;&gt;&amp; watchedVideos, vector&lt;vector&lt;int&gt;&gt;&amp; friends, int id, int level) { bfs(friends, id, level, 0); vector&lt;s&gt; vs; map&lt;string, int&gt; m; for(auto a = si.begin(); a != si.end(); a++){ for(int i = 0; i &lt; watchedVideos[*a].size(); i++){ m[watchedVideos[*a][i]]++; } } for(auto a = m.begin(); a != m.end(); a++){ vs.push_back(s(a-&gt;second, a-&gt;first)); } sort(vs.begin(), vs.end(), pd); vector&lt;string&gt; ret; for(int i = 0; i &lt; vs.size(); i++){ ret.push_back(vs[i].c); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/get-watched-videos-by-your-friends/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1310. 子数组异或查询]]></title>
    <url>%2F2020%2F01%2F06%2Fleetcode%201310.%20%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[题目：有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。 对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor … xor arr[Ri]）作为本次查询的结果。 并返回一个包含给定查询 queries 所有结果的数组。 示例：示例 1： 输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] 输出：[2,7,14,8] 解释： 数组中元素的二进制表示形式是： 1 = 0001 3 = 0011 4 = 0100 8 = 1000 查询的 XOR 值为： [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 示例 2： 输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]] 输出：[8,0,4,4] 提示： 1 &lt;= arr.length &lt;= 3 * 10^4 1 &lt;= arr[i] &lt;= 10^9 1 &lt;= queries.length &lt;= 3 * 10^4 queries[i].length == 2 0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length 分析： 使用map来存储已经计算过的内容，但这个方法只是投机取巧 可以使用异或的特性，0^A = A, A^A = 0, 只需要维护一个数组，每一位存储着，第一位异或到当前位后的值 公式：XOR[l, r] = XOR[0, r] ^ XOR[0, l-1] 代码：class Solution { public: vector&lt;int&gt; xorQueries(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { map&lt;vector&lt;int&gt;, int&gt; m; vector&lt;int&gt; vi; for(int i = 0; i &lt; queries.size(); i++){ if(m.count(queries[i]) != 0){ vi.push_back(m[queries[i]]); } else{ int z = arr[queries[i][0]]; for(int j = queries[i][0]+1; j &lt;= queries[i][1]; j++){ z = z ^ arr[j]; } vi.push_back(z); m[queries[i]] = z; } } return vi; } }; 题目地址:https://leetcode-cn.com/problems/xor-queries-of-a-subarray/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1309. 解码字母到整数映射]]></title>
    <url>%2F2020%2F01%2F06%2Fleetcode%201309.%20%E8%A7%A3%E7%A0%81%E5%AD%97%E6%AF%8D%E5%88%B0%E6%95%B4%E6%95%B0%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s，它由数字（’0’ - ‘9’）和 ‘#’ 组成。我们希望按下述规则将 s 映射为一些小写英文字符： 字符（’a’ - ‘i’）分别用（’1’ - ‘9’）表示。 字符（’j’ - ‘z’）分别用（’10#’ - ‘26#’）表示。返回映射之后形成的新字符串。 题目数据保证映射始终唯一。 示例：示例 1： 输入：s = &quot;10#11#12&quot; 输出：&quot;jkab&quot; 解释：&quot;j&quot; -&gt; &quot;10#&quot; , &quot;k&quot; -&gt; &quot;11#&quot; , &quot;a&quot; -&gt; &quot;1&quot; , &quot;b&quot; -&gt; &quot;2&quot;. 示例 2： 输入：s = &quot;1326#&quot; 输出：&quot;acz&quot; 示例 3： 输入：s = &quot;25#&quot; 输出：&quot;y&quot; 示例 4： 输入：s = &quot;12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#&quot; 输出：&quot;abcdefghijklmnopqrstuvwxyz&quot; 提示： 1 &lt;= s.length &lt;= 1000 s[i] 只包含数字（’0’-‘9’）和 ‘#’ 字符。 s 是映射始终存在的有效字符串。 分析：倒着遍历，遇到#就获取前两个数字所代表的字符，否则就获取当前数字所代表的字符 代码：class Solution { public: string freqAlphabets(string s) { string str = &quot;&quot;; for(int i = s.size()-1; i &gt;= 0; i--){ if(s[i] == &apos;#&apos;){ int z = s[i-1] - &apos;0&apos;; z = (s[i-2] - &apos;0&apos;) * 10 + z; z--; str = char(z + &apos;a&apos;) + str; i -= 2; } else{ int z = s[i] - &apos;1&apos;; str = char(z + &apos;a&apos;) + str; } } return str; } }; 题目地址:https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1307. 口算难题]]></title>
    <url>%2F2019%2F12%2F30%2Fleetcode%201307.%20%E5%8F%A3%E7%AE%97%E9%9A%BE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目：给你一个方程，左边用 words 表示，右边用 result 表示。 你需要根据以下规则检查方程是否可解： 每个字符都会被解码成一位数字（0 - 9）。 每对不同的字符必须映射到不同的数字。 每个 words[i] 和 result 都会被解码成一个没有前导零的数字。 左侧数字之和（words）等于右侧数字（result）。 如果方程可解，返回 True，否则返回 False。 示例：示例 1： 输入：words = [&quot;SEND&quot;,&quot;MORE&quot;], result = &quot;MONEY&quot; 输出：true 解释：映射 &apos;S&apos;-&gt; 9, &apos;E&apos;-&gt;5, &apos;N&apos;-&gt;6, &apos;D&apos;-&gt;7, &apos;M&apos;-&gt;1, &apos;O&apos;-&gt;0, &apos;R&apos;-&gt;8, &apos;Y&apos;-&gt;&apos;2&apos; 所以 &quot;SEND&quot; + &quot;MORE&quot; = &quot;MONEY&quot; , 9567 + 1085 = 10652 示例 2： 输入：words = [&quot;SIX&quot;,&quot;SEVEN&quot;,&quot;SEVEN&quot;], result = &quot;TWENTY&quot; 输出：true 解释：映射 &apos;S&apos;-&gt; 6, &apos;I&apos;-&gt;5, &apos;X&apos;-&gt;0, &apos;E&apos;-&gt;8, &apos;V&apos;-&gt;7, &apos;N&apos;-&gt;2, &apos;T&apos;-&gt;1, &apos;W&apos;-&gt;&apos;3&apos;, &apos;Y&apos;-&gt;4 所以 &quot;SIX&quot; + &quot;SEVEN&quot; + &quot;SEVEN&quot; = &quot;TWENTY&quot; , 650 + 68782 + 68782 = 138214 示例 3： 输入：words = [&quot;THIS&quot;,&quot;IS&quot;,&quot;TOO&quot;], result = &quot;FUNNY&quot; 输出：true 示例 4： 输入：words = [&quot;LEET&quot;,&quot;CODE&quot;], result = &quot;POINT&quot; 输出：false 提示： 2 &lt;= words.length &lt;= 5 1 &lt;= words[i].length, results.length &lt;= 7 words[i], result 只含有大写英文字母 表达式中使用的不同字符数最大为 10 分析：代码：class Solution {private: bool ret; vector m1;public: void dg(vector&lt;vector&gt;&amp; vvc, string result, vector mi, map&lt;int, bool&gt; m, int z, int x, int a){// vvc是按位重组的字母串，result是反转过后的字符串，mi是26字母对应的数字，m是数字是否使用过，z是按位重组后的第一个下标，x是按位重组后的第二个下标，a是上一位的进位 if(ret == true){ // 设置提前退出，剪枝 return; } if(vvc.size() == z){ // 当vcc中所有的数字比对完后判断是result是否还有数字没有比对 if(result.size() &gt; z+1) // result不可能比vcc中最大的数多出两位及以上 return; if(result.size() &gt; z){ // 只大一位的话，那上一位的进位和多出的一位比较 if(m[a] == false &amp;&amp; -1 == mi[result[z]-‘A’] || a == mi[result[z]-‘A’]){ m1 = mi; ret = true; } } else ret = true; return; } if(vvc[z].size() == x){ // 一位的数全部统计完成 int q = a; for(int i = 0; i &lt; vvc[z].size(); i++){ // 每位相加 q += mi[vvc[z][i]-‘A’]; } if(mi[result[z] - ‘A’] == -1){ // 如果result中对应位的值没有出现过 if(m[q % 10] == false){ // 并且正确的数也没有使用过，就将此字符设置成新数字，然后进入下一位的计算 m[q % 10] = true; mi[result[z] - ‘A’] = q % 10; dg(vvc, result, mi, m, z+1, 0, q/10); return; } else{ return; } } else{ if(mi[result[z] - ‘A’] == q % 10){ // 如果出现过，就判断是否正确，正确进入下一位的计算 dg(vvc, result, mi, m, z+1, 0, q/10); return; } else{ return; } } } if(mi[vvc[z][x] - &apos;A&apos;] == -1){ // 如果当前字符没有对应的数字，就依次尝试每一个数字，除了已经出现过的数字 for(int i = 0; i &lt; 10; i++){ if(m[i] == false){ mi[vvc[z][x] - &apos;A&apos;] = i; m[i] = true; dg(vvc, result, mi, m, z, x+1, a); m[i] = false; } } mi[vvc[z][x] - &apos;A&apos;] = -1; } else{ dg(vvc, result, mi, m, z, x+1, a); } } bool isSolvable(vector&lt;string&gt;&amp; words, string result) { ret = false; vector&lt;vector&lt;char&gt;&gt; vvc; // 新的按位分组的words bool b = true; int z = 0; vector&lt;int&gt; mi(26, -1); map&lt;int, bool&gt; m; vector&lt;string&gt; words1(words.size(), &quot;&quot;); string result1; for(int i = 0; i &lt; words.size(); i++){ // 反转字符串 for(int j = words[i].size()-1; j &gt;= 0; j--){ words1[i] += words[i][j]; } } for(int i = result.size()-1; i &gt;= 0; i--){ result1 += result[i]; } while(b){ // vvc赋值 b = false; vector&lt;char&gt; vc; for(int i = 0; i &lt; words1.size(); i++){ if(z &lt; words1[i].size()){ vc.push_back(words1[i][z]); b = true; } } vvc.push_back(vc); z++; } vvc.pop_back(); dg(vvc, result1, mi, m, 0, 0, 0); return ret; } }; 题目地址:https://leetcode-cn.com/problems/verbal-arithmetic-puzzle/submissions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1306. 跳跃游戏 III]]></title>
    <url>%2F2019%2F12%2F30%2Fleetcode%201306.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20III%2F</url>
    <content type="text"><![CDATA[题目：这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。 请你判断自己是否能够跳到对应元素值为 0 的 任意 下标处。 注意，不管是什么情况下，你都无法跳到数组之外。 示例：示例 1： 输入：arr = [4,2,3,0,3,1,2], start = 5 输出：true 解释： 到达值为 0 的下标 3 有以下可能方案： 下标 5 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 下标 5 -&gt; 下标 6 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 示例 2： 输入：arr = [4,2,3,0,3,1,2], start = 0 输出：true 解释： 到达值为 0 的下标 3 有以下可能方案： 下标 0 -&gt; 下标 4 -&gt; 下标 1 -&gt; 下标 3 示例 3： 输入：arr = [3,0,2,1,2], start = 2 输出：false 解释：无法到达值为 0 的下标 1 处。 提示： 1 &lt;= arr.length &lt;= 5 * 10^4 0 &lt;= arr[i] &lt; arr.length 0 &lt;= start &lt; arr.length 分析：创建一个数组，循环遍历，每次将跳动一次就可以到达0的数修改为0，循环至再也没有一个数可以修改为0为止 代码：class Solution { public: bool canReach(vector&lt;int&gt;&amp; arr, int start) { bool b = true; vector&lt;int&gt; vi(arr); while(b){ b = false; for(int i = 0; i &lt; arr.size(); i++){ if(vi[i] == 0) continue; if(i+arr[i] &lt; arr.size() &amp;&amp; vi[i+arr[i]] == 0){ vi[i] = 0; b = true; } if(i-arr[i] &gt;= 0 &amp;&amp; vi[i-arr[i]] == 0){ vi[i] = 0; b = true; } } } if(vi[start] == 0){ return true; } return false; } }; 题目地址:https://leetcode-cn.com/problems/jump-game-iii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1305. 两棵二叉搜索树中的所有元素]]></title>
    <url>%2F2019%2F12%2F30%2Fleetcode%201305.%20%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目：给你 root1 和 root2 这两棵二叉搜索树。 请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。. 示例：示例 1： 输入：root1 = [2,1,4], root2 = [1,0,3] 输出：[0,1,1,2,3,4] 示例 2： 输入：root1 = [0,-10,10], root2 = [5,1,7,0,2] 输出：[-10,0,0,1,2,5,7,10] 示例 3： 输入：root1 = [], root2 = [5,1,7,0,2] 输出：[0,1,2,5,7] 示例 4： 输入：root1 = [0,-10,10], root2 = [] 输出：[-10,0,10] 示例 5： 输入：root1 = [1,null,8], root2 = [8,1] 输出：[1,1,8,8] 提示： 每棵树最多有 5000 个节点。 每个节点的值在 [-10^5, 10^5] 之间。 分析：直接dfs获取所有节点值，再sort排序 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { private: vector&lt;int&gt; vi; public: void dfs(TreeNode* root){ if(root == NULL) return; vi.push_back(root-&gt;val); dfs(root-&gt;left); dfs(root-&gt;right); } vector&lt;int&gt; getAllElements(TreeNode* root1, TreeNode* root2) { dfs(root1); dfs(root2); sort(vi.begin(), vi.end()); return vi; } }; 题目地址:https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1304. 和为零的N个唯一整数]]></title>
    <url>%2F2019%2F12%2F30%2Fleetcode%201304.%20%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84N%E4%B8%AA%E5%94%AF%E4%B8%80%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。 示例：示例 1： 输入：n = 5 输出：[-7,-1,1,3,4] 解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。 示例 2： 输入：n = 3 输出：[-1,0,1] 示例 3： 输入：n = 1 输出：[0] 提示： 1 &lt;= n &lt;= 1000 分析：如果是偶数，一对一对绝对值相同的正负数组合，如果是奇数，多加个0 代码：class Solution { public: vector&lt;int&gt; sumZero(int n) { vector&lt;int&gt; vi; if(n % 2 == 1){ vi.push_back(0); n--; } for(int i = 0; i &lt; n; i+=2){ vi.push_back(i+1); vi.push_back((i+1)*-1); } return vi; } }; 题目地址:https://leetcode-cn.com/problems/find-n-unique-integers-sum-up-to-zero/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1298. 你能从盒子里获得的最大糖果数]]></title>
    <url>%2F2019%2F12%2F23%2Fleetcode%201298.%20%E4%BD%A0%E8%83%BD%E4%BB%8E%E7%9B%92%E5%AD%90%E9%87%8C%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B3%96%E6%9E%9C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你 n 个盒子，每个盒子的格式为 [status, candies, keys, containedBoxes] ，其中： 状态字 status[i]：整数，如果 box[i] 是开的，那么是 1 ，否则是 0 。 糖果数 candies[i]: 整数，表示 box[i] 中糖果的数目。 钥匙 keys[i]：数组，表示你打开 box[i] 后，可以得到一些盒子的钥匙，每个元素分别为该钥匙对应盒子的下标。 内含的盒子 containedBoxes[i]：整数，表示放在 box[i] 里的盒子所对应的下标。 给你一个 initialBoxes 数组，表示你现在得到的盒子，你可以获得里面的糖果，也可以用盒子里的钥匙打开新的盒子，还可以继续探索从这个盒子里找到的其他盒子。 请你按照上述规则，返回可以获得糖果的 最大数目 。 示例：示例 1： 输入：status = [1,0,1,0], candies = [7,5,4,100], keys = [[],[],[1],[]], containedBoxes = [[1,2],[3],[],[]], initialBoxes = [0] 输出：16 解释： 一开始你有盒子 0 。你将获得它里面的 7 个糖果和盒子 1 和 2。 盒子 1 目前状态是关闭的，而且你还没有对应它的钥匙。所以你将会打开盒子 2 ，并得到里面的 4 个糖果和盒子 1 的钥匙。 在盒子 1 中，你会获得 5 个糖果和盒子 3 ，但是你没法获得盒子 3 的钥匙所以盒子 3 会保持关闭状态。 你总共可以获得的糖果数目 = 7 + 4 + 5 = 16 个。 示例 2： 输入：status = [1,0,0,0,0,0], candies = [1,1,1,1,1,1], keys = [[1,2,3,4,5],[],[],[],[],[]], containedBoxes = [[1,2,3,4,5],[],[],[],[],[]], initialBoxes = [0] 输出：6 解释： 你一开始拥有盒子 0 。打开它你可以找到盒子 1,2,3,4,5 和它们对应的钥匙。 打开这些盒子，你将获得所有盒子的糖果，所以总糖果数为 6 个。 示例 3： 输入：status = [1,1,1], candies = [100,1,100], keys = [[],[0,2],[]], containedBoxes = [[],[],[]], initialBoxes = [1] 输出：1 示例 4： 输入：status = [1], candies = [100], keys = [[]], containedBoxes = [[]], initialBoxes = [] 输出：0 示例 5： 输入：status = [1,1,1], candies = [2,3,2], keys = [[],[],[]], containedBoxes = [[],[],[]], initialBoxes = [2,1,0] 输出：7 提示： 1 &lt;= status.length &lt;= 1000 status.length == candies.length == keys.length == containedBoxes.length == n status[i] 要么是 0 要么是 1 。 1 &lt;= candies[i] &lt;= 1000 0 &lt;= keys[i].length &lt;= status.length 0 &lt;= keys[i][j] &lt; status.lengthkeys[i] 中的值都是互不相同的。 0 &lt;= containedBoxes[i].length &lt;= status.length 0 &lt;= containedBoxes[i][j] &lt; status.length containedBoxes[i] 中的值都是互不相同的。 每个盒子最多被一个盒子包含。 0 &lt;= initialBoxes.length &lt;= status.length 0 &lt;= initialBoxes[i] &lt; status.length 分析：三个map，没开过的盒子hz，没使用过的钥匙ys，已经开启过的盒子kq（避免重复开启） 写一个函数，开箱子，获得里面的糖果、盒子和钥匙，并且去hz和ys里面去寻找对应额盒子和钥匙，要是没有的话，存入hz和ys。其中注意每次开盒子，通过kq判断是否开启过盒子 代码：class Solution { private: map&lt;int, int&gt; hz; map&lt;int, int&gt; ys; map&lt;int, int&gt; kq; int ret; public: void dg(vector&lt;int&gt;&amp; status, vector&lt;int&gt;&amp; candies, vector&lt;vector&lt;int&gt;&gt;&amp; keys, vector&lt;vector&lt;int&gt;&gt;&amp; containedBoxes, int dk){ if(kq[dk] == 1){ return; } kq[dk] = 1; ret += candies[dk]; for(int i = 0; i &lt; keys[dk].size(); i++){ if(hz[keys[dk][i]] == 1){ hz[keys[dk][i]] = 0; dg(status, candies, keys, containedBoxes, keys[dk][i]); } else{ ys[keys[dk][i]] = 1; } } for(int i = 0; i &lt; containedBoxes[dk].size(); i++){ if(status[containedBoxes[dk][i]] == 1){ hz[containedBoxes[dk][i]] = 0; dg(status, candies, keys, containedBoxes, containedBoxes[dk][i]); } if(ys[containedBoxes[dk][i]] == 1){ ys[containedBoxes[dk][i]] = 0; dg(status, candies, keys, containedBoxes, containedBoxes[dk][i]); } else{ hz[containedBoxes[dk][i]] = 1; } } } int maxCandies(vector&lt;int&gt;&amp; status, vector&lt;int&gt;&amp; candies, vector&lt;vector&lt;int&gt;&gt;&amp; keys, vector&lt;vector&lt;int&gt;&gt;&amp; containedBoxes, vector&lt;int&gt;&amp; initialBoxes) { ret = 0; for(int i = 0; i &lt; initialBoxes.size(); i++){ if(status[initialBoxes[i]] == 0){ hz[initialBoxes[i]] = 1; } } for(int i = 0; i &lt; initialBoxes.size(); i++){ if(status[initialBoxes[i]] == 1){ dg(status, candies, keys, containedBoxes, initialBoxes[i]); } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-candies-you-can-get-from-boxes/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1297. 子串的最大出现次数]]></title>
    <url>%2F2019%2F12%2F23%2Fleetcode%201297.%20%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数： 子串中不同字母的数目必须小于等于 maxLetters 。 子串的长度必须大于等于 minSize 且小于等于 maxSize 。 示例：示例 1： 输入：s = &quot;aababcaab&quot;, maxLetters = 2, minSize = 3, maxSize = 4 输出：2 解释：子串 &quot;aab&quot; 在原字符串中出现了 2 次。 它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。 示例 2： 输入：s = &quot;aaaa&quot;, maxLetters = 1, minSize = 3, maxSize = 3 输出：2 解释：子串 &quot;aaa&quot; 在原字符串中出现了 2 次，且它们有重叠部分。 示例 3： 输入：s = &quot;aabcabcab&quot;, maxLetters = 2, minSize = 2, maxSize = 3 输出：3 示例 4： 输入：s = &quot;abcde&quot;, maxLetters = 2, minSize = 3, maxSize = 3 输出：0 提示： 1 &lt;= s.length &lt;= 10^5 1 &lt;= maxLetters &lt;= 26 1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length) s 只包含小写英文字母。 分析：长度长的子字符串肯定有一个短的字符串也满足条件，所以只需要获取所有长度等于minSize的子字符串，使用map存储出现次数。然后遍历map，找出出现次数最多，并且满足子串中不同字母的数目小于等于 maxLetters的字符串即可 代码：class Solution { public: int maxFreq(string s, int maxLetters, int minSize, int maxSize) { map&lt;string, int&gt; m; int ret = 0; for(int l = 0, r = minSize-1; r &lt; s.size(); l++, r++){ m[s.substr(l, minSize)]++; } for(auto a = m.begin(); a != m.end(); a++){ if(ret &lt; a-&gt;second){ map&lt;char, int&gt; m1; int z = 0; for(int i = 0; i &lt; a-&gt;first.size(); i++){ if(m1[a-&gt;first[i]] == 0){ z++; m1[a-&gt;first[i]]++; } } if(z &lt;= maxLetters){ ret = a-&gt;second; } } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1296. 划分数组为连续数字的集合]]></title>
    <url>%2F2019%2F12%2F23%2Fleetcode%201296.%20%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 和一个正整数 k，请你判断是否可以把这个数组划分成一些由 k 个连续数字组成的集合。如果可以，请返回 True；否则，返回 False。 示例：示例 1： 输入：nums = [1,2,3,3,4,4,5,6], k = 4 输出：true 解释：数组可以分成 [1,2,3,4] 和 [3,4,5,6]。 示例 2： 输入：nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3 输出：true 解释：数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]。 示例 3： 输入：nums = [3,3,2,2,1,1], k = 3 输出：true 示例 4： 输入：nums = [1,2,3,4], k = 3 输出：false 解释：数组不能分成几个大小为 3 的子数组。 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^9 1 &lt;= k &lt;= nums.length 分析：使用map统计每个数出现次数，使用set排序并去重 按照set的排序找出连续k个数字，并在map中-1。 一次次寻找直到所剩数为0返回true 如果中途缺少某个数，返回false 代码：class Solution {public: bool isPossibleDivide(vector&amp; nums, int k) { map&lt;int, int&gt; m; for(int i = 0; i &lt; nums.size(); i++){ m[nums[i]]++; } set s(nums.begin(), nums.end()); for(auto a = s.begin(); a != s.end();){ auto z = a; m[z]–; int x = z; z++; for(int i = 1; i &lt; k; i++){ if(z != s.end() &amp;&amp; z == x+1 &amp;&amp; m[z] &gt; 0){ cout &lt;&lt; m[z]; x = z; m[z]–; z++; } else{ return false; } } while(a != s.end() &amp;&amp; m[a] &lt;= 0){ a++; } } return true; }}; 题目地址:https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1295. 统计位数为偶数的数字]]></title>
    <url>%2F2019%2F12%2F23%2Fleetcode%201295.%20%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。 示例：示例 1： 输入：nums = [12,345,2,6,7896] 输出：2 解释： 12 是 2 位数字（位数为偶数） 345 是 3 位数字（位数为奇数） 2 是 1 位数字（位数为奇数） 6 是 1 位数字 位数为奇数） 7896 是 4 位数字（位数为偶数） 因此只有 12 和 7896 是位数为偶数的数字 示例 2： 输入：nums = [555,901,482,1771] 输出：1 解释： 只有 1771 是位数为偶数的数字。 提示： 1 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 10^5 分析：用 log10 来计算位数，用log2来判断是否为偶数 代码：class Solution { public: int findNumbers(vector&lt;int&gt;&amp; nums) { int ret = 0; for(int i = 0; i &lt; nums.size(); i++){ int w = 0; while(nums[i] &gt; 0){ nums[i] /= 10; w++; } if(w % 2 == 0){ ret++; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1293. 网格中的最短路径]]></title>
    <url>%2F2019%2F12%2F16%2Fleetcode%201293.%20%E7%BD%91%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个 m * n 的网格，其中每个单元格不是 0（空）就是 1（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。 如果您 最多 可以消除 k 个障碍物，请找出从左上角 (0, 0) 到右下角 (m-1, n-1) 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 -1。 示例：示例 1： 输入： grid = [[0,0,0], [1,1,0], [0,0,0], [0,1,1], [0,0,0]], k = 1 输出：6 解释： 不消除任何障碍的最短路径是 10。 消除位置 (3,2) 处的障碍后，最短路径是 6 。该路径是 (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; (3,2) -&gt; (4,2). 示例 2： 输入： grid = [[0,1,1], [1,1,1], [1,0,0]], k = 1 输出：-1 解释： 我们至少需要消除两个障碍才能找到这样的路径。 提示： grid.length == m grid[0].length == n 1 &lt;= m, n &lt;= 40 1 &lt;= k &lt;= m*n grid[i][j] == 0 or 1 grid[0][0] == grid[m-1][n-1] == 0 分析：使用bfs 再用一个三维数组vvvi[i][j][k], 表示计算到横坐标为i, 纵坐标为j, 已消除障碍次数为k时的移动次数，因为是bfs，所以先到达的移动次数一定要少，所以只用记录第一个到达的移动次数即可 代码：class Solution { private: struct node{ int x, y, k; // x, y 表示坐标， k表示已经消除障碍次数 node(int x1, int y1, int k1){ x = x1; y = y1; k = k1; }; }; public: int shortestPath(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) { queue&lt;node&gt; q; vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; vvvi(grid.size(), vector&lt;vector&lt;int&gt;&gt;(grid[0].size(), vector&lt;int&gt;(k+10, -1))); vvvi[0][0][0] = 0; // vvvi[i][j][k], 表示计算到横坐标为i, 纵坐标为j, 已消除障碍次数为k时的移动次数 q.push(node(0,0,0)); int x1[4] = {-1, 1, 0, 0}; int y1[4] = {0, 0, -1, 1}; while(q.size() != 0){ node n = q.front(); q.pop(); for(int i = 0; i &lt; 4; i++){ int xx = n.x + x1[i]; int yy = n.y + y1[i]; if(xx &lt; grid.size() &amp;&amp; xx &gt;= 0 &amp;&amp; yy &lt; grid[0].size() &amp;&amp; yy &gt;= 0 &amp;&amp; n.k + grid[xx][yy] &lt;= k){ if(vvvi[xx][yy][n.k + grid[xx][yy]] == -1){ vvvi[xx][yy][n.k + grid[xx][yy]] = vvvi[n.x][n.y][n.k] + 1; q.push(node(xx, yy, n.k + grid[xx][yy])); } } } } int ret = INT_MAX; for(int i = 0; i &lt;= k; i++){ if(vvvi[grid.size()-1][grid[0].size()-1][i] != -1 &amp;&amp; vvvi[grid.size()-1][grid[0].size()-1][i] &lt; ret) ret = vvvi[grid.size()-1][grid[0].size()-1][i]; } if (ret == INT_MAX) return -1; return ret; } }; 题目地址:https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1292. 元素和小于等于阈值的正方形的最大边长]]></title>
    <url>%2F2019%2F12%2F16%2Fleetcode%201292.%20%E5%85%83%E7%B4%A0%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BE%B9%E9%95%BF%2F</url>
    <content type="text"><![CDATA[题目：给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。 请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。 示例：示例 1： 输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4 输出：2 解释：总和小于 4 的正方形的最大边长为 2，如图所示。 示例 2： 输入：mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1 输出：0 示例 3： 输入：mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6 输出：3 示例 4： 输入：mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184 输出：2 提示： 1 &lt;= m, n &lt;= 300 m == mat.length n == mat[i].length 0 &lt;= mat[i][j] &lt;= 10000 0 &lt;= threshold &lt;= 10^5 分析：使用前缀和的遍历（以每个点为左上角遍历），时间复杂度为n^3,因为全是正数，所以可以使用二分将时间压缩到n^2logn 代码：class Solution { public: int maxSideLength(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int threshold) { vector&lt;vector&lt;int&gt;&gt; vvi1(mat.size()+2, vector&lt;int&gt;(mat[0].size()+2, 0)); // 列前缀和 vector&lt;vector&lt;int&gt;&gt; vvi2(mat.size()+2, vector&lt;int&gt;(mat[0].size()+2, 0)); // 行前缀和 int ret = 0; for(int i = 1; i &lt;= mat.size(); i++){ // 前缀和 for(int j = 1; j &lt;= mat[0].size(); j++){ vvi1[i][j] = vvi1[i-1][j] + mat[i-1][j-1]; vvi2[i][j] = vvi2[i][j-1] + mat[i-1][j-1]; } } for(int k = 1; k &lt;= min(mat.size(), mat[0].size()); k++){ int z = 0; for(int i = 0; i &lt; k; i++){ for(int j = 0; j &lt; k; j++){ z += mat[i][j]; } } for(int i = 0; i &lt; mat.size() - k + 1; i++){ int z1 = z; for(int j = 0; j &lt; mat[0].size() - k + 1; j++){ if(z1 &lt;= threshold &amp;&amp; ret &lt; k){ ret = k; } z1 = z1 + vvi1[i+k][j+k+1] - vvi1[i][j+k+1] - vvi1[i+k][j+1] + vvi1[i][j+1]; // 要注意格式 } z = z + vvi2[i+k+1][k] - vvi2[i+1][k]; } } return ret; } }; 题目地址:https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1291. 顺次数]]></title>
    <url>%2F2019%2F12%2F16%2Fleetcode%201291.%20%E9%A1%BA%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。 请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。 示例：示例 1： 输出：low = 100, high = 300 输出：[123,234] 示例 2： 输出：low = 1000, high = 13000 输出：[1234,2345,3456,4567,5678,6789,12345] 提示： 10 &lt;= low &lt;= high &lt;= 10^9 分析：直接将每一个可能的数遍历一遍，找到符合条件的 代码：class Solution { public: vector&lt;int&gt; sequentialDigits(int low, int high) { vector&lt;int&gt; vi; for(int i = 2; i &lt; 10; i++){ // 位数 for(int j = 1; j+i-1 &lt; 10; j++){ // 开始数字 int z = 0; for(int k = 0; k &lt; i; k++){ // 给每一位赋值 z = z*10 + k + j; } if(z &gt;= low &amp;&amp; z &lt;= high) vi.push_back(z); } } return vi; } }; 题目地址:https://leetcode-cn.com/problems/sequential-digits/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1290. 二进制链表转整数]]></title>
    <url>%2F2019%2F12%2F16%2Fleetcode%201290.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。 请你返回该链表所表示数字的 十进制值 。 示例：示例 1： 输入：head = [1,0,1]输出：5解释：二进制数 (101) 转化为十进制数 (5)示例 2： 输入：head = [0]输出：0示例 3： 输入：head = [1]输出：1示例 4： 输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]输出：18880示例 5： 输入：head = [0,0]输出：0 提示： 链表不为空。 链表的结点总数不超过 30。 每个结点的值不是 0 就是 1。 分析：存储成数组，然后反着计算成十进制数 代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: int getDecimalValue(ListNode* head) { vector&lt;int&gt; vi; int ret = 0; int n = 1; ListNode* l = head; while(l != NULL){ vi.push_back(l-&gt;val); l = l-&gt;next; } for(int i = vi.size()-1; i &gt;= 0; i--){ ret += vi[i] * n; n *= 2; } return ret; } }; 题目地址:https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1284. 转化为全零矩阵的最少反转次数]]></title>
    <url>%2F2019%2F12%2F09%2Fleetcode%201284.%20%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%85%A8%E9%9B%B6%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%91%E5%8F%8D%E8%BD%AC%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个 m x n 的二进制矩阵 mat。 每一步，你可以选择一个单元格并将它反转（反转表示 0 变 1 ，1 变 0 ）。如果存在和它相邻的单元格，那么这些相邻的单元格也会被反转。（注：相邻的两个单元格共享同一条边。） 请你返回将矩阵 mat 转化为全零矩阵的最少反转次数，如果无法转化为全零矩阵，请返回 -1 。 二进制矩阵的每一个格子要么是 0 要么是 1 。 全零矩阵是所有格子都为 0 的矩阵。 示例：示例 1： 输入：mat = [[0,0],[0,1]] 输出：3 解释：一个可能的解是反转 (1, 0)，然后 (0, 1) ，最后是 (1, 1) 。 示例 2： 输入：mat = [[0]] 输出：0 解释：给出的矩阵是全零矩阵，所以你不需要改变它。 示例 3： 输入：mat = [[1,1,1],[1,0,1],[0,0,0]] 输出：6 示例 4： 输入：mat = [[1,0,0],[1,0,0]] 输出：-1 解释：该矩阵无法转变成全零矩阵 提示： m == mat.length n == mat[0].length 1 &lt;= m &lt;= 3 1 &lt;= n &lt;= 3 mat[i][j] 是 0 或 1 。 分析：使用bfs，直接暴力解 使用一个map用来记录所有格子的状态 将每个格子进行翻转，如果翻转后状态已经出现过，就跳过这次翻转。停止的条件有两个：达到全0矩阵，返回翻转次数。所有状态都被搜索过，但未能全0，返回-1 代码：class Solution { public: int minFlips(vector&lt;vector&lt;int&gt;&gt;&amp; mat) { map&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt; m; queue&lt;vector&lt;vector&lt;int&gt;&gt;&gt; q; queue&lt;int&gt; qi; q.push(mat); qi.push(0); while(q.size() != 0){ if(m.find(q.front()) != m.end()){ q.pop(); qi.pop(); continue; } bool b = true; for(int i = 0; i &lt; mat.size(); i++){ for(int j = 0; j &lt; mat[0].size(); j++){ if(q.front()[i][j] == 1){ b = false; break; } } } if(b){ return qi.front(); } m.insert(pair&lt;vector&lt;vector&lt;int&gt;&gt;, int&gt;{q.front(), 1}); for(int i = 0; i &lt; mat.size(); i++){ for(int j = 0; j &lt; mat[0].size(); j++){ vector&lt;vector&lt;int&gt;&gt; v(q.front()); v[i][j] = v[i][j] == 0 ? 1 : 0; if(i - 1 &gt;= 0){ v[i-1][j] = v[i-1][j] == 0 ? 1 : 0; } if(i + 1 &lt; mat.size()){ v[i+1][j] = v[i+1][j] == 0 ? 1 : 0; } if(j - 1 &gt;= 0){ v[i][j-1] = v[i][j-1] == 0 ? 1 : 0; } if(j + 1 &lt; mat[0].size()){ v[i][j+1] = v[i][j+1] == 0 ? 1 : 0; } q.push(v); qi.push(qi.front()+1); } } q.pop(); qi.pop(); } return -1; } }; 题目地址:https://leetcode-cn.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1283. 使结果不超过阈值的最小除数]]></title>
    <url>%2F2019%2F12%2F09%2Fleetcode%201283.%20%E4%BD%BF%E7%BB%93%E6%9E%9C%E4%B8%8D%E8%B6%85%E8%BF%87%E9%98%88%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E9%99%A4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 和一个正整数 threshold ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。 请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。 每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。 题目保证一定有解。 示例：示例 1： 输入：nums = [1,2,5,9], threshold = 6 输出：5 解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。 如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。 示例 2： 输入：nums = [2,3,5,7,11], threshold = 11 输出：3 示例 3： 输入：nums = [19], threshold = 5 输出：4 提示： 1 &lt;= nums.length &lt;= 5 * 10^4 1 &lt;= nums[i] &lt;= 10^6 nums.length &lt;= threshold &lt;= 10^6 分析：使用二分查找 代码：class Solution { public: int smallestDivisor(vector&lt;int&gt;&amp; nums, int threshold) { int l = 1; int r = 1000000; while(l &lt; r){ int m = (l+r)&gt;&gt;1; int h = 0; for(int i = 0; i &lt; nums.size(); i++){ h += nums[i] / m + (nums[i] % m != 0 ? 1 : 0); } if(h &gt; threshold){ l = m + 1; } else{ r = m; } } return l; } }; 题目地址:https://leetcode-cn.com/problems/find-the-smallest-divisor-given-a-threshold/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1282. 用户分组]]></title>
    <url>%2F2019%2F12%2F09%2Fleetcode%201282.%20%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。 你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。 示例：示例 1： 输入：groupSizes = [3,3,3,3,3,1,3] 输出：[[5],[0,1,2],[3,4,6]] 解释： 其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。 示例 2： 输入：groupSizes = [2,1,3,3,3,2] 输出：[[1],[0,5],[2,3,4]] 提示： groupSizes.length == n 1 &lt;= n &lt;= 500 1 &lt;= groupSizes[i] &lt;= n 分析：声明两个map，一个用来存储每个用户组该加入的人数，一个用来存储每个用户组还可以加入的人数。直接遍历即可 代码：class Solution { public: vector&lt;vector&lt;int&gt;&gt; groupThePeople(vector&lt;int&gt;&amp; groupSizes) { vector&lt;vector&lt;int&gt;&gt; vvi; map&lt;int, int&gt; mii; map&lt;int, int&gt; mii1; int q = 0; for(int i = 0; i &lt; groupSizes.size(); i++){ if(vvi.size() == 0){ vvi.push_back(vector&lt;int&gt;{i}); mii[q] = groupSizes[i]-1; mii1[q] = groupSizes[i]; q++; } else{ for(int j = 0; j &lt; vvi.size(); j++){ if(groupSizes[i] == mii1[j] &amp;&amp; mii[j] != 0){ vvi[j].push_back(i); mii[j]--; break; } if(j == vvi.size()-1){ vvi.push_back(vector&lt;int&gt;{i}); mii[q] = groupSizes[i]-1; mii1[q] = groupSizes[i]; q++; break; } } } } return vvi; } }; 题目地址:https://leetcode-cn.com/problems/group-the-people-given-the-group-size-they-belong-to/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1281. 整数的各位积和之差]]></title>
    <url>%2F2019%2F12%2F09%2Fleetcode%201281.%20%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。 示例：示例 1： 输入：n = 234 输出：15 解释： 各位数之积 = 2 * 3 * 4 = 24 各位数之和 = 2 + 3 + 4 = 9 结果 = 24 - 9 = 15 示例 2： 输入：n = 4421 输出：21 解释： 各位数之积 = 4 * 4 * 2 * 1 = 32 各位数之和 = 4 + 4 + 2 + 1 = 11 结果 = 32 - 11 = 21 提示： 1 &lt;= n &lt;= 10^5 分析：使用%和/获取每一位的数字，然后直接计算 代码：class Solution { public: int subtractProductAndSum(int n) { int z = n; int j = 1; int h = 0; while(z != 0){ j = j * (z % 10); h = h + (z % 10); z /= 10; } return j - h; } }; 题目地址:https://leetcode-cn.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1276. 不浪费原料的汉堡制作方案]]></title>
    <url>%2F2019%2F12%2F02%2Fleetcode%201276.%20%E4%B8%8D%E6%B5%AA%E8%B4%B9%E5%8E%9F%E6%96%99%E7%9A%84%E6%B1%89%E5%A0%A1%E5%88%B6%E4%BD%9C%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[题目：圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。 给你两个整数 tomatoSlices 和 cheeseSlices，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下： 巨无霸汉堡：4 片番茄和 1 片奶酪 小皇堡：2 片番茄和 1 片奶酪 请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。 如果无法使剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量为 0，就请返回 []。 示例：示例 1： 输入：tomatoSlices = 16, cheeseSlices = 7 输出：[1,6] 解释：制作 1 个巨无霸汉堡和 6 个小皇堡需要 4*1 + 2*6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。 示例 2： 输入：tomatoSlices = 17, cheeseSlices = 4 输出：[] 解释：只制作小皇堡和巨无霸汉堡无法用光全部原料。 示例 3： 输入：tomatoSlices = 4, cheeseSlices = 17 输出：[] 解释：制作 1 个巨无霸汉堡会剩下 16 片奶酪，制作 2 个小皇堡会剩下 15 片奶酪。 示例 4： 输入：tomatoSlices = 0, cheeseSlices = 0 输出：[0,0] 示例 5： 输入：tomatoSlices = 2, cheeseSlices = 1 输出：[0,1] 提示： 0 &lt;= tomatoSlices &lt;= 10^7 0 &lt;= cheeseSlices &lt;= 10^7 分析：鸡兔同笼问题，先判断无法组成的情况。 然后假设全是小汉堡，就需要2*奶酪个番茄。 （番茄数量减去2*奶酪个番茄）/ 2 ，就是大汉堡的数量 奶酪-大汉堡就是小汉堡数量 代码：class Solution { public: vector&lt;int&gt; numOfBurgers(int tomatoSlices, int cheeseSlices) { vector&lt;int&gt; vi; if(tomatoSlices &gt; cheeseSlices * 4) return vi; if(tomatoSlices &lt; cheeseSlices * 2) return vi; if(tomatoSlices % 2 != 0) return vi; if(cheeseSlices == 0 &amp;&amp; tomatoSlices == 0) return vector&lt;int&gt;{0,0}; if(cheeseSlices == 0){ return vi; } int z = tomatoSlices - cheeseSlices * 2; vi.push_back(z/2); vi.push_back(cheeseSlices - vi[0]); return vi; } }; 题目地址:https://leetcode-cn.com/problems/number-of-burgers-with-no-waste-of-ingredients/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1275. 找出井字棋的获胜者]]></title>
    <url>%2F2019%2F12%2F02%2Fleetcode%201275.%20%E6%89%BE%E5%87%BA%E4%BA%95%E5%AD%97%E6%A3%8B%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%2F</url>
    <content type="text"><![CDATA[题目：A 和 B 在一个 3 x 3 的网格上玩井字棋。 井字棋游戏的规则如下： 玩家轮流将棋子放在空方格 (“ “) 上。第一个玩家 A 总是用 “X” 作为棋子，而第二个玩家 B 总是用 “O” 作为棋子。 “X” 和 “O” 只能放在空方格中，而不能放在已经被占用的方格上。只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。 如果所有方块都放满棋子（不为空），游戏也会结束。 游戏结束后，棋子无法再进行任何移动。给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。 如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。 你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。 示例：示例 1： 输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]] 输出：&quot;A&quot; 解释：&quot;A&quot; 获胜，他总是先走。 &quot;X &quot; &quot;X &quot; &quot;X &quot; &quot;X &quot; &quot;X &quot; &quot; &quot; -&gt; &quot; &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; -&gt; &quot; X &quot; &quot; &quot; &quot;O &quot; &quot;O &quot; &quot;OO &quot; &quot;OOX&quot; 示例 2： 输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]] 输出：&quot;B&quot; 解释：&quot;B&quot; 获胜。 &quot;X &quot; &quot;X &quot; &quot;XX &quot; &quot;XXO&quot; &quot;XXO&quot; &quot;XXO&quot; &quot; &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot; O &quot; -&gt; &quot;XO &quot; -&gt; &quot;XO &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot; &quot;O &quot; 示例 3： 输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]] 输出：&quot;Draw&quot; 输出：由于没有办法再行动，游戏以平局结束。 &quot;XXO&quot; &quot;OOX&quot; &quot;XOX&quot; 示例 4： 输入：moves = [[0,0],[1,1]] 输出：&quot;Pending&quot; 解释：游戏还没有结束。 &quot;X &quot; &quot; O &quot; &quot; &quot; 提示： 1 &lt;= moves.length &lt;= 9 moves[i].length == 2 0 &lt;= moves[i][j] &lt;= 2 moves 里没有重复的元素。 moves 遵循井字棋的规则。 分析：先下好棋子，然后判断输赢 代码：class Solution { public: string tictactoe(vector&lt;vector&lt;int&gt;&gt;&amp; moves) { vector&lt;vector&lt;int&gt;&gt; vvi(3, vector&lt;int&gt;(3, 0)); for(int i = 0; i &lt; moves.size(); i++){ if(i % 2 == 0){ vvi[moves[i][0]][moves[i][1]] = 1; } else{ vvi[moves[i][0]][moves[i][1]] = -1; } } for(int i = 0; i &lt; 3; i++){ if(vvi[i][0] + vvi[i][1] + vvi[i][2] == 3) return &quot;A&quot;; else if(vvi[i][0] + vvi[i][1] + vvi[i][2] == -3) return &quot;B&quot;; if(vvi[0][i] + vvi[1][i] + vvi[2][i] == 3) return &quot;A&quot;; else if(vvi[0][i] + vvi[1][i] + vvi[2][i] == -3) return &quot;B&quot;; } if(vvi[0][0] + vvi[1][1] + vvi[2][2] == 3) return &quot;A&quot;; else if(vvi[0][0] + vvi[1][1] + vvi[2][2] == -3) return &quot;B&quot;; if(vvi[2][0] + vvi[1][1] + vvi[0][2] == 3) return &quot;A&quot;; else if(vvi[2][0] + vvi[1][1] + vvi[0][2] == -3) return &quot;B&quot;; if(moves.size() == 9){ return &quot;Draw&quot;; } return &quot;Pending&quot;; } }; 题目地址:https://leetcode-cn.com/problems/find-winner-on-a-tic-tac-toe-game/submissions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1268. 搜索推荐系统]]></title>
    <url>%2F2019%2F11%2F25%2Fleetcode%201268.%20%E6%90%9C%E7%B4%A2%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[题目：给你一个产品数组 products 和一个字符串 searchWord ，products 数组中每个产品都是一个字符串。 请你设计一个推荐系统，在依次输入单词 searchWord 的每一个字母后，推荐 products 数组中前缀与 searchWord 相同的最多三个产品。如果前缀相同的可推荐产品超过三个，请按字典序返回最小的三个。 请你以二维列表的形式，返回在输入 searchWord 每个字母后相应的推荐产品的列表。 示例：示例 1： 输入：products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot; 输出：[ [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;], [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;], [&quot;mouse&quot;,&quot;mousepad&quot;], [&quot;mouse&quot;,&quot;mousepad&quot;], [&quot;mouse&quot;,&quot;mousepad&quot;] ] 解释：按字典序排序后的产品列表是 [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mouse&quot;,&quot;mousepad&quot;] 输入 m 和 mo，由于所有产品的前缀都相同，所以系统返回字典序最小的三个产品 [&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;] 输入 mou， mous 和 mouse 后系统都返回 [&quot;mouse&quot;,&quot;mousepad&quot;] 示例 2： 输入：products = [&quot;havana&quot;], searchWord = &quot;havana&quot; 输出：[[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;],[&quot;havana&quot;]] 示例 3： 输入：products = [&quot;bags&quot;,&quot;baggage&quot;,&quot;banner&quot;,&quot;box&quot;,&quot;cloths&quot;], searchWord = &quot;bags&quot; 输出：[[&quot;baggage&quot;,&quot;bags&quot;,&quot;banner&quot;],[&quot;baggage&quot;,&quot;bags&quot;,&quot;banner&quot;],[&quot;baggage&quot;,&quot;bags&quot;],[&quot;bags&quot;]] 示例 4： 输入：products = [&quot;havana&quot;], searchWord = &quot;tatiana&quot; 输出：[[],[],[],[],[],[],[]] 提示： 1 &lt;= products.length &lt;= 1000 1 &lt;= Σ products[i].length &lt;= 2 * 10^4 products[i] 中所有的字符都是小写英文字母。 1 &lt;= searchWord.length &lt;= 1000searchWord 中所有字符都是小写英文字母。 分析：先字典序排序，使用一个指针指向前缀相同的第一个字符串，然后一个个往下遍历，直到遍历到尾或字符串不同 代码：class Solution { public: vector&lt;vector&lt;string&gt;&gt; suggestedProducts(vector&lt;string&gt;&amp; products, string searchWord) { vector&lt;vector&lt;string&gt;&gt; vvs(searchWord.size()); sort(products.begin(), products.end()); int l = 0; for(int i = 0; i &lt; searchWord.size(); i++){ while(i &gt;= products[l].size() || searchWord.substr(0, i+1) != products[l].substr(0, i+1)){ ++l; if(l == products.size()) return vvs; } for(int j = l, k = 0; k &lt; 3 &amp;&amp; j &lt; products.size(); j++){ if(i &lt; products[j].size() &amp;&amp; searchWord.substr(0, i+1) == products[j].substr(0, i+1)){ k++; vvs[i].push_back(products[j]); } } } return vvs; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-164/problems/search-suggestions-system/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1269. 停在原地的方案数]]></title>
    <url>%2F2019%2F11%2F25%2Fleetcode%201269.%20%E5%81%9C%E5%9C%A8%E5%8E%9F%E5%9C%B0%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。 每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。 给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。 由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。 示例：示例 1： 输入：steps = 3, arrLen = 2 输出：4 解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。 向右，向左，不动 不动，向右，向左 向右，不动，向左 不动，不动，不动 示例 2： 输入：steps = 2, arrLen = 4 输出：2 解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。 向右，向左 不动，不动 示例 3： 输入：steps = 4, arrLen = 2 输出：8 提示： 1 &lt;= steps &lt;= 500 1 &lt;= arrLen &lt;= 10^6 分析：使用dp dp[i][j],第i次操作，停留在位置j dp[i][j] = dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j-1] 代码：class Solution { public: int numWays(int steps, int arrLen) { long dp[steps+1][min(steps+2, arrLen+2)]; memset(dp,0,sizeof(dp)); dp[0][1] = 1; for(int i = 1; i &lt; steps+1; i++){ for(int j = 1; j &lt; min(steps+1, arrLen+1); j++){ dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1] + dp[i-1][j]) % 1000000007; } } return dp[steps][1]; } }; 题目地址:https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1267. 统计参与通信的服务器]]></title>
    <url>%2F2019%2F11%2F25%2Fleetcode%201267.%20%E7%BB%9F%E8%AE%A1%E5%8F%82%E4%B8%8E%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目：这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。 如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。 请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。 示例：示例 1： 输入：grid = [[1,0],[0,1]] 输出：0 解释：没有一台服务器能与其他服务器进行通信。 示例 2： 输入：grid = [[1,0],[1,1]] 输出：3 解释：所有这些服务器都至少可以与一台别的服务器进行通信。 示例 3： 输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]] 输出：4 解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。 提示： m == grid.length n == grid[i].length 1 &lt;= m &lt;= 250 1 &lt;= n &lt;= 250 grid[i][j] == 0 or 1 分析：优先横着遍历，当有两台或以上处于同一列时，计数加1，将已统计的服务器标记，接着竖着遍历，记得不要将已统计的服务器继续计数 代码：class Solution { public: int countServers(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { vector&lt;vector&lt;int&gt;&gt; g = grid; int ret = 0; int first = -1; for(int i = 0; i &lt; g.size(); i++){ for(int j = 0; j &lt; g[0].size(); j++){ if(g[i][j] == 1){ if(first == -1){ first = j; } else{ g[i][j] = 2; if(g[i][first] == 1){ g[i][first] = 2; ret++; } ret++; } } } first = -1; } for(int i = 0; i &lt; g[0].size(); i++){ for(int j = 0; j &lt; g.size(); j++){ if(g[j][i] == 1 || g[j][i] == 2){ if(first == -1){ first = j; } else{ if(g[first][i] == 1){ g[first][i] = 2; ret++; } if(g[j][i] == 1){ g[j][i] = 2; ret++; } } } } first = -1; } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-164]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1266. 访问所有点的最小时间]]></title>
    <url>%2F2019%2F11%2F25%2Fleetcode%201266.%20%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目：平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。 你可以按照下面的规则在平面上移动： 每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。 必须按照数组中出现的顺序来访问这些点。 示例：示例 1： 输入：points = [[1,1],[3,4],[-1,0]] 输出：7 解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0] 从 [1,1] 到 [3,4] 需要 3 秒 从 [3,4] 到 [-1,0] 需要 4 秒 一共需要 7 秒 示例 2： 输入：points = [[3,2],[-2,2]] 输出：5 提示： points.length == n 1 &lt;= n &lt;= 100 points[i].length == 2 -1000 &lt;= points[i][0], points[i][1] &lt;= 1000 分析：因为可以斜着移动，所以优先斜着移动，然后再沿水平或竖直方向移动 代码：class Solution { public: int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) { int ret = 0; for(int i = 1; i &lt; points.size(); i++){ int x = points[i][0] - points[i-1][0]; x = x &gt; 0 ? x : x*-1; int y = points[i][1] - points[i-1][1]; y = y &gt; 0 ? y : y*-1; ret += min(x, y); ret += max(x, y) - min(x, y); } return ret; } }; 题目地址:https://leetcode-cn.com/problems/minimum-time-visiting-all-points/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1263. 推箱子]]></title>
    <url>%2F2019%2F11%2F18%2Fleetcode%201263.%20%E6%8E%A8%E7%AE%B1%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目：「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。 游戏地图用大小为 n * m 的网格 grid 表示，其中每个元素可以是墙、地板或者是箱子。 现在你将作为玩家参与游戏，按规则将箱子 ‘B’ 移动到目标位置 ‘T’ ： 玩家用字符 ‘S’ 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。 地板用字符 ‘.’ 表示，意味着可以自由行走。 墙用字符 ‘#’ 表示，意味着障碍物，不能通行。 箱子仅有一个，用字符 ‘B’ 表示。相应地，网格上有一个目标位置 ‘T’。 玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。玩家无法越过箱子。 返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回 -1。 示例：示例 1： 输入：grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]] 输出：3 解释：我们只需要返回推箱子的次数。 示例 2： 输入：grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;T&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]] 输出：-1 示例 3： 输入：grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;T&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;B&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;S&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]] 输出：5 解释：向下、向左、向左、向上再向上。 示例 4： 输入：grid = [[&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;S&quot;,&quot;#&quot;,&quot;.&quot;,&quot;B&quot;,&quot;T&quot;,&quot;#&quot;], [&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;]] 输出：-1 提示： 1 &lt;= grid.length &lt;= 20 1 &lt;= grid[i].length &lt;= 20 grid 仅包含字符 ‘.’, ‘#’, ‘S’ , ‘T’, 以及 ‘B’。 grid 中 ‘S’, ‘B’ 和 ‘T’ 各只能出现一个。 分析：写两个BFS，一个用来判断人物是否可以走到方块边上，另一个用来判断根据人物方向移动是否可以走到目的地 代码：class Solution { public: vector&lt;int&gt; ren(vector&lt;vector&lt;char&gt;&gt; grid, vector&lt;int&gt; r, vector&lt;int&gt; x){ vector&lt;int&gt; vi(4, 0); // 存储顺序：上下左右 grid[x[0]][x[1]] = &apos;#&apos;; queue&lt;vector&lt;int&gt;&gt; q; map&lt;vector&lt;int&gt;, int&gt; m; q.push(r); while(q.size()){ if(m[q.front()] == 1){ q.pop(); continue; } m[q.front()] = 1; if(q.front()[0] == x[0]-1 &amp;&amp; q.front()[1] == x[1]){ vi[0] = 1; } if(q.front()[0] == x[0]+1 &amp;&amp; q.front()[1] == x[1]){ vi[1] = 1; } if(q.front()[0] == x[0] &amp;&amp; q.front()[1] == x[1]-1){ vi[2] = 1; } if(q.front()[0] == x[0] &amp;&amp; q.front()[1] == x[1]+1){ vi[3] = 1; } if(grid[q.front()[0]-1][q.front()[1]] != &apos;#&apos;){ q.push(vector&lt;int&gt;{q.front()[0]-1, q.front()[1]}); } if(grid[q.front()[0]+1][q.front()[1]] != &apos;#&apos;){ q.push(vector&lt;int&gt;{q.front()[0]+1, q.front()[1]}); } if(grid[q.front()[0]][q.front()[1]-1] != &apos;#&apos;){ q.push(vector&lt;int&gt;{q.front()[0], q.front()[1]-1}); } if(grid[q.front()[0]][q.front()[1]+1] != &apos;#&apos;){ q.push(vector&lt;int&gt;{q.front()[0], q.front()[1]+1}); } q.pop(); } return vi; } int minPushBox(vector&lt;vector&lt;char&gt;&gt;&amp; grid1) { vector&lt;vector&lt;char&gt;&gt; grid(grid1.size()+2, vector&lt;char&gt;(grid1[0].size()+2, &apos;#&apos;)); for(int i = 0; i &lt; grid1.size(); i++){ for(int j = 0; j &lt; grid1[0].size(); j++){ grid[i+1][j+1] = grid1[i][j]; } } vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; vvvi(grid.size()+2, vector&lt;vector&lt;int&gt;&gt;(grid[0].size()+2, vector&lt;int&gt;(4, -1))); queue&lt;vector&lt;int&gt;&gt; q; // 格式：箱子坐标、人的位置（上下左右 对应 0123）、移动次数 vector&lt;int&gt; r(2, 0); vector&lt;int&gt; x(2, 0); for(int i = 0; i &lt; grid.size(); i++){ // 人、箱子的位置 for(int j = 0; j &lt; grid[0].size(); j++){ if(grid[i][j] == &apos;S&apos;){ r[0] = i; r[1] = j; } else if(grid[i][j] == &apos;B&apos;){ x[0] = i; x[1] = j; } } } vector&lt;int&gt; tmp = ren(grid, r, x); for(int i = 0; i &lt; 4; i++){ if(tmp[i] == 1) q.push(vector&lt;int&gt;{x[0], x[1], i, 0}); } while(q.size()){ if(vvvi[q.front()[0]][q.front()[1]][q.front()[2]] != -1){ // 判断是否已经有记录 q.pop(); continue; } if(grid[q.front()[0]][q.front()[1]] == &apos;T&apos;){ // 判断是否到达目的地 return q.front()[3]; } vvvi[q.front()[0]][q.front()[1]][q.front()[2]] = q.front()[3]; // 记录 // 小人可以移动到的位置 vector&lt;int&gt; tmp; if(q.front()[2] == 0){ tmp = ren(grid, vector&lt;int&gt;{q.front()[0]-1, q.front()[1]}, vector&lt;int&gt;{q.front()[0], q.front()[1]}); } else if(q.front()[2] == 1){ tmp = ren(grid, vector&lt;int&gt;{q.front()[0]+1, q.front()[1]}, vector&lt;int&gt;{q.front()[0], q.front()[1]}); } else if(q.front()[2] == 2){ tmp = ren(grid, vector&lt;int&gt;{q.front()[0], q.front()[1]-1}, vector&lt;int&gt;{q.front()[0], q.front()[1]}); } else if(q.front()[2] == 3){ tmp = ren(grid, vector&lt;int&gt;{q.front()[0], q.front()[1]+1}, vector&lt;int&gt;{q.front()[0], q.front()[1]}); } for(int i = 0; i &lt; 4; i++){ if(tmp[i] == 1) q.push(vector&lt;int&gt;{q.front()[0], q.front()[1], i, q.front()[3]}); } // 根据小人位置移动方块 if(q.front()[2] == 0 &amp;&amp; grid[q.front()[0]+1][q.front()[1]] != &apos;#&apos;){ q.push(vector{q.front()[0]+1, q.front()[1], q.front()[2], q.front()[3]+1}); } else if(q.front()[2] == 1 &amp;&amp; grid[q.front()[0]-1][q.front()[1]] != &apos;#&apos;){ q.push(vector{q.front()[0]-1, q.front()[1], q.front()[2], q.front()[3]+1}); } else if(q.front()[2] == 2 &amp;&amp; grid[q.front()[0]][q.front()[1]+1] != &apos;#&apos;){ q.push(vector{q.front()[0], q.front()[1]+1, q.front()[2], q.front()[3]+1}); } else if(q.front()[2] == 3 &amp;&amp; grid[q.front()[0]][q.front()[1]-1] != &apos;#&apos;){ q.push(vector{q.front()[0], q.front()[1]-1, q.front()[2], q.front()[3]+1}); } q.pop(); } return -1; } }; 题目地址:https://leetcode-cn.com/problems/minimum-moves-to-move-a-box-to-their-target-location/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1262. 可被三整除的最大和]]></title>
    <url>%2F2019%2F11%2F18%2Fleetcode%201262.%20%E5%8F%AF%E8%A2%AB%E4%B8%89%E6%95%B4%E9%99%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。 示例：示例 1： 输入：nums = [3,6,5,1,8] 输出：18 解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。 示例 2： 输入：nums = [4] 输出：0 解释：4 不能被 3 整除，所以无法选出数字，返回 0。 示例 3： 输入：nums = [1,2,3,4,4] 输出：12 解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。 提示： 1 &lt;= nums.length &lt;= 4 * 10^4 1 &lt;= nums[i] &lt;= 10^4 分析：使用dp dp[i] 存储选取的数字除3余i的值 每遇到一个新的数字，就与dp中的值相加，并更新到合适的位置 代码：class Solution { public: int maxSumDivThree(vector&lt;int&gt;&amp; nums) { vector&lt;int&gt; dp(3, -1); for(int i = 0; i &lt; nums.size(); i++){ int mod = nums[i] % 3; vector&lt;int&gt; vi(3, -1); for(int j = 0; j &lt; 3; j++){ if(dp[j] != -1){ vi[(j + mod) % 3] = dp[j] + nums[i]; } } if(dp[mod] == -1) { dp[mod] = nums[i]; } for(int j = 0; j &lt; 3; j++){ dp[j] = max(dp[j], vi[j]); } } if(dp[0] == -1) return 0; return dp[0]; } }; 题目地址:https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/submissions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1261. 在受污染的二叉树中查找元素]]></title>
    <url>%2F2019%2F11%2F18%2Fleetcode%201261.%20%E5%9C%A8%E5%8F%97%E6%B1%A1%E6%9F%93%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目：给出一个满足下述规则的二叉树： root.val == 0 如果 treeNode.val == x 且 treeNode.left != null，那么 treeNode.left.val == 2 * x + 1 如果 treeNode.val == x 且 treeNode.right != null，那么 treeNode.right.val == 2 * x + 2现在这个二叉树受到「污染」，所有的 treeNode.val 都变成了 -1。 请你先还原二叉树，然后实现 FindElements 类： FindElements(TreeNode* root) 用受污染的二叉树初始化对象，你需要先把它还原。 bool find(int target) 判断目标值 target 是否存在于还原后的二叉树中并返回结果。 示例：示例 1： 输入： [&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;] [[[-1,null,-1]],[1],[2]] 输出： [null,false,true] 解释： FindElements findElements = new FindElements([-1,null,-1]); findElements.find(1); // return False findElements.find(2); // return True 示例 2： 输入： [&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;] [[[-1,-1,-1,-1,-1]],[1],[3],[5]] 输出： [null,true,true,false] 解释： FindElements findElements = new FindElements([-1,-1,-1,-1,-1]); findElements.find(1); // return True findElements.find(3); // return True findElements.find(5); // return False 示例 3： 输入： [&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;] [[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]] 输出： [null,true,false,false,true] 解释： FindElements findElements = new FindElements([-1,null,-1,-1,null,-1]); findElements.find(2); // return True findElements.find(3); // return False findElements.find(4); // return False findElements.find(5); // return True 提示： TreeNode.val == -1 二叉树的高度不超过 20 节点的总数在 [1, 10^4] 之间 调用 find() 的总次数在 [1, 10^4] 之间 0 &lt;= target &lt;= 10^6 分析：dfs计算二叉树，计算过程中将结点值通过map记录，find查询时，通过map判断是否出现过 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class FindElements { private: map&lt;int,int&gt; mi; public: void dfs(TreeNode* root){ if(root-&gt;left != NULL){ root-&gt;left-&gt;val = root-&gt;val * 2 + 1; mi[root-&gt;left-&gt;val] = 1; dfs(root-&gt;left); } if(root-&gt;right != NULL){ root-&gt;right-&gt;val = root-&gt;val * 2 + 2; mi[root-&gt;right-&gt;val] = 1; dfs(root-&gt;right); } } FindElements(TreeNode* root) { root-&gt;val = 0; mi[0] = 1; dfs(root); } bool find(int target) { if(mi[target] == 1) return true; return false; } }; /** * Your FindElements object will be instantiated and called as such: * FindElements* obj = new FindElements(root); * bool param_1 = obj-&gt;find(target); */ 题目地址:https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree/submissions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1260. 二维网格迁移]]></title>
    <url>%2F2019%2F11%2F18%2Fleetcode%201260.%20%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[题目：给你一个 n 行 m 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。 每次「迁移」操作将会引发下述活动： 位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。 位于 grid[i][m - 1] 的元素将会移动到 grid[i + 1][0]。 位于 grid[n - 1][m - 1] 的元素将会移动到 grid[0][0]。请你返回 k 次迁移操作后最终得到的 二维网格。 示例：示例 1： 输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 输出：[[9,1,2],[3,4,5],[6,7,8]] 示例 2： 输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] 示例 3： 输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 输出：[[1,2,3],[4,5,6],[7,8,9]] 提示： 1 &lt;= grid.length &lt;= 50 1 &lt;= grid[i].length &lt;= 50 -1000 &lt;= grid[i][j] &lt;= 1000 0 &lt;= k &lt;= 100 分析：使用一个一维数组作为临时存储，按照题目要求移动 代码：class Solution { public: vector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) { vector&lt;vector&lt;int&gt;&gt; vvi = grid; for(int i = 0; i &lt; k; i++){ vector&lt;int&gt; vi; for(int j = 0; j &lt; grid.size(); j++){ vi.push_back(vvi[j][vvi[0].size()-1]); } for(int j = 0; j &lt; grid.size(); j++){ for(int k = grid[0].size()-2; k &gt;= 0; k--){ vvi[j][k+1] = vvi[j][k]; } } for(int j = 1; j &lt; grid.size(); j++){ vvi[j][0] = vi[j-1]; } vvi[0][0] = vi[vi.size()-1]; } return vvi; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-163/submissions/detail/36845154/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1255. 得分最高的单词集合]]></title>
    <url>%2F2019%2F11%2F11%2Fleetcode%201255.%20%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[题目：你将会得到一份单词表 words，一个字母表 letters （可能会有重复字母），以及每个字母对应的得分情况表 score。 请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。 单词拼写游戏的规则概述如下： 玩家需要用字母表 letters 里的字母来拼写单词表 words 中的单词。 可以只使用字母表 letters 中的部分字母，但是每个字母最多被使用一次。 单词表 words 中每个单词只能计分（使用）一次。 根据字母得分情况表score，字母 ‘a’, ‘b’, ‘c’, … , ‘z’ 对应的得分分别为 score[0], score[1], …, score[25]。 本场游戏的「得分」是指：玩家所拼写出的单词集合里包含的所有字母的得分之和。 示例：示例 1： 输入：words = [&quot;dog&quot;,&quot;cat&quot;,&quot;dad&quot;,&quot;good&quot;], letters = [&quot;a&quot;,&quot;a&quot;,&quot;c&quot;,&quot;d&quot;,&quot;d&quot;,&quot;d&quot;,&quot;g&quot;,&quot;o&quot;,&quot;o&quot;], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0] 输出：23 解释： 字母得分为 a=1, c=9, d=5, g=3, o=2 使用给定的字母表 letters，我们可以拼写单词 &quot;dad&quot; (5+1+5)和 &quot;good&quot; (3+2+2+5)，得分为 23 。 而单词 &quot;dad&quot; 和 &quot;dog&quot; 只能得到 21 分。 示例 2： 输入：words = [&quot;xxxz&quot;,&quot;ax&quot;,&quot;bx&quot;,&quot;cx&quot;], letters = [&quot;z&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;x&quot;,&quot;x&quot;,&quot;x&quot;], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10] 输出：27 解释： 字母得分为 a=4, b=4, c=4, x=5, z=10 使用给定的字母表 letters，我们可以组成单词 &quot;ax&quot; (4+5)， &quot;bx&quot; (4+5) 和 &quot;cx&quot; (4+5) ，总得分为 27 。 单词 &quot;xxxz&quot; 的得分仅为 25 。 示例 3： 输入：words = [&quot;leetcode&quot;], letters = [&quot;l&quot;,&quot;e&quot;,&quot;t&quot;,&quot;c&quot;,&quot;o&quot;,&quot;d&quot;], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0] 输出：0 解释： 字母 &quot;e&quot; 在字母表 letters 中只出现了一次，所以无法组成单词表 words 中的单词。 提示： 1 &lt;= words.length &lt;= 14 1 &lt;= words[i].length &lt;= 15 1 &lt;= letters.length &lt;= 100 letters[i].length == 1 score.length == 26 0 &lt;= score[i] &lt;= 10 words[i] 和 letters[i] 只包含小写的英文字母。 代码：class Solution { private: int ret; public: void dg(vector&lt;vector&lt;int&gt;&gt;&amp; w, vector&lt;int&gt; c, vector&lt;int&gt;&amp; vi, int z, int fen){ if(z == w.size()){ // 退出条件 if(ret &lt; fen) ret = fen; return; } vector&lt;int&gt; c1 = c; for(int i = 0; i &lt; 26; i++){ // 计算字符数量是否够组成字符串 if(c1[i] - w[z][i] &gt;= 0){ c1[i] -= w[z][i]; } else{ dg(w, c, vi, z+1, fen); return; } } dg(w, c1, vi, z+1, fen+vi[z]); // 两条分支，选或不选 dg(w, c, vi, z+1, fen); } int maxScoreWords(vector&lt;string&gt;&amp; words, vector&lt;char&gt;&amp; letters, vector&lt;int&gt;&amp; score) { vector&lt;int&gt; vi(words.size(), 0); // 每个字符串的分值 vector&lt;vector&lt;int&gt;&gt; w(words.size(), vector&lt;int&gt;(26, 0)); // words数组中各个字符的数量 vector&lt;int&gt; c(26, 0); // 拥有字符的数量 ret = 0; for(int i = 0; i &lt; words.size(); i++){ // 计算分值和字符的数量 for(int j = 0; j &lt; words[i].size(); j++){ vi[i] += score[words[i][j]-&apos;a&apos;]; w[i][words[i][j] - &apos;a&apos;]++; } } for(int i = 0; i &lt; letters.size(); i++){ // 计算拥有字符的数量 c[letters[i]-&apos;a&apos;]++; } dg(w, c, vi, 0, 0); return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-162/problems/maximum-score-words-formed-by-letters/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1254. 统计封闭岛屿的数目]]></title>
    <url>%2F2019%2F11%2F11%2Fleetcode%201254.%20%E7%BB%9F%E8%AE%A1%E5%B0%81%E9%97%AD%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：有一个二维矩阵 grid ，每个位置要么是陆地（记号为 0 ）要么是水域（记号为 1 ）。 我们从一块陆地出发，每次可以往上下左右 4 个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。 如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。 请返回封闭岛屿的数目。 示例：示例 1： 输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] 输出：2 解释： 灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。 示例 2： 输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]] 输出：1 示例 3： 输入：grid = [[1,1,1,1,1,1,1], [1,0,0,0,0,0,1], [1,0,1,1,1,0,1], [1,0,1,0,1,0,1], [1,0,1,1,1,0,1], [1,0,0,0,0,0,1], [1,1,1,1,1,1,1]] 输出：2 提示： 1 &lt;= grid.length, grid[0].length &lt;= 100 0 &lt;= grid[i][j] &lt;=1 分析：使用dfs，从每个0开始深搜，便利过就修改为2，不要重复遍历，找到被包围的块即可 代码：class Solution { private: bool b; public: void dg(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y){ grid[x][y] = 2; if(x + 1 == grid.size()){ b = false; } else if(grid[x+1][y] != 1 &amp;&amp; grid[x+1][y] != 2){ dg(grid, x+1, y); } if(x - 1 == -1){ b = false; } else if(grid[x-1][y] != 1 &amp;&amp; grid[x-1][y] != 2){ dg(grid, x-1, y); } if(y + 1 == grid[0].size()){ b = false; } else if(grid[x][y+1] != 1 &amp;&amp; grid[x][y+1] != 2){ dg(grid, x, y+1); } if(y - 1 == -1){ b = false; } else if(grid[x][y-1] != 1 &amp;&amp; grid[x][y-1] != 2){ dg(grid, x, y-1); } } int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int ret = 0; b = true; for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ if(grid[i][j] == 0){ dg(grid, i, j); if(b) ret++; b = true; } } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-162/problems/number-of-closed-islands/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1253. 重构 2 行二进制矩阵]]></title>
    <url>%2F2019%2F11%2F11%2Fleetcode%201253.%20%E9%87%8D%E6%9E%84%202%20%E8%A1%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目：给你一个 2 行 n 列的二进制数组： 矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 0 就是 1。 第 0 行的元素之和为 upper。 第 1 行的元素之和为 lower。 第 i 列（从 0 开始编号）的元素之和为 colsum[i]，colsum 是一个长度为 n 的整数数组。你需要利用 upper，lower 和 colsum 来重构这个矩阵，并以二维整数数组的形式返回它。 如果有多个不同的答案，那么任意一个都可以通过本题。 如果不存在符合要求的答案，就请返回一个空的二维数组。 示例：示例 1： 输入：upper = 2, lower = 1, colsum = [1,1,1] 输出：[[1,1,0],[0,0,1]] 解释：[[1,0,1],[0,1,0]] 和 [[0,1,1],[1,0,0]] 也是正确答案。 示例 2： 输入：upper = 2, lower = 3, colsum = [2,2,1,1] 输出：[] 示例 3： 输入：upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1] 输出：[[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]] 提示： 1 &lt;= colsum.length &lt;= 10^5 0 &lt;= upper, lower &lt;= colsum.length 0 &lt;= colsum[i] &lt;= 2 代码：class Solution { public: vector&lt;vector&lt;int&gt;&gt; reconstructMatrix(int upper, int lower, vector&lt;int&gt;&amp; colsum) { vector&lt;vector&lt;int&gt;&gt; vvi(2, vector&lt;int&gt;(colsum.size(), 0)); // 初始化 for(int i = 0; i &lt; colsum.size(); i++){ // 将一列加起来等于2的填入 if(colsum[i] == 2){ upper--; lower--; vvi[0][i] = 1; vvi[1][i] = 1; if(upper &lt; 0 || lower &lt; 0) // 值不匹配返回空 return vector&lt;vector&lt;int&gt;&gt;(); } } for(int i = 0; i &lt; colsum.size(); i++){ // 将剩下一列加起来等于1的先填入上面一行，填满后填入下面一行 if(colsum[i] == 1){ if(upper &gt; 0){ upper--; vvi[0][i] = 1; } else if(lower &gt; 0){ lower--; vvi[1][i] = 1; } else{ return vector&lt;vector&lt;int&gt;&gt;(); // 值不匹配返回空 } } } if(upper &gt; 0 || lower &gt; 0) return vector&lt;vector&lt;int&gt;&gt;(); // 还有剩余返回空 return vvi; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-162/problems/reconstruct-a-2-row-binary-matrix/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1252. 奇数值单元格的数目]]></title>
    <url>%2F2019%2F11%2F11%2Fleetcode%201252.%20%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个 n 行 m 列的矩阵，最开始的时候，每个单元格中的值都是 0。 另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。 你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。 请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。 示例：示例 1： 输入：n = 2, m = 3, indices = [[0,1],[1,1]] 输出：6 解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。 第一次增量操作后得到 [[1,2,1],[0,1,0]]。 最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。 示例 2： 输入：n = 2, m = 2, indices = [[1,1],[0,0]] 输出：0 解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。 提示： 1 &lt;= n &lt;= 50 1 &lt;= m &lt;= 50 1 &lt;= indices.length &lt;= 100 0 &lt;= indices[i][0] &lt; n 0 &lt;= indices[i][1] &lt; m 分析：遍历indices，将所指的行和列加1 最后遍历数组找到奇数的数量即可 代码：class Solution { public: int oddCells(int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; indices) { vector&lt;vector&lt;int&gt;&gt; vvi(n, vector&lt;int&gt;(m, 0)); for(int i = 0; i &lt; indices.size(); i++){ for(int j = 0; j &lt; m; j++){ vvi[indices[i][0]][j]++; } for(int j = 0; j &lt; n; j++){ vvi[j][indices[i][1]]++; } } int ret = 0; for(int i = 0; i &lt; vvi.size(); i++){ for(int j = 0; j &lt; vvi[0].size(); j++){ if(vvi[i][j] % 2 == 1){ ret++; } } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-162/problems/cells-with-odd-values-in-a-matrix/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1250. 检查「好数组」]]></title>
    <url>%2F2019%2F10%2F28%2Fleetcode%201250.%20%E6%A3%80%E6%9F%A5%E3%80%8C%E5%A5%BD%E6%95%B0%E7%BB%84%E3%80%8D%2F</url>
    <content type="text"><![CDATA[题目：给你一个正整数数组 nums，你需要从中任选一些子集，然后将子集中每一个数乘以一个 任意整数，并求出他们的和。 假如该和结果为 1，那么原数组就是一个「好数组」，则返回 True；否则请返回 False。 示例：示例 1： 输入：nums = [12,5,7,23] 输出：true 解释：挑选数字 5 和 7。 5*3 + 7*(-2) = 1 示例 2： 输入：nums = [29,6,10] 输出：true 解释：挑选数字 29, 6 和 10。 29*1 + 6*(-3) + 10*(-1) = 1 示例 3： 输入：nums = [3,6] 输出：false 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^9 分析：数学题，用到裴蜀定理 定理：对于给定的正整数a，b，方程ax+by=c有解的充要条件为c是gcd（a，b）的整数倍 证明：假设a和b有最大公因数2a*x+b*y=c必定还有一个2*(a&#39;*x+b&#39;*y)=c, 2 不可能乘以一个整数得到 1 所以，找到最大公因数为1的两个数即可 代码：class Solution { public: int gcd(int a, int b){ if(a % b == 0) return b; else return gcd(b, a%b); } bool isGoodArray(vector&lt;int&gt;&amp; nums) { int z = nums[0]; for(int i = 1; i &lt; nums.size(); i++){ z = gcd(z, nums[i]); } if(z == 1){ return true; } return false; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-161/problems/check-if-it-is-a-good-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1249. 移除无效的括号]]></title>
    <url>%2F2019%2F10%2F28%2Fleetcode%201249.%20%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目：给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。 你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。 请返回任意一个合法字符串。 有效「括号字符串」应当符合以下 任意一条 要求： 空字符串或只包含小写字母的字符串 可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」 可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」 示例：示例 1： 输入：s = &quot;lee(t(c)o)de)&quot; 输出：&quot;lee(t(c)o)de&quot; 解释：&quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; 也是一个可行答案。 示例 2： 输入：s = &quot;a)b(c)d&quot; 输出：&quot;ab(c)d&quot; 示例 3： 输入：s = &quot;))((&quot; 输出：&quot;&quot; 解释：空字符串也是有效的 示例 4： 输入：s = &quot;(a(b(c)d)&quot; 输出：&quot;a(b(c)d)&quot; 提示： 1 &lt;= s.length &lt;= 10^5 s[i] 可能是 ‘(‘、’)’ 或英文小写字母 分析：使用栈来寻找非法括号 一个栈用来记录栈中左括号的位置 一个栈用来记录非法右括号的位置 最后去掉两个栈中标记的括号即可 代码：class Solution { public: string minRemoveToMakeValid(string s) { string str = &quot;&quot;; vector&lt;int&gt; vi1; vector&lt;int&gt; vi2; vector&lt;int&gt; vi3; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == &apos;(&apos;){ vi1.push_back(0); vi2.push_back(i); } else if(s[i] == &apos;)&apos;){ if(vi1.size() &gt; 0){ vi1.pop_back(); vi2.pop_back(); } else{ vi3.push_back(i); } } } int v2 = 0; int v3 = 0; for(int i = 0; i &lt; s.size(); i++){ if(v2 &lt; vi2.size() &amp;&amp; vi2[v2] == i){ v2++; } else if(v3 &lt; vi3.size() &amp;&amp; vi3[v3] == i) { v3++; } else{ str += s[i]; } } return str; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-161/problems/minimum-remove-to-make-valid-parentheses/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1248. 统计「优美子数组」]]></title>
    <url>%2F2019%2F10%2F28%2Fleetcode%201248.%20%E7%BB%9F%E8%AE%A1%E3%80%8C%E4%BC%98%E7%BE%8E%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%8D%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums 和一个整数 k。 如果某个子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。 请返回这个数组中「优美子数组」的数目。 示例：示例 1： 输入：nums = [1,1,2,1,1], k = 3 输出：2 解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。 示例 2： 输入：nums = [2,4,6], k = 1 输出：0 解释：数列中不包含任何奇数，所以不存在优美子数组。 示例 3： 输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2 输出：16 提示： 1 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10^5 1 &lt;= k &lt;= nums.length 分析：统计每个奇数左侧和右侧偶数的数量 每一个子数组的组成方式为（左侧偶数+1）*（右侧偶数+1） 代码：class Solution { public: int numberOfSubarrays(vector&lt;int&gt;&amp; nums, int k) { vector&lt;vector&lt;int&gt;&gt; vvi; int count = 0; int l = 0; int r = 0; int ret = 0; for(int i = 0; i &lt; nums.size(); i++){ if(nums[i] % 2 == 0){ count++; } else{ vvi.push_back(vector&lt;int&gt;{count, 0}); if(vvi.size() != 1){ vvi[vvi.size()-2][1] = count; } count = 0; } } if(count == nums.size()) return 0; vvi[vvi.size()-1][1] = count; while(r != vvi.size()){ if(r - l + 1 == k){ ret += (vvi[l][0]+1) * (vvi[r][1]+1); r++; } else if(r - l + 1 &lt; k){ r++; } else{ l++; } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-161/problems/count-number-of-nice-subarrays/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5241. 铺瓷砖]]></title>
    <url>%2F2019%2F10%2F28%2Fleetcode%205241.%20%E9%93%BA%E7%93%B7%E7%A0%96%2F</url>
    <content type="text"><![CDATA[题目：你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。 房子的客厅大小为 n x m，为保持极简的风格，需要使用尽可能少的 正方形 瓷砖来铺盖地面。 假设正方形瓷砖的规格不限，边长都是整数。 请你帮设计师计算一下，最少需要用到多少块方形瓷砖？ 示例：示例 1： 输入：n = 2, m = 3 输出：3 解释：3 块地砖就可以铺满卧室。 2 块 1x1 地砖 1 块 2x2 地砖 示例 2： 输入：n = 5, m = 8 输出：5 示例 3： 输入：n = 11, m = 13 输出：6 提示： 1 &lt;= n &lt;= 13 1 &lt;= m &lt;= 13 分析：直接打表，或者使用dp，每次将一个长方形分成两个长方形，但是会有特例，如13*11 代码：class Solution { public: int tilingRectangle(int n, int m) { int a[13][13] = { {1}, {2,1}, {3,3,1}, {4,2,4,1}, {5,4,4,5,1}, {6,3,2,3,5,1}, {7,5,5,5,5,5,1}, {8,4,5,2,5,4,7,1}, {9,6,3,6,6,3,6,7,1}, {10,5,6,4,2,4,6,5,6,1}, {11,7,6,6,6,6,6,6,7,6,1}, {12,6,4,3,6,2,6,3,4,5,7,1}, {13,8,7,7,6,6,6,6,7,7,6,7,1} }; int x; int y; x = max(n, m); y = min(n, m); return a[x-1][y-1]; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-160/problems/tiling-a-rectangle-with-the-fewest-squares/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1247. 交换字符使得字符串相同]]></title>
    <url>%2F2019%2F10%2F28%2Fleetcode%201247.%20%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%BE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C%2F</url>
    <content type="text"><![CDATA[题目：有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 “x” 和 “y”，你需要通过「交换字符」的方式使这两个字符串相同。 每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。 交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。 最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。 示例：示例 1： 输入：s1 = &quot;xx&quot;, s2 = &quot;yy&quot; 输出：1 解释： 交换 s1[0] 和 s2[1]，得到 s1 = &quot;yx&quot;，s2 = &quot;yx&quot;。 示例 2： 输入：s1 = &quot;xy&quot;, s2 = &quot;yx&quot; 输出：2 解释： 交换 s1[0] 和 s2[0]，得到 s1 = &quot;yy&quot;，s2 = &quot;xx&quot; 。 交换 s1[0] 和 s2[1]，得到 s1 = &quot;xy&quot;，s2 = &quot;xy&quot; 。 注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 &quot;yx&quot;，因为我们只能交换属于两个不同字符串的字符。 示例 3： 输入：s1 = &quot;xx&quot;, s2 = &quot;xy&quot; 输出：-1 示例 4： 输入：s1 = &quot;xxyyxyxyxx&quot;, s2 = &quot;xyyxyxxxyx&quot; 输出：4 提示： 1 &lt;= s1.length, s2.length &lt;= 1000 s1, s2 只包含 ‘x’ 或 ‘y’。 代码：class Solution { public: int minimumSwap(string s1, string s2) { int x = 0; int y = 0; int ret = 0; for(int i = 0; i &lt; s1.size(); i++){ // 统计不相等时s1字符串x和y的数量 if(s1[i] != s2[i]){ if(s1[i] == &apos;x&apos;) x++; else y++; } } if((x+y) % 2 == 1) // 如果两种字符数量相加不是偶数返回-1 return -1; ret = x/2 + y/2; // 将一个x或y换到对面，就相当于同时让另一组x或y满足条件 if(x % 2 == 1) // 剩下的yx和xy需要两步才可以满足条件 ret += 2; return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-161/problems/minimum-swaps-to-make-strings-equal/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5240. 串联字符串的最大长度]]></title>
    <url>%2F2019%2F10%2F28%2Fleetcode%205240.%20%E4%B8%B2%E8%81%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目：给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。 请返回所有可行解 s 中最长长度。 示例：示例 1： 输入：arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;] 输出：4 解释：所有可能的串联组合是 &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; 和 &quot;ique&quot;，最大长度为 4。 示例 2： 输入：arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;] 输出：6 解释：可能的解答有 &quot;chaers&quot; 和 &quot;acters&quot;。 示例 3： 输入：arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;] 输出：26 提示： 1 &lt;= arr.length &lt;= 16 1 &lt;= arr[i].length &lt;= 26 arr[i] 中只含有小写英文字母 分析：将字符串按位转换成数字，用来判断两个字符串之间是否有相等的字符 每个字符串都有选或不选两种可能，复杂度为2^16。直接递归解决 代码：class Solution { private: int m; public: void dg(vector&lt;int&gt; a, int x, int c){ for(int i = c; i &lt; a.size(); i++){ if((x &amp; a[i]) == 0 &amp;&amp; a[i] != 0){ int z = 0; z = (x | a[i]); dg(a, z, i+1); } } int r = 0; for(int i = 0; i &lt; 26; i++){ r = r + x % 2; x /= 2; } if(m &lt; r) m = r; } int maxLength(vector&lt;string&gt;&amp; arr) { vector&lt;int&gt; a(arr.size(), 0); m = 0; for(int i = 0; i &lt; arr.size(); i++){ for(int j = 0; j &lt; arr[i].size(); j++){ int z = 1; z = z &lt;&lt; (arr[i][j] - &apos;a&apos;); if((a[i] &amp; z) != 0){ a[i] = 0; break; } a[i] |= z; } } dg(a, 0, 0); return m; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-160/problems/maximum-length-of-a-concatenated-string-with-unique-characters/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5239. 循环码排列]]></title>
    <url>%2F2019%2F10%2F28%2Fleetcode%205239.%20%E5%BE%AA%E7%8E%AF%E7%A0%81%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,,…,2^n-1) 的排列 p，并且满足： p[0] = start p[i] 和 p[i+1] 的二进制表示形式只有一位不同 p[0] 和 p[2^n -1] 的二进制表示形式也只有一位不同 示例：示例 1： 输入：n = 2, start = 3 输出：[3,2,0,1] 解释：这个排列的二进制表示是 (11,10,00,01) 所有的相邻元素都有一位是不同的，另一个有效的排列是 [3,1,0,2] 示例 2： 输出：n = 3, start = 2 输出：[2,6,7,5,4,0,1,3] 解释：这个排列的二进制表示是 (010,110,111,101,100,000,001,011) 提示： 1 &lt;= n &lt;= 16 0 &lt;= start &lt; 2^n 分析：这个就是格雷码 格雷码的生成方法： 1位格雷码有两个码字 (n+1)位格雷码中的前2^n个码字等于n位格雷码的码字，按顺序书写，加前缀0 (n+1)位格雷码中的后2^n个码字等于n位格雷码的码字，按逆序书写，加前缀1 n+1位格雷码的集合 = n位格雷码集合(顺序)加前缀0 + n位格雷码集合(逆序)加前缀1 最后在将所要求的start放在第一个即可 代码：class Solution { public: vector&lt;int&gt; circularPermutation(int n, int start) { vector&lt;int&gt; vi{0, 1}; vector&lt;int&gt; ret; for(int i = 1; i &lt; n; i++){ for(int j = vi.size()-1; j &gt;= 0; j--){ int z = 1; z = z &lt;&lt; i; vi.push_back(vi[j] | z); } } for(int i = 0; i &lt; vi.size(); i++){ if(vi[i] == start){ ret.insert(ret.end(), vi.begin()+i, vi.end()); ret.insert(ret.end(), vi.begin(), vi.begin()+i); break; } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-160/problems/circular-permutation-in-binary-representation/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5238. 找出给定方程的正整数解]]></title>
    <url>%2F2019%2F10%2F28%2Fleetcode%205238.%20%E6%89%BE%E5%87%BA%E7%BB%99%E5%AE%9A%E6%96%B9%E7%A8%8B%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题目：给出一个函数 f(x, y) 和一个目标结果 z，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。 给定函数是严格单调的，也就是说： f(x, y) &lt; f(x + 1, y)f(x, y) &lt; f(x, y + 1)函数接口定义如下： interface CustomFunction { public: // Returns positive integer f(x, y) for any given positive integer x and y. int f(int x, int y); }; 如果你想自定义测试，你可以输入整数 function_id 和一个目标结果 z 作为输入，其中 function_id 表示一个隐藏函数列表中的一个函数编号，题目只会告诉你列表中的 2 个函数。 你可以将满足条件的 结果数对 按任意顺序返回。 示例：示例 1： 输入：function_id = 1, z = 5 输出：[[1,4],[2,3],[3,2],[4,1]] 解释：function_id = 1 表示 f(x, y) = x + y 示例 2： 输入：function_id = 2, z = 5 输出：[[1,5],[5,1]] 解释：function_id = 2 表示 f(x, y) = x * y 提示： 1 &lt;= function_id &lt;= 9 1 &lt;= z &lt;= 100 题目保证 f(x, y) == z 的解处于 1 &lt;= x, y &lt;= 1000 的范围内。 在 1 &lt;= x, y &lt;= 1000 的前提下，题目保证 f(x, y) 是一个 32 位有符号整数。 分析：先将x加到&gt;=z的时候。 如果结果&lt;z，y++ 如果结果==z，将x和y记录下来，y++ 如果结果&lt;z,x– 循环直到x==0结束 代码：/* * // This is the custom function interface. * // You should not implement it, or speculate about its implementation * class CustomFunction { * public: * // Returns f(x, y) for any given positive integers x and y. * // Note that f(x, y) is increasing with respect to both x and y. * // i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1) * int f(int x, int y); * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; findSolution(CustomFunction&amp; customfunction, int z) { int x = 1; int y = 1; vector&lt;vector&lt;int&gt;&gt; vvi; while(customfunction.f(x, y) &lt; z){ cout &lt;&lt; &quot;!&quot;; x++; } while(x != 0){ if(customfunction.f(x, y) &lt; z){ y++; } else if(customfunction.f(x, y) == z){ vvi.push_back(vector&lt;int&gt;{x, y}); y++; } else{ x--; } } return vvi; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-160/problems/find-positive-integer-solution-for-a-given-equation/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5225. 最大相等频率]]></title>
    <url>%2F2019%2F10%2F14%2Fleetcode%205225.%20%E6%9C%80%E5%A4%A7%E7%9B%B8%E7%AD%89%E9%A2%91%E7%8E%87%2F</url>
    <content type="text"><![CDATA[题目：给出一个正整数数组 nums，请你帮忙从该数组中找出能满足下面要求的 最长 前缀，并返回其长度： 从前缀中 删除一个 元素后，使得所剩下的每个数字的出现次数相同。如果删除这个元素后没有剩余元素存在，仍可认为每个数字都具有相同的出现次数（也就是 0 次）。 示例：示例 1： 输入：nums = [2,2,1,1,5,3,3,5] 输出：7 解释：对于长度为 7 的子数组 [2,2,1,1,5,3,3]，如果我们从中删去 nums[4]=5，就可以得到 [2,2,1,1,3,3]，里面每个数字都出现了两次。 示例 2： 输入：nums = [1,1,1,2,2,2,3,3,3,4,4,4,5] 输出：13 示例 3： 输入：nums = [1,1,1,2,2,2] 输出：5 示例 4： 输入：nums = [10,2,8,9,3,8,1,5,2,3,7,6] 输出：8 提示： 2 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^5 分析：从左侧遍历，每添加一个数，有三种可能满足条件 所有数的数量相等，进入一个新的数 进入一个新的数后，有一个数数量为1，别的数相等 进入一个新的数后，有一个数数量比别的多1，别的相等 需要六个变量 zuida，储存着出现次数最多的那个值的数量和次数 dier，存储着出现次数第二多的那个值的数量和次数 wei1，存储着出现次数只有1的值的数量 ret，存储着满足要求的最长字符串长度 yiyou，存储着已经出现过的数的种类的数量 m[i]，存储着i这个值出现的次数 代码：class Solution { public: int maxEqualFreq(vector&lt;int&gt;&amp; nums) { int zuida[2] = {-1, 0}; int dier[2] = {-1, 0}; int wei1 = 0; int ret = 0; int yiyou = 0; map&lt;int, int&gt; m; for(int i = 0; i &lt; nums.size(); i++){ m[nums[i]]++; if(yiyou == zuida[1]){ // 所有数的数量相等，进入一个新的数 ret = i+1; } if(m[nums[i]] &gt; zuida[0]){ if(zuida[1] &gt; 1){ dier[0] = zuida[0]; dier[1] = zuida[1]; } zuida[0] = m[nums[i]]; zuida[1] = 1; } else if(m[nums[i]] == zuida[0]){ zuida[1]++; } if(m[nums[i]] &lt; zuida[0] &amp;&amp; m[nums[i]] &gt; dier[0]){ dier[0] = m[nums[i]]; dier[1] = 1; } else if(m[nums[i]] == dier[0]){ dier[1]++; } if(m[nums[i]] == zuida[0] &amp;&amp; zuida[0]-1 == dier[0]){ dier[1]--; } if(m[nums[i]] == 1){ yiyou++; wei1++; } else if(m[nums[i]] == 2){ wei1--; } if(wei1 == 1 &amp;&amp; zuida[1] == yiyou-1){ // 有一个数数量为1，别的数相等 ret = i+1; } if(zuida[1] == 1 &amp;&amp; dier[1] == yiyou-1 &amp;&amp; zuida[0] - 1 == dier[0]){ // 有一个数数量比别的多1，别的相等 ret = i+1; } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-158/problems/maximum-equal-frequency/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5224. 掷骰子模拟]]></title>
    <url>%2F2019%2F10%2F14%2Fleetcode%205224.%20%E6%8E%B7%E9%AA%B0%E5%AD%90%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[题目：有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。 不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。 现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。 假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。 示例：示例 1： 输入：n = 2, rollMax = [1,1,2,2,2,3] 输出：34 解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。 示例 2： 输入：n = 2, rollMax = [1,1,1,1,1,1] 输出：30 示例 3： 输入：n = 3, rollMax = [1,1,1,2,2,3] 输出：181 提示： 1 &lt;= n &lt;= 5000 rollMax.length == 6 1 &lt;= rollMax[i] &lt;= 15 分析：动态规划 dp[i][j][l], i表示掷的第i颗骰子，j表示最后一颗骰子的值，l表示最后一颗骰子的值重复出现次数 代码：class Solution { public: int dieSimulator(int n, vector&lt;int&gt;&amp; rollMax) { int dp[n][6][20]; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; 6; i++){ // 初始化一颗骰子的六种情况 dp[0][i][1] = 1; } for(int i = 1; i &lt; n; i++){ // 掷的第i颗骰子 for(int j = 0; j &lt; 6; j++){ // 最后一颗骰子的值 for(int k = 0; k &lt; 6; k++){ // 新的骰子的值 if(j == k){ // 如果新的骰子和最后一颗骰子一样,就得从2开始，因为之前至少有一颗骰子相等 for(int l = 2; l &lt;= rollMax[j]; l++){ dp[i][k][l] += dp[i-1][k][l-1]; dp[i][k][l] %= 1000000007; } } else{ for(int l = 1; l &lt;= rollMax[j]; l++){ dp[i][k][1] += dp[i-1][j][l]; dp[i][k][1] %= 1000000007; } } } } } int ret = 0; for(int i = 0; i &lt; 6; i++){ // 将掷完骰子的六种结尾的所有可能相加 for(int j = 0; j &lt;= rollMax[i]; j++){ ret += dp[n-1][i][j]; ret %= 1000000007; } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-158/problems/dice-roll-simulation/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5223. 可以攻击国王的皇后]]></title>
    <url>%2F2019%2F10%2F14%2Fleetcode%205223.%20%E5%8F%AF%E4%BB%A5%E6%94%BB%E5%87%BB%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[题目：在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。 「黑皇后」在棋盘上的位置分布用整数坐标数组 queens 表示，「白国王」的坐标用数组 king 表示。 「黑皇后」的行棋规定是：横、直、斜都可以走，步数不受限制，但是，不能越子行棋。 请你返回可以直接攻击到「白国王」的所有「黑皇后」的坐标（任意顺序）。 示例：示例 1： 输入：queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0] 输出：[[0,1],[1,0],[3,3]] 解释： [0,1] 的皇后可以攻击到国王，因为他们在同一行上。 [1,0] 的皇后可以攻击到国王，因为他们在同一列上。 [3,3] 的皇后可以攻击到国王，因为他们在同一条对角线上。 [0,4] 的皇后无法攻击到国王，因为她被位于 [0,1] 的皇后挡住了。 [4,0] 的皇后无法攻击到国王，因为她被位于 [1,0] 的皇后挡住了。 [2,4] 的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。 示例 2： 输入：queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3] 输出：[[2,2],[3,4],[4,4]] 示例 3： 输入：queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4] 输出：[[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]] 提示： 1 &lt;= queens.length &lt;= 63 queens[0].length == 2 0 &lt;= queens[i][j] &lt; 8 king.length == 2 0 &lt;= king[0], king[1] &lt; 8 一个棋盘格上最多只能放置一枚棋子。 分析：直接从王后的八个方向遍历，储存每个方向最近的 代码：class Solution { public: vector&lt;vector&lt;int&gt;&gt; queensAttacktheKing(vector&lt;vector&lt;int&gt;&gt;&amp; queens, vector&lt;int&gt;&amp; king) { vector&lt;vector&lt;int&gt;&gt; ret; map&lt;int, map&lt;int, int&gt;&gt; q; for(int i = 0; i &lt; queens.size(); i++){ q[queens[i][0]][queens[i][1]] = 1; } for(int i = king[0]; i &gt;= 0; i--){ if(q[i][king[1]]){ ret.push_back(vector&lt;int&gt;{i, king[1]}); break; } } for(int i = king[0]; i &lt; 8; i++){ if(q[i][king[1]]){ ret.push_back(vector&lt;int&gt;{i, king[1]}); break; } } for(int i = king[1]; i &gt;= 0; i--){ if(q[king[0]][i]){ ret.push_back(vector&lt;int&gt;{king[0], i}); break; } } for(int i = king[1]; i &lt; 8; i++){ if(q[king[0]][i]){ ret.push_back(vector&lt;int&gt;{king[0], i}); break; } } for(int i = king[0], j = king[1]; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--){ if(q[i][j]){ ret.push_back(vector&lt;int&gt;{i, j}); break; } } for(int i = king[0], j = king[1]; i &gt;= 0 &amp;&amp; j &lt; 8; i--, j++){ if(q[i][j]){ ret.push_back(vector&lt;int&gt;{i, j}); break; } } for(int i = king[0], j = king[1]; i &lt; 8 &amp;&amp; j &gt;= 0; i++, j--){ if(q[i][j]){ ret.push_back(vector&lt;int&gt;{i, j}); break; } } for(int i = king[0], j = king[1]; i &lt; 8 &amp;&amp; j &lt; 8; i++, j++){ if(q[i][j]){ ret.push_back(vector&lt;int&gt;{i, j}); break; } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-158/problems/queens-that-can-attack-the-king/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5222. 分割平衡字符串]]></title>
    <url>%2F2019%2F10%2F14%2Fleetcode%205222.%20%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。 给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。 返回可以通过分割得到的平衡字符串的最大数量。 示例：示例 1： 输入：s = &quot;RLRRLLRLRL&quot; 输出：4 解释：s 可以分割为 &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, 每个子字符串中都包含相同数量的 &apos;L&apos; 和 &apos;R&apos;。 示例 2： 输入：s = &quot;RLLLLRRRLR&quot; 输出：3 解释：s 可以分割为 &quot;RL&quot;, &quot;LLLRRR&quot;, &quot;LR&quot;, 每个子字符串中都包含相同数量的 &apos;L&apos; 和 &apos;R&apos;。 示例 3： 输入：s = &quot;LLLLRRRR&quot; 输出：1 解释：s 只能保持原样 &quot;LLLLRRRR&quot;. 提示： 1 &lt;= s.length &lt;= 1000 s[i] = ‘L’ 或 ‘R’ 分析：声明一个变量，遇到L-1，遇到R+1，当变量为0的时候，返回值加1 代码：class Solution { public: int balancedStringSplit(string s) { int ret = 0; int cnt = 0; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == &apos;L&apos;){ cnt--; } else{ cnt++; } if(cnt == 0){ ret++; } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-158/problems/split-a-string-in-balanced-strings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5208. 穿过迷宫的最少移动次数]]></title>
    <url>%2F2019%2F10%2F03%2Fleetcode%205208.%20%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：你还记得那条风靡全球的贪吃蛇吗？ 我们在一个 n*n 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（(0, 0) 和 (0, 1)）开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（(n-1, n-2) 和 (n-1, n-1)）。 每次移动，蛇可以这样走： 如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（(r, c)、(r, c+1)）移动到 （(r, c)、(r+1, c)）。 如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（(r, c)、(r+1, c)）移动到（(r, c)、(r, c+1)）。 返回蛇抵达目的地所需的最少移动次数。 如果无法到达目的地，请返回 -1。 示例：示例 1： 输入：grid = [[0,0,0,0,0,1], [1,1,0,0,1,0], [0,0,0,0,1,1], [0,0,1,0,1,0], [0,1,1,0,0,0], [0,1,1,0,0,0]] 输出：11 解释： 一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。 示例 2： 输入：grid = [[0,0,1,1,1,1], [0,0,0,0,1,1], [1,1,0,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,1], [1,1,1,0,0,0]] 输出：9 提示： 2 &lt;= n &lt;= 100 0 &lt;= grid[i][j] &lt;= 1 蛇保证从空单元格开始出发。 分析：使用dp dp[i][j][k]。i和j代表蛇尾坐标，k代表蛇的状态 代码：int dp[101][101][2]; class Solution { public: int minimumMoves(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n=grid.size(); memset(dp,0x3f,sizeof(dp)); dp[0][0][0]=0;//初始化除0,0,0的状态其它都是无限大(非法) for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { if(!grid[i][j]) { if(i+1&lt;n &amp;&amp; j+1&lt;n &amp;&amp; !grid[i+1][j] &amp;&amp; !grid[i][j+1] &amp;&amp; !grid[i+1][j+1])//先考虑2X2的情况 { dp[i][j][0]=min(dp[i][j][0],dp[i][j][1]+1); dp[i][j][1]=min(dp[i][j][1],dp[i][j][0]+1); dp[i+1][j][0]=min(dp[i+1][j][0],dp[i][j][0]+1); dp[i][j+1][1]=min(dp[i][j+1][1],dp[i][j][1]+1); } if(j+2&lt;n &amp;&amp; !grid[i][j+1] &amp;&amp; !grid[i][j+2]) { dp[i][j+1][0]=min(dp[i][j+1][0],dp[i][j][0]+1); } if(i+2&lt;n &amp;&amp; !grid[i+1][j] &amp;&amp; !grid[i+2][j]) { dp[i+1][j][1]=min(dp[i+1][j][1],dp[i][j][1]+1); } } } } if(dp[n-1][n-2][0]==0x3f3f3f3f)//如果结果无限大则表示没法到达 { return -1; } else { return dp[n-1][n-2][0]; } } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-156/problems/minimum-moves-to-reach-target-with-rotations/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5206. 删除字符串中的所有相邻重复项 II]]></title>
    <url>%2F2019%2F09%2F30%2Fleetcode%205206.%20%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9%20II%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。 你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。 在执行完所有删除操作后，返回最终得到的字符串。 本题答案保证唯一。 示例：示例 1： 输入：s = &quot;abcd&quot;, k = 2 输出：&quot;abcd&quot; 解释：没有要删除的内容。 示例 2： 输入：s = &quot;deeedbbcccbdaa&quot;, k = 3 输出：&quot;aa&quot; 解释： 先删除 &quot;eee&quot; 和 &quot;ccc&quot;，得到 &quot;ddbbbdaa&quot; 再删除 &quot;bbb&quot;，得到 &quot;dddaa&quot; 最后删除 &quot;ddd&quot;，得到 &quot;aa&quot; 示例 3： 输入：s = &quot;pbbcggttciiippooaais&quot;, k = 2 输出：&quot;ps&quot; 提示： 1 &lt;= s.length &lt;= 10^5 2 &lt;= k &lt;= 10^4 s 中只含有小写英文字母。 分析：循环寻找字符串中重复出现k次的字符，删除。直至遍历一遍后没有删除 代码：class Solution { public: string removeDuplicates(string s, int k) { bool b = true; while(b){ int l = 0; char c = &apos;*&apos;; b = false; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == c){ l++; } else{ l = 1; c = s[i]; } if(l == k){ s.erase(i - k + 1, k); l = 0; c = &apos;*&apos;; b = true; i -= k; } } } return s; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-156/problems/remove-all-adjacent-duplicates-in-string-ii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5207. 尽可能使字符串相等]]></title>
    <url>%2F2019%2F09%2F30%2Fleetcode%205207.%20%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89%2F</url>
    <content type="text"><![CDATA[题目：给你两个长度相同的字符串，s 和 t。 将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。 用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。 如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。 如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。 示例：示例 1： 输入：s = &quot;abcd&quot;, t = &quot;bcdf&quot;, cost = 3 输出：3 解释：s 中的 &quot;abc&quot; 可以变为 &quot;bcd&quot;。开销为 3，所以最大长度为 3。 示例 2： 输入：s = &quot;abcd&quot;, t = &quot;cdef&quot;, cost = 3 输出：1 解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。 示例 3： 输入：s = &quot;abcd&quot;, t = &quot;acde&quot;, cost = 0 输出：1 解释：你无法作出任何改动，所以最大长度为 1。 提示： 1 &lt;= s.length, t.length &lt;= 10^5 0 &lt;= maxCost &lt;= 10^6 s 和 t 都只含小写英文字母。 分析：使用两个指针，先指向0，如果变换的开销小于等于cost，将开销记录下来，右指针右移一位，如果变换的开销大于cost，左指针右移一位 代码：class Solution { public: int j(char i, char j){ return i &gt; j ? i - j : j - i; } int equalSubstring(string s, string t, int maxCost) { int l = 0; int r = 0; int z = j(s[0], t[0]); int ret = 0; while(r &lt; s.size()){ if(z &lt;= maxCost){ ret = max(ret, r - l + 1); r++; z += j(s[r], t[r]); } else{ z -= j(s[l], t[l]); l++; } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-156/problems/get-equal-substrings-within-budget/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2019%2F09%2F30%2Fleetcode%205205.%20%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例：示例 1： 输入：arr = [1,2,2,1,1,3] 输出：true 解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2： 输入：arr = [1,2] 输出：false 示例 3： 输入：arr = [-3,0,1,-3,1,1,1,-3,10,0] 输出：true 提示： 1 &lt;= arr.length &lt;= 1000 -1000 &lt;= arr[i] &lt;= 1000 分析：统计数的出现次数，使用set和map存储，如果大小相等则出现次数独一无二，反之相反 代码：class Solution { public: bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) { map&lt;int, int&gt; mi; set&lt;int&gt; si; for(int i = 0; i &lt; arr.size(); i++){ mi[arr[i]]++; } for(auto m = mi.begin(); m != mi.end(); m++){ si.insert(m-&gt;second); } if(si.size() != mi.size()) return false; return true; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-156/problems/unique-number-of-occurrences/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5200. 项目管理]]></title>
    <url>%2F2019%2F09%2F30%2Fleetcode%205200.%20%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[题目：公司共有 n 个项目和 m 个小组，每个项目要不没有归属，要不就由其中的一个小组负责。 我们用 group[i] 代表第 i 个项目所属的小组，如果这个项目目前无人接手，那么 group[i] 就等于 -1。（项目和小组都是从零开始编号的） 请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表： 同一小组的项目，排序后在列表中彼此相邻。项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。结果要求： 如果存在多个解决方案，只需要返回其中任意一个即可。 如果没有合适的解决方案，就请返回一个 空列表。 示例：示例 1： 输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]] 输出：[6,3,4,1,5,2,0,7] 示例 2： 输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]] 输出：[] 解释：与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。 提示： 1 &lt;= m &lt;= n &lt;= 3*10^4 group.length == beforeItems.length == n -1 &lt;= group[i] &lt;= m-1 0 &lt;= beforeItems[i].length &lt;= n-1 0 &lt;= beforeItems[i][j] &lt;= n-1 i != beforeItems[i][j] 分析：使用两次拓扑排序 将项目按组分好，将没有组的各自为一个组 组内拓扑排序 将排序好的组按组进行拓扑排序 代码：class Solution { private: class c{ public: vector&lt;int&gt; hz; int rd; vector&lt;int&gt; jd; c(){ rd = 0; }; }; public: //拓扑排序 vector&lt;int&gt; sortItems(int n, int m, vector&lt;int&gt;&amp; group, vector&lt;vector&lt;int&gt;&gt;&amp; beforeItems) { vector&lt;c&gt; vc(m); vector&lt;int&gt; ys(n); // 映射 vector&lt;int&gt; vi(n); // 组内入度 vector&lt;vector&lt;int&gt;&gt; vvi(n, vector&lt;int&gt;()); // 后置结点 for(int i = 0; i &lt; n; i++){ // 分组 if(group[i] == -1){ vc.push_back(c()); vc[vc.size()-1].jd.push_back(i); ys[i] = vc.size()-1; } else{ vc[group[i]].jd.push_back(i); ys[i] = group[i]; } } for(int i = 0; i &lt; beforeItems.size(); i++){ // 计算组内后置结点和入度 for(int j = 0; j &lt; beforeItems[i].size(); j++){ if(beforeItems[i][j] != -1 &amp;&amp; group[beforeItems[i][j]] == group[i]){ vvi[beforeItems[i][j]].push_back(i); vi[i]++; } } } for(int i = 0; i &lt; vc.size(); i++){ // 组内排序 if(vc[i].jd.size() != 1){ queue&lt;int&gt; q; vector&lt;int&gt; tmp; for(int j = 0; j &lt; vc[i].jd.size(); j++){ if(vi[vc[i].jd[j]] == 0){ q.push(vc[i].jd[j]); } } while(q.size()){ tmp.push_back(q.front()); for(int j = 0; j &lt; vvi[q.front()].size(); j++){ vi[vvi[q.front()][j]]--; if(vi[vvi[q.front()][j]] == 0) q.push(vvi[q.front()][j]); } q.pop(); } if(tmp.size() != vc[i].jd.size()) return vector&lt;int&gt;(); vc[i].jd.clear(); vc[i].jd.insert(vc[i].jd.begin(), tmp.begin(), tmp.end()); } } for(int i = 0; i &lt; beforeItems.size(); i++){ // 计算组间后置和入度 for(int j = 0; j &lt; beforeItems[i].size(); j++){ if(group[beforeItems[i][j]] != group[i] || group[i] == -1){ vc[ys[beforeItems[i][j]]].hz.push_back(ys[i]); vc[ys[i]].rd++; cout &lt;&lt; ys[i]; } } } vector&lt;int&gt; ret; queue&lt;int&gt; q; for(int i = 0; i &lt; vc.size(); i++){ if(vc[i].rd == 0){ cout &lt;&lt; i &lt;&lt; &quot; &quot;; q.push(i); } } while(q.size()){ ret.insert(ret.end(), vc[q.front()].jd.begin(), vc[q.front()].jd.end()); for(int i = 0; i &lt; vc[q.front()].hz.size(); i++){ vc[vc[q.front()].hz[i]].rd--; if(vc[vc[q.front()].hz[i]].rd == 0) q.push(vc[q.front()].hz[i]); } q.pop(); } if(ret.size() == n){ return ret; } return vector&lt;int&gt;(); 题目地址:https://leetcode-cn.com/contest/weekly-contest-155/problems/sort-items-by-groups-respecting-dependencies/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5199. 交换字符串中的元素]]></title>
    <url>%2F2019%2F09%2F23%2Fleetcode%205199.%20%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。 你可以 任意多次交换 在 pairs 中任意一对索引处的字符。 返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。 示例：示例 1: 输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2]] 输出：&quot;bacd&quot; 解释： 交换 s[0] 和 s[3], s = &quot;bcad&quot; 交换 s[1] 和 s[2], s = &quot;bacd&quot; 示例 2： 输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]] 输出：&quot;abcd&quot; 解释： 交换 s[0] 和 s[3], s = &quot;bcad&quot; 交换 s[0] 和 s[2], s = &quot;acbd&quot; 交换 s[1] 和 s[2], s = &quot;abcd&quot; 示例 3： 输入：s = &quot;cba&quot;, pairs = [[0,1],[1,2]] 输出：&quot;abc&quot; 解释： 交换 s[0] 和 s[1], s = &quot;bca&quot; 交换 s[1] 和 s[2], s = &quot;bac&quot; 交换 s[0] 和 s[1], s = &quot;abc&quot; 提示： 1 &lt;= s.length &lt;= 10^5 0 &lt;= pairs.length &lt;= 10^5 0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length s 中只含有小写英文字母 分析：只要可以交换的字符，之间的值可以随意换 使用dfs或者并查集，将可以交换的字符索引存储到同一个数组中 将每组的字符排序，按序填入索引位置即可 代码：class Solution { private: map&lt;int, vector&lt;int&gt;&gt; mvi; vector&lt;int&gt; p; public: void dfs(int x, vector&lt;int&gt;&amp; vi){ // 将连通的结点存储到同一个数组中 if(p[x] == 0){ vi.push_back(x); p[x] = 1; for(int i = 0; i &lt; mvi[x].size(); i++){ dfs(mvi[x][i], vi); } } } string smallestStringWithSwaps(string s, vector&lt;vector&lt;int&gt;&gt;&amp; pairs) { string str = s; p.insert(p.begin(), s.size(), 0); for(int i = 0; i &lt; pairs.size(); i++){ mvi[pairs[i][0]].push_back(pairs[i][1]); mvi[pairs[i][1]].push_back(pairs[i][0]); } vector&lt;vector&lt;int&gt;&gt; vvi; vector&lt;vector&lt;char&gt;&gt; vvc; for(int i = 0; i &lt; s.size(); i++){ if(p[i] == 0){ vvi.push_back(vector&lt;int&gt;()); dfs(i, vvi[vvi.size()-1]); } } for(int i = 0; i &lt; vvi.size(); i++){ vvc.push_back(vector&lt;char&gt;()); for(int j = 0; j &lt; vvi[i].size(); j++){ vvc[vvc.size()-1].push_back(s[vvi[i][j]]); } sort(vvc[vvc.size()-1].begin(), vvc[vvc.size()-1].end()); sort(vvi[i].begin(), vvi[i].end()); } for(int i = 0; i &lt; vvi.size(); i++){ for(int j = 0; j &lt; vvi[i].size(); j++){ str[vvi[i][j]] = vvc[i][j]; } } return str; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-155/problems/smallest-string-with-swaps/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5198. 丑数 III]]></title>
    <url>%2F2019%2F09%2F23%2Fleetcode%205198.%20%E4%B8%91%E6%95%B0%20III%2F</url>
    <content type="text"><![CDATA[题目：请你帮忙设计一个程序，用来找出第 n 个丑数。 丑数是可以被 a 或 b 或 c 整除的 正整数。 示例：示例 1： 输入：n = 3, a = 2, b = 3, c = 5 输出：4 解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。 示例 2： 输入：n = 4, a = 2, b = 3, c = 4 输出：6 解释：丑数序列为 2, 3, 4, 6, 8, 9, 12... 其中第 4 个是 6。 示例 3： 输入：n = 5, a = 2, b = 11, c = 13 输出：10 解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。 示例 4： 输入：n = 1000000000, a = 2, b = 217983653, c = 336916467 输出：1999999984 提示： 1 &lt;= n, a, b, c &lt;= 10^9 1 &lt;= a b c &lt;= 10^18 本题结果在 [1, 2 * 10^9] 的范围内 分析：使用二分查找法 判断一个数是第几个丑数的方法 计算到m为止，a，b，c的倍数的数量 减去ab，bc，ac的最小公倍数的数量 加上abc的最小公倍数的数量 A，B的最小公倍数=A*B/(A，B)的最大公约数求最大公约数—碾转相除法：转换为A，B相除的余数与A，B间较小数的最大公约数 代码：class Solution { public: int gcd(int a, int b){ // 最大公约数 while(b != 0){ int z = b; b = a % b; a = z; } return a; } int nthUglyNumber(int n, int a, int b, int c) { int l = 0; int r = 2000000000; while(l + 1 &lt; r){ int m = ((long)l + r) / 2; int cnt = m / a; cnt += m / b; cnt += m / c; cnt -= m / ((long)a * b / gcd(a, b)); // 最小公倍数 cnt -= m / ((long)b * c / gcd(b, c)); cnt -= m / ((long)a * c / gcd(a, c)); int tmp = (long)a * b / gcd(a, b); cnt += m / ((long)tmp * c / gcd(tmp, c)); if(cnt &lt; n) l = m; else r = m; } return r; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-155/problems/ugly-number-iii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5197. 最小绝对差]]></title>
    <url>%2F2019%2F09%2F23%2Fleetcode%205197.%20%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[题目：给你个整数数组 arr，其中每个元素都 不相同。 请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。 示例：示例 1： 输入：arr = [4,2,1,3] 输出：[[1,2],[2,3],[3,4]] 示例 2： 输入：arr = [1,3,6,10,15] 输出：[[1,3]] 示例 3： 输入：arr = [3,8,-10,23,19,-4,-14,27] 输出：[[-14,-10],[19,23],[23,27]] 提示： 2 &lt;= arr.length &lt;= 10^5 -10^6 &lt;= arr[i] &lt;= 10^6 分析：先排序，然后遍历比较相差的值，保存最小绝对差的元素对，如果遇到更小的，就清空之前的元素对 代码：class Solution { public: vector&lt;vector&lt;int&gt;&gt; minimumAbsDifference(vector&lt;int&gt;&amp; arr) { sort(arr.begin(), arr.end()); vector&lt;vector&lt;int&gt;&gt; vvi; int m = INT_MAX; for(int i = 1; i &lt; arr.size(); i++){ if(m &gt; arr[i] - arr[i-1]){ m = arr[i] - arr[i-1]; vvi.clear(); vvi.push_back(vector&lt;int&gt;{arr[i-1], arr[i]}); } else if(m == arr[i] - arr[i-1]){ vvi.push_back(vector&lt;int&gt;{arr[i-1], arr[i]}); } } return vvi; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-155/problems/minimum-absolute-difference/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1192. 查找集群内的「关键连接」]]></title>
    <url>%2F2019%2F09%2F19%2Fleetcode%201192.%20%E6%9F%A5%E6%89%BE%E9%9B%86%E7%BE%A4%E5%86%85%E7%9A%84%E3%80%8C%E5%85%B3%E9%94%AE%E8%BF%9E%E6%8E%A5%E3%80%8D%2F</url>
    <content type="text"><![CDATA[题目：力扣数据中心有 n 台服务器，分别按从 0 到 n-1 的方式进行了编号。 它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 connections 是无向的。 从形式上讲，connections[i] = [a, b] 表示服务器 a 和 b 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。 「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。 请你以任意顺序返回该集群内的所有 「关键连接」。 示例：输入：n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]输出：[[1,3]]解释：[[3,1]] 也是正确的。 提示： 1 &lt;= n &lt;= 10^5 n-1 &lt;= connections.length &lt;= 10^5 connections[i][0] != connections[i][1] 不存在重复的连接 分析：这道题使用了Tarjan算法 Tarjan算法是用来求强连通分量的，它是一种基于DFS（深度优先搜索）的算法 Tarjan算法有两个非常重要的数组： dfn[] 一个时间戳（被搜到的次序） low[] 返祖的时候计算的回溯值 将路径存储为邻接表 写一个dfs，传两个参数x，y，一个为当前需要遍历的结点，一个为上一个结点（可以避免原路返回） 将low[x]和dfn[x]的值赋值为被搜到的次序 循环遍历相连的结点： 下一个结点没有被遍历过，调用dfs函数。然后判断返回值是否大于dfn[x],如果大于，就代表这一个结点和当前节点中的边为关键连接。再将返回值和当前节点的low值比较，将low值修改为两个值中较小的那一个 下一个结点被遍历过，判断当前节点和下一结点的low值，将当前节点的low修改为较小的那一个。 代码：class Solution { private: vector&lt;vector&lt;int&gt;&gt; c; // 路径 vector&lt;int&gt; low; // 返祖的时候计算的回溯值 vector&lt;int&gt; dfn; // 时间戳 vector&lt;vector&lt;int&gt;&gt; kc; int cnt; public: int dfs(int x, int y){ // x是当前节点，y是上一个结点，返回值为low[x] low[x] = dfn[x] = ++cnt; for(int i = 0; i &lt; c[x].size(); i++){ if(c[x][i] != y){ if(dfn[c[x][i]] == 0){ int l = dfs(c[x][i], x); if(l &gt; dfn[x]){ // 这个位置不能用low[x],如果使用low，n = 4, connections = [[0,1],[1,2],[2,0],[1,3],[2,3]]就会通不过，因为照这个程序运行low[2]的值会变成1，而，low[3]的值会是2，访问顺序为0,1,2(这里会先尝试0，这样low[2]的值会变成1),3(这里会尝试1，这样low[3]的值就变成了[2]) kc.push_back(vector&lt;int&gt;{x, c[x][i]}); //cout &lt;&lt; low[x] &lt;&lt; &quot; &quot; &lt;&lt; l &lt;&lt; &quot;\n&quot;; } low[x] = min(low[x], l); } else{ low[x] = min(low[x], low[c[x][i]]); } } } return low[x]; } vector&lt;vector&lt;int&gt;&gt; criticalConnections(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) { cnt = 0; c.insert(c.begin(), n, vector&lt;int&gt;()); // 初始化c low.insert(low.begin(), n, 0); // 初始化low dfn.insert(dfn.begin(), n, 0); // 初始化dfn for(int i = 0; i &lt; connections.size(); i++){ c[connections[i][0]].push_back(connections[i][1]); c[connections[i][1]].push_back(connections[i][0]); } for(int i = 0; i &lt; n; i++){ if(dfn[i] == 0){ dfs(i, i); } } return kc; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-154/problems/critical-connections-in-a-network/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2019%2F09%2F16%2Fleetcode%201191.%20K%20%E6%AC%A1%E4%B8%B2%E8%81%94%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 arr 和一个整数 k。 首先，我们要对该数组进行修改，即把原数组 arr 重复 k 次。 举个例子，如果 arr = [1, 2] 且 k = 3，那么修改后的数组就是 [1, 2, 1, 2, 1, 2]。 然后，请你返回修改后的数组中的最大的子数组之和。 注意，子数组长度可以是 0，在这种情况下它的总和也是 0。 由于 结果可能会很大，所以需要 模（mod） 10^9 + 7 后再返回。 示例：示例 1： 输入：arr = [1,2], k = 3输出：9示例 2： 输入：arr = [1,-2,1], k = 5输出：2示例 3： 输入：arr = [-1,-2], k = 7输出：0 提示： 1 &lt;= arr.length &lt;= 10^5 1 &lt;= k &lt;= 10^5 -10^4 &lt;= arr[i] &lt;= 10^4 分析：如果只重复一次，就直接求数组中最大的连续数组 如果重复两次，就求两个数组前半段最大和后半段最大之和，与上面的进行比较，选择大的那个 如果重复两次以上，就用上面求出的前半段最大和后半段最大之和，加上数组之和乘以k-2次，在和上面的两个比较，选择大的那个 代码：class Solution {public: int kConcatenationMaxSum(vector&amp; arr, int k) { long z = 0; long lm = 0; long k2 = 0; long k1 = 0; long x = 0; long xm = 0; for(int i = 0; i &lt; arr.size(); i++){ z += arr[i]; if(z &gt; lm) lm = z; x += arr[i]; if(x &lt; 0) x = 0; if(xm &lt; x){ xm = x; } } if(z &gt;= 0 &amp;&amp; k &gt; 1){ long rm = 0; long x = 0; for(int i = arr.size()-1; i &gt;= 0; i–){ x += arr[i]; if(rm &lt; x) rm = x; } k2 = (z * (k - 2 &gt; 0 ? k - 2 : 0) + rm + lm) % 1000000007; } if(k &gt; 1){ long rm = 0; long x = 0; for(int i = arr.size()-1; i &gt;= 0; i–){ x += arr[i]; if(rm &lt; x) rm = x; } k1 = (rm + lm) % 1000000007; } return max(max(xm, k2), k1); }}; 题目地址:https://leetcode-cn.com/contest/weekly-contest-154/problems/k-concatenation-maximum-sum/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1190. 反转每对括号间的子串]]></title>
    <url>%2F2019%2F09%2F16%2Fleetcode%201190.%20%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给出一个字符串 s（仅含有小写英文字母和括号）。 请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。 注意，您的结果中 不应 包含任何括号。 示例：示例 1： 输入：s = &quot;(abcd)&quot; 输出：&quot;dcba&quot; 示例 2： 输入：s = &quot;(u(love)i)&quot; 输出：&quot;iloveu&quot; 示例 3： 输入：s = &quot;(ed(et(oc))el)&quot; 输出：&quot;leetcode&quot; 示例 4： 输入：s = &quot;a(bcdefghijkl(mno)p)q&quot; 输出：&quot;apmnolkjihgfedcbq&quot; 提示： 0 &lt;= s.length &lt;= 2000 s 中只有小写英文字母和括号 我们确保所有括号都是成对出现的 分析：使用栈，遇到)就将上一个(开始到)的出栈，反转后进栈 代码：class Solution { public: string reverseParentheses(string s) { vector&lt;char&gt; vi; for(int i = 0; i &lt; s.size(); i++){ if(s[i] == &apos;)&apos;) { vector&lt;char&gt; v; while(vi[vi.size()-1] != &apos;(&apos;){ v.push_back(vi[vi.size()-1]); vi.pop_back(); } vi.pop_back(); vi.insert(vi.end(), v.begin(), v.end()); } else{ vi.push_back(s[i]); } } string str = &quot;&quot;; str.insert(str.begin(), vi.begin(), vi.end()); return str; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-154/problems/reverse-substrings-between-each-pair-of-parentheses/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1189. “气球” 的最大数量]]></title>
    <url>%2F2019%2F09%2F16%2Fleetcode%201189.%20%E2%80%9C%E6%B0%94%E7%90%83%E2%80%9D%20%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 “balloon”（气球）。 字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。 示例：示例 1： 输入：text = &quot;nlaebolko&quot; 输出：1 示例 2： 输入：text = &quot;loonbalxballpoon&quot; 输出：2 示例 3： 输入：text = &quot;leetcode&quot; 输出：0 提示： 1 &lt;= text.length &lt;= 10^4 text 全部由小写英文字母组成 分析：直接统计b a l o n 这几个字母出现的次数，将l和o出现数量除以2，返回这几个字母出现次数最少的那个 代码：class Solution { public: int maxNumberOfBalloons(string text) { int c[5] = {0}; for(int i = 0; i &lt; text.size(); i++){ if(text[i] == &apos;b&apos;) c[0]++; else if(text[i] == &apos;a&apos;) c[1]++; else if(text[i] == &apos;l&apos;) c[2]++; else if(text[i] == &apos;o&apos;) c[3]++; else if(text[i] == &apos;n&apos;) c[4]++; } c[2] /= 2; c[3] /= 2; int m = INT_MAX; for(int i = 0; i &lt; 5; i++){ if(c[i] &lt; m) m = c[i]; } return m; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-154/problems/maximum-number-of-balloons/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1187. 使数组严格递增]]></title>
    <url>%2F2019%2F09%2F09%2Fleetcode%201187.%20%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E%2F</url>
    <content type="text"><![CDATA[题目：给你两个整数数组 arr1 和 arr2，返回使 arr1 严格递增所需要的最小「操作」数（可能为 0）。 每一步「操作」中，你可以分别从 arr1 和 arr2 中各选出一个索引，分别为 i 和 j，0 &lt;= i &lt; arr1.length 和 0 &lt;= j &lt; arr2.length，然后进行赋值运算 arr1[i] = arr2[j]。 如果无法让 arr1 严格递增，请返回 -1。 示例：示例 1： 输入：arr1 = [1,5,3,6,7], arr2 = [1,3,2,4] 输出：1 解释：用 2 来替换 5，之后 arr1 = [1, 2, 3, 6, 7]。 示例 2： 输入：arr1 = [1,5,3,6,7], arr2 = [4,3,1] 输出：2 解释：用 3 来替换 5，然后用 4 来替换 3，得到 arr1 = [1, 3, 4, 6, 7]。 示例 3： 输入：arr1 = [1,5,3,6,7], arr2 = [1,6,3,3] 输出：-1 解释：无法使 arr1 严格递增。 提示： 1 &lt;= arr1.length, arr2.length &lt;= 2000 0 &lt;= arr1[i], arr2[i] &lt;= 10^9 分析：将arr2去重排序 动态规划 定义一个函数dy，用来计算arr2中大于传入参数z的第一个值 dp[i][j],i为第i个数，j为修改j次 在j为0的时候，根据之前的数是否是递增关系来判断是否将dp[i][0]置为arr1[i] dp[0][1] = arr2中最小的值 dp[i][j] = dy(arr2，dp[i][j-1]) || arr1[i] (需要判断arr1[i]是否大于vvi[i-1][j]) 最后从dp[dp.size()-1][0]开始遍历一遍，返回第一个非-1值时的j 代码：class Solution { public: int dy(vector&lt;int&gt; si, int z){ int l = 0; int r = si.size()-1; int mid; while(l &lt;= r){ mid = l + (r - l) / 2; if(z &lt; si[mid]){ r = mid - 1; }else{ l = mid + 1; } } // cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; z &lt;&lt; &quot;&gt;&quot;; return l &gt;= si.size() ? -1 : si[l]; } int makeArrayIncreasing(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) { vector&lt;vector&lt;int&gt;&gt; vvi(arr1.size(), vector&lt;int&gt;(arr1.size()+1, -1)); set&lt;int&gt; si(arr2.begin(), arr2.end()); arr2.assign(si.begin(), si.end()); for(int i = 0; i &lt; arr1.size(); i++){ for(int j = 0; j &lt;= i+1; j++){ if(j == 0 &amp;&amp; (i-1 &lt; 0 || (vvi[i-1][0] != -1 &amp;&amp; arr1[i] &gt; arr1[i-1]))){ vvi[i][0] = arr1[i]; } else{ // if(i-1 &gt;= 0 &amp;&amp; j-1 &gt;= 0 &amp;&amp; vvi[i-1][j-1] == -1){ // continue; // } int d = INT_MAX; // 根据j-1获得，这次改变 int d1 = INT_MAX; // 根据j获得，这次不变 if(i-1 &gt;= 0 &amp;&amp; j-1 &gt;= 0 &amp;&amp; vvi[i-1][j-1] != -1){ d = dy(arr2, vvi[i-1][j-1]); d = d &gt; -1 ? d : INT_MAX; } if(i - 1 &gt;= 0 &amp;&amp; vvi[i-1][j] != -1 &amp;&amp; vvi[i-1][j] &lt; arr1[i]){ d1 = arr1[i]; } if(d == INT_MAX &amp;&amp; d1 == INT_MAX) vvi[i][j] = -1; else vvi[i][j] = min(d1, d); if(i == 0 &amp;&amp; j == 1){ // 在第0位1次修改的时候，也就是第一个数字改为arr2中最小的那个值 vvi[0][1] = arr2[0]; } } //cout &lt;&lt; vvi[i][j] &lt;&lt; &quot;\t&quot;; } // cout &lt;&lt; &quot;\n&quot;; } for(int i = 0; i &lt; arr1.size()+1; i++){ if(vvi[arr1.size()-1][i] != -1){ return i; } } return -1; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-153/problems/make-array-strictly-increasing/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1186. 删除一次得到子数组最大和]]></title>
    <url>%2F2019%2F09%2F09%2Fleetcode%201186.%20%E5%88%A0%E9%99%A4%E4%B8%80%E6%AC%A1%E5%BE%97%E5%88%B0%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：用户通过次数 131用户尝试次数 478通过次数 134提交次数 1365题目难度 Medium给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。 换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。 注意，删除一个元素后，子数组 不能为空。 示例：示例 1： 输入：arr = [1,-2,0,3] 输出：4 解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。 示例 2： 输入：arr = [1,-2,-2,3] 输出：3 解释：我们直接选出 [3]，这就是最大和。 示例 3： 输入：arr = [-1,-1,-1,-1] 输出：-1 解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。 我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。 提示： 1 &lt;= arr.length &lt;= 10^5 -10^4 &lt;= arr[i] &lt;= 10^4 分析：从左往右、从右往左遍各历一遍，求以每个数为结尾最大的值 再次遍历一遍，求以每个数为中心，左右两边之前求出来的值之和 代码：class Solution { public: int maximumSum(vector&lt;int&gt;&amp; arr) { vector&lt;int&gt; l(arr.size(), 0); vector&lt;int&gt; r(arr.size(), 0); int max_a = *max_element(arr.begin(), arr.end()); if(max_a &lt; 0) return max_a; int z = 0; for(int i = 0; i &lt; arr.size(); i++){ z += arr[i]; if(z &lt;= 0) z = 0; l[i] = z; } int max_l = *max_element(l.begin(), l.end()); z = 0; for(int i = arr.size()-1; i &gt;= 0; i--){ z += arr[i]; if(z &lt;= 0) z = 0; r[i] = z; } int max_lr = 0; for(int i = 0; i &lt; arr.size(); i++){ int lr = 0; lr += i - 1 &gt;= 0 ? l[i-1] : 0; lr += i + 1 &lt; arr.size() ? r[i+1] : 0; max_lr = max(lr, max_lr); } return max(max_lr, max_l); } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-153/problems/maximum-subarray-sum-with-one-deletion/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1185. 一周中的第几天]]></title>
    <url>%2F2019%2F09%2F09%2Fleetcode%201185.%20%E4%B8%80%E5%91%A8%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[题目：给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。 输入为三个整数：day、month 和 year，分别表示日、月、年。 您返回的结果必须是这几个值中的一个 {“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”}。 示例：示例 1： 输入：day = 31, month = 8, year = 2019 输出：&quot;Saturday&quot; 示例 2： 输入：day = 18, month = 7, year = 1999 输出：&quot;Sunday&quot; 示例 3： 输入：day = 15, month = 8, year = 1993 输出：&quot;Sunday&quot; 提示： 给出的日期一定是在 1971 到 2100 年之间的有效日期。 分析：计算从1971年开始到目标时间的间隔加上3除7求余数，因为1971年一月一日是星期5 还可以用泰勒公式或基姆拉尔森公式来求，算法如下： 版权声明：本文为CSDN博主「hans_1990」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/hans_1990/article/details/26486613 代码：class Solution { public: string dayOfTheWeek(int day, int month, int year) { int d = 0; int r[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; int p[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; string str[12] = {&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;}; for(int i = 1971; i &lt; year; i++){ if(i % 4 == 0 &amp;&amp; i % 100 != 0 || i % 400 == 0) d += 366; else d += 365; } if(year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0){ for(int i = 1; i &lt; month; i++){ d += r[i-1]; } } else{ for(int i = 1; i &lt; month; i++){ d += p[i-1]; } } d += day; cout &lt;&lt; d; d = (d + 3) % 7; return str[d]; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-153/problems/day-of-the-week/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1184. 公交站间的距离]]></title>
    <url>%2F2019%2F09%2F09%2Fleetcode%201184.%20%E5%85%AC%E4%BA%A4%E7%AB%99%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[题目：环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。 环线上的公交车都可以按顺时针和逆时针的方向行驶。 返回乘客从出发点 start 到目的地 destination 之间的最短距离。 示例：示例 1： 输入：distance = [1,2,3,4], start = 0, destination = 1 输出：1 解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。 示例 2： 输入：distance = [1,2,3,4], start = 0, destination = 2 输出：3 解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。 示例 3： 输入：distance = [1,2,3,4], start = 0, destination = 3 输出：4 解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。 提示： 1 &lt;= n &lt;= 10^4 distance.length == n 0 &lt;= start, destination &lt; n 0 &lt;= distance[i] &lt;= 10^4 分析：两个循环，各记录两个方向的距离 代码：class Solution { public: int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) { int s = 0; int n = 0; for(int i = start; i != destination; i = (i+1) % distance.size()){ s += distance[i]; } for(int i = start-1 &gt;= 0 ? start - 1 : distance.size()-1; i != ((destination-1) &lt; 0 ? distance.size()-1 : destination-1); i = (i-1 &gt;= 0 ? i-1 : distance.size()-1)){ n += distance[i]; } cout &lt;&lt; &quot;:&quot;; return min(s, n); } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-153/problems/distance-between-bus-stops/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5176. 猜字谜]]></title>
    <url>%2F2019%2F09%2F02%2Fleetcode%205176.%20%E7%8C%9C%E5%AD%97%E8%B0%9C%2F</url>
    <content type="text"><![CDATA[题目：外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。 字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底： 单词 word 中包含谜面 puzzle 的第一个字母。 单词 word 中的每一个字母都可以在谜面 puzzle 中找到。例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）。 返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。 示例：输入： words = [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], puzzles = [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;] 输出：[1,1,3,2,4,0] 解释： 1 个单词可以作为 &quot;aboveyz&quot; 的谜底 : &quot;aaaa&quot; 1 个单词可以作为 &quot;abrodyz&quot; 的谜底 : &quot;aaaa&quot; 3 个单词可以作为 &quot;abslute&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot; 2 个单词可以作为 &quot;absoryz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot; 4 个单词可以作为 &quot;actresz&quot; 的谜底 : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot; 没有单词可以作为 &quot;gaswxyz&quot; 的谜底，因为列表中的单词都不含字母 &apos;g&apos;。 提示： 1 &lt;= words.length &lt;= 10^5 4 &lt;= words[i].length &lt;= 50 1 &lt;= puzzles.length &lt;= 10^4 puzzles[i].length == 7 words[i][j], puzzles[i][j] 都是小写英文字母。 每个 puzzles[i] 所包含的字符都不重复。 分析：因为puzzles[i].length == 7，所以words中的字符串只可能有7个字符组成，超出7个字符的去掉 int类型有32位，所以可以用来表示26个字母，列如第一位用来存储是否有a这个字符、第二位用来存储是否有b这个字符等等 将所有的字符串根据上面的方法转换成int类型 一个个比较过来，想要判断一个字符串的字符是否在另一个字符串中包含(已经转换为两个int类型的数据了)，只需要将两个int进行&amp;操作然后再将新的int和第二个int比较，如果相等就代表字符串的字符在另一个字符串中包含了 代码：class Solution { public: bool cx(int x, int y){ return (x &amp; (1 &lt;&lt; y)) == 0; } vector&lt;int&gt; findNumOfValidWords(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles) { vector&lt;vector&lt;int&gt;&gt; c(26); vector&lt;int&gt; ret; for(int i = 0; i &lt; words.size(); i++){ int vi = 0; int z = 0; bool b = true; for(int j = 0; j &lt; words[i].size(); j++){ if(cx(vi, words[i][j]-&apos;a&apos;)){ z++; if(z &gt; 7){ b = false; break; } } vi |= 1 &lt;&lt; int(words[i][j]-&apos;a&apos;); } if(b){ for(int j = 0; j &lt; 26; j++){ if(!cx(vi, j)){ c[j].push_back(vi); } } } //cout &lt;&lt; c[j].size() &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;; } for(int i = 0; i &lt; puzzles.size(); i++){ int z = 0; int x = 0; for(int j = 0; j &lt; puzzles[i].size(); j++){ z |= 1 &lt;&lt; int(puzzles[i][j]-&apos;a&apos;); } for(int j = 0; j &lt; c[puzzles[i][0] - &apos;a&apos;].size(); j++){ if((c[puzzles[i][0] - &apos;a&apos;][j] | z) == z){ cout &lt;&lt; x &lt;&lt; &quot;\n&quot;; x++; } } ret.push_back(x); } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-152/problems/number-of-valid-words-for-each-puzzle/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5175. 构建回文串检测]]></title>
    <url>%2F2019%2F09%2F02%2Fleetcode%205175.%20%E6%9E%84%E5%BB%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s，请你对 s 的子串进行检测。 每次检测，待检子串都可以表示为 queries[i] = [left, right, k]。我们可以 重新排列 子串 s[left], …, s[right]，并从中选择 最多 k 项替换成任何小写英文字母。 如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 true，否则结果为 false。 返回答案数组 answer[]，其中 answer[i] 是第 i 个待检子串 queries[i] 的检测结果。 注意：在替换时，子串中的每个字母都必须作为 独立的 项进行计数，也就是说，如果 s[left..right] = “aaa” 且 k = 2，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 s，可以认为每次检测都是独立的） 示例：输入：s = &quot;abcda&quot;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]] 输出：[true,false,false,true,true] 解释： queries[0] : 子串 = &quot;d&quot;，回文。 queries[1] : 子串 = &quot;bc&quot;，不是回文。 queries[2] : 子串 = &quot;abcd&quot;，只替换 1 个字符是变不成回文串的。 queries[3] : 子串 = &quot;abcd&quot;，可以变成回文的 &quot;abba&quot;。 也可以变成 &quot;baab&quot;，先重新排序变成 &quot;bacd&quot;，然后把 &quot;cd&quot; 替换为 &quot;ab&quot;。 queries[4] : 子串 = &quot;abcda&quot;，可以变成回文的 &quot;abcba&quot;。 提示： 1 &lt;= s.length, queries.length &lt;= 10^5 0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; s.length 0 &lt;= queries[i][2] &lt;= s.length s 中只有小写英文字母 分析：计算到每一个字符的各个字符数量 中间一段的字符数量等于结尾的字符数量到第一个字符前一个的字符数量 对字符数量除2取余，将所有余数相加除以2，如果得到的数据小于等于k，就返回ture，否则返回false 代码：class Solution { public: vector&lt;bool&gt; canMakePaliQueries(string s, vector&lt;vector&lt;int&gt;&gt;&amp; queries) { vector&lt;bool&gt; vb; vector&lt;vector&lt;int&gt;&gt; vvi(s.size()+1, vector&lt;int&gt;(26)); for(int i = 0; i &lt; s.size(); i++){ vvi[i+1] = vvi[i]; vvi[i+1][s[i]-&apos;a&apos;]++; } for(int i = 0; i &lt; queries.size(); i++){ int z = 0; for(int j = 0; j &lt; 26; j++){ z += (vvi[queries[i][1]+1][j] - vvi[queries[i][0]][j]) % 2; } if(z / 2 &lt;= queries[i][2]){ vb.push_back(true); } else vb.push_back(false); } return vb; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-152/problems/can-make-palindrome-from-substring/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5174. 健身计划评估]]></title>
    <url>%2F2019%2F09%2F02%2Fleetcode%205174.%20%E5%81%A5%E8%BA%AB%E8%AE%A1%E5%88%92%E8%AF%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[题目：你的好友是一位健身爱好者。前段日子，他给自己制定了一份健身计划。现在想请你帮他评估一下这份计划是否合理。 他会有一份计划消耗的卡路里表，其中 calories[i] 给出了你的这位好友在第 i 天需要消耗的卡路里总量。 为了更好地评估这份计划，对于卡路里表中的每一天，你都需要计算他 「这一天以及之后的连续几天」 （共 k 天）内消耗的总卡路里 T： 如果 T &lt; lower，那么这份计划相对糟糕，并失去 1 分； 如果 T &gt; upper，那么这份计划相对优秀，并获得 1 分； 否则，这份计划普普通通，分值不做变动。 请返回统计完所有 calories.length 天后得到的总分作为评估结果。 注意：总分可能是负数。 示例：示例 1： 输入：calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3 输出：0 解释：calories[0], calories[1] &lt; lower 而 calories[3], calories[4] &gt; upper, 总分 = 0. 示例 2： 输入：calories = [3,2], k = 2, lower = 0, upper = 1 输出：1 解释：calories[0] + calories[1] &gt; upper, 总分 = 1. 示例 3： 输入：calories = [6,5,0,0], k = 2, lower = 1, upper = 5 输出：0 解释：calories[0] + calories[1] &gt; upper, calories[2] + calories[3] &lt; lower, 总分 = 0. 提示： 1 &lt;= k &lt;= calories.length &lt;= 10^5 0 &lt;= calories[i] &lt;= 20000 0 &lt;= lower &lt;= upper 分析：遍历计算每天开始k天消耗的卡路里量，判断评分 代码：class Solution { public: int dietPlanPerformance(vector&lt;int&gt;&amp; calories, int k, int lower, int upper) { int c = 0; int ret = 0; for(int i = 0; i &lt; k-1; i++){ c += calories[i]; } for(int i = k-1; i &lt; calories.size(); i++){ c += calories[i]; if(c &lt; lower) ret--; if(c &gt; upper) ret++; c -= calories[i - k + 1]; } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-152/problems/diet-plan-performance/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5173. 质数排列]]></title>
    <url>%2F2019%2F09%2F02%2Fleetcode%205173.%20%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。 让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。 由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。 示例：示例 1： 输入：n = 5 输出：12 解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。 示例 2： 输入：n = 100 输出：682289015 提示： 1 &lt;= n &lt;= 100 分析：找到质数和非质数，将两种的排列方式的数量相乘即可 代码：class Solution { public: int numPrimeArrangements(int n) { int z = 1; long ret = 1; for(int i = 2; i &lt;= n; i++){ for(int j = 2; j*j &lt;= i; j++){ if(i % j == 0){ z++; break; } } } for(int i = z; i &gt; 0; i--){ ret *= i; ret %= 1000000007; } for(int i = n-z; i &gt; 0; i--){ ret *= i; ret %= 1000000007; } return int(ret); } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-152/problems/prime-arrangements/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1172. 餐盘栈]]></title>
    <url>%2F2019%2F08%2F26%2Fleetcode%201172.%20%E9%A4%90%E7%9B%98%E6%A0%88%2F</url>
    <content type="text"><![CDATA[题目：我们把无限数量 ∞ 的栈排成一行，按从左到右的次序从 0 开始编号。每个栈的的最大容量 capacity 都相同。 实现一个叫「餐盘」的类 DinnerPlates： DinnerPlates(int capacity) - 给出栈的最大容量 capacity。 void push(int val) - 将给出的正整数 val 推入 从左往右第一个 没有满的栈。 int pop() - 返回 从右往左第一个 非空栈顶部的值，并将其从栈中删除；如果所有的栈都是空的，请返回 -1。 int popAtStack(int index) - 返回编号 index 的栈顶部的值，并将其从栈中删除；如果编号 index 的栈是空的，请返回 -1。 示例：输入： [&quot;DinnerPlates&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;popAtStack&quot;,&quot;popAtStack&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;pop&quot;] [[2],[1],[2],[3],[4],[5],[0],[20],[21],[0],[2],[],[],[],[],[]] 输出： [null,null,null,null,null,null,2,null,null,20,21,5,4,3,1,-1] 解释： DinnerPlates D = DinnerPlates(2); // 初始化，栈最大容量 capacity = 2 D.push(1); D.push(2); D.push(3); D.push(4); D.push(5); // 栈的现状为： 2 4 1 3 5 ﹈ ﹈ ﹈ D.popAtStack(0); // 返回 2。栈的现状为： 4 1 3 5 ﹈ ﹈ ﹈ D.push(20); // 栈的现状为： 20 4 1 3 5 ﹈ ﹈ ﹈ D.push(21); // 栈的现状为： 20 4 21 1 3 5 ﹈ ﹈ ﹈ D.popAtStack(0); // 返回 20。栈的现状为： 4 21 1 3 5 ﹈ ﹈ ﹈ D.popAtStack(2); // 返回 21。栈的现状为： 4 1 3 5 ﹈ ﹈ ﹈ D.pop() // 返回 5。栈的现状为： 4 1 3 ﹈ ﹈ D.pop() // 返回 4。栈的现状为： 1 3 ﹈ ﹈ D.pop() // 返回 3。栈的现状为： 1 ﹈ D.pop() // 返回 1。现在没有栈。 D.pop() // 返回 -1。仍然没有栈。 提示： 1 &lt;= capacity &lt;= 20000 1 &lt;= val &lt;= 20000 0 &lt;= index &lt;= 100000 最多会对 push，pop，和 popAtStack 进行 200000 次调用。 分析：正常实现栈，但是加两个变量，一个表示从这个栈的左边开始全是满的栈，一个表示从这个栈的右边开始全是满的栈 代码：class DinnerPlates { private: int c; vector&lt;vector&lt;int&gt;&gt; vvi; int l; int r; public: DinnerPlates(int capacity) { c = capacity; l = 0; r = 0; } void push(int val) { bool b = true; int i = l; for(; i &lt; vvi.size(); i++){ if(vvi[i].size() &lt; c){ vvi[i].push_back(val); b = false; break; } } if(b){ vector&lt;int&gt; v; v.push_back(val); vvi.push_back(v); i = vvi.size()-1; r = i; } l = i; } int pop() { int z = 0; int i = r; for(; i &gt;= 0; i--){ if(vvi[i].size() != 0){ z = vvi[i][vvi[i].size()-1]; vvi[i].pop_back(); r = i; return z; } } r = 0; return -1; } int popAtStack(int index) { int z = -1; if(vvi[index].size() != 0){ z = vvi[index][vvi[index].size()-1]; vvi[index].pop_back(); if(l &gt; index) l = index; if(r &lt; index) r = index; } return z; } }; /** * Your DinnerPlates object will be instantiated and called as such: * DinnerPlates* obj = new DinnerPlates(capacity); * obj-&gt;push(val); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;popAtStack(index); */ 题目地址:https://leetcode-cn.com/contest/weekly-contest-151/problems/dinner-plate-stacks/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1171. 从链表中删去总和值为零的连续节点]]></title>
    <url>%2F2019%2F08%2F26%2Fleetcode%201171.%20%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E5%8E%BB%E6%80%BB%E5%92%8C%E5%80%BC%E4%B8%BA%E9%9B%B6%E7%9A%84%E8%BF%9E%E7%BB%AD%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。 删除完毕后，请你返回最终结果链表的头节点。 你可以返回任何满足题目要求的答案。 （注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。） 示例：示例 1： 输入：head = [1,2,-3,3,1] 输出：[3,1] 提示：答案 [1,2,1] 也是正确的。 示例 2： 输入：head = [1,2,3,-3,4] 输出：[1,2,4] 示例 3： 输入：head = [1,2,3,-3,-2] 输出：[1] 提示： 给你的链表中可能有 1 到 1000 个节点。 对于链表中的每个节点，节点的值：-1000 &lt;= node.val &lt;= 1000. 分析：将链表转换成数组。然后从每个字符开始遍历数组，删除总和值为0的值的时候从头开始继续遍历。最后转换回链表 代码：/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* removeZeroSumSublists(ListNode* head) { vector&lt;int&gt; vi; ListNode* z = head; while(z != NULL){ if(z-&gt;val != 0) vi.push_back(z-&gt;val); z = z-&gt;next; } for(int i = 0; i &lt; vi.size(); i++){ int z = 0; for(int j = i; j &lt; vi.size(); j++){ z += vi[j]; if(z == 0){ vi.erase(vi.begin()+i, vi.begin()+j+1); i = -1; break; } } } ListNode* l = new ListNode(0); ListNode* k = l; for(int i = 0; i &lt; vi.size(); i++){ k -&gt; next = new ListNode(vi[i]); k = k-&gt;next; } return l-&gt;next; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-151/problems/remove-zero-sum-consecutive-nodes-from-linked-list/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1170. 比较字符串最小字母出现频次]]></title>
    <url>%2F2019%2F08%2F26%2Fleetcode%201170.%20%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D%E5%87%BA%E7%8E%B0%E9%A2%91%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[题目：我们来定义一个函数 f(s)，其中传入参数 s 是一个非空字符串；该函数的功能是统计 s 中（按字典序比较）最小字母的出现频次。 例如，若 s = “dcce”，那么 f(s) = 2，因为最小的字母是 “c”，它出现了 2 次。 现在，给你两个字符串数组待查表 queries 和词汇表 words，请你返回一个整数数组 answer 作为答案，其中每个 answer[i] 是满足 f(queries[i]) &lt; f(W) 的词的数目，W 是词汇表 words 中的词。 示例：示例 1： 输入：queries = [&quot;cbd&quot;], words = [&quot;zaaaz&quot;] 输出：[1] 解释：查询 f(&quot;cbd&quot;) = 1，而 f(&quot;zaaaz&quot;) = 3 所以 f(&quot;cbd&quot;) &lt; f(&quot;zaaaz&quot;)。 示例 2： 输入：queries = [&quot;bbb&quot;,&quot;cc&quot;], words = [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;] 输出：[1,2] 解释：第一个查询 f(&quot;bbb&quot;) &lt; f(&quot;aaaa&quot;)，第二个查询 f(&quot;aaa&quot;) 和 f(&quot;aaaa&quot;) 都 &gt; f(&quot;cc&quot;)。 提示： 1 &lt;= queries.length &lt;= 2000 1 &lt;= words.length &lt;= 2000 1 &lt;= queries[i].length, words[i].length &lt;= 10 queries[i][j], words[i][j] 都是小写英文字母 分析：遍历整个字符串，记录下整个字符串中最小字符出现次数，然后比较这个次数 代码：class Solution { public: vector&lt;int&gt; numSmallerByFrequency(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words) { vector&lt;int&gt; q; vector&lt;int&gt; w; vector&lt;int&gt; ret; for(int i = 0; i &lt; words.size(); i++){ char c = &apos;z&apos;; int x = 0; for(int j = 0; j &lt; words[i].size(); j++){ if(words[i][j] &lt; c){ c = words[i][j]; x = 1; } else if(words[i][j] == c){ x++; } } w.push_back(x); } for(int i = 0; i &lt; queries.size(); i++){ char c = &apos;z&apos;; int x = 0; for(int j = 0; j &lt; queries[i].size(); j++){ if(queries[i][j] &lt; c){ c = queries[i][j]; x = 1; } else if(queries[i][j] == c){ x++; } } q.push_back(x); } for(int i = 0; i &lt; q.size(); i++){ int z = 0; for(int j = 0; j &lt; w.size(); j++){ if(q[i] &lt; w[j]){ z++; } } ret.push_back(z); } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-151/problems/compare-strings-by-frequency-of-the-smallest-character/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1169. 查询无效交易]]></title>
    <url>%2F2019%2F08%2F26%2Fleetcode%201169.%20%E6%9F%A5%E8%AF%A2%E6%97%A0%E6%95%88%E4%BA%A4%E6%98%93%2F</url>
    <content type="text"><![CDATA[题目：如果出现下述两种情况，交易 可能无效： 交易金额超过 ¥1000或者，它和另一个城市中同名的另一笔交易相隔不超过 60 分钟（包含 60 分钟整）每个交易字符串 transactions[i] 由一些用逗号分隔的值组成，这些值分别表示交易的名称，时间（以分钟计），金额以及城市。 给你一份交易清单 transactions，返回可能无效的交易列表。你可以按任何顺序返回答案。 示例：示例 1： 输入：transactions = [&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;] 输出：[&quot;alice,20,800,mtv&quot;,&quot;alice,50,100,beijing&quot;] 解释：第一笔交易是无效的，因为第二笔交易和它间隔不超过 60 分钟、名称相同且发生在不同的城市。同样，第二笔交易也是无效的。 示例 2： 输入：transactions = [&quot;alice,20,800,mtv&quot;,&quot;alice,50,1200,mtv&quot;] 输出：[&quot;alice,50,1200,mtv&quot;] 示例 3： 输入：transactions = [&quot;alice,20,800,mtv&quot;,&quot;bob,50,1200,mtv&quot;] 输出：[&quot;bob,50,1200,mtv&quot;] 提示： transactions.length &lt;= 1000 每笔交易 transactions[i] 按 “{name},{time},{amount},{city}” 的格式进行记录 每个交易名称 {name} 和城市 {city} 都由小写英文字母组成，长度在 1 到 10 之间 每个交易时间 {time} 由一些数字组成，表示一个 0 到 1000 之间的整数 每笔交易金额 {amount} 由一些数字组成，表示一个 0 到 2000 之间的整数 分析：先转换成字符串组，然后挑出交易额大于1000的，再找出60分钟内在不同两地交易的，最后恢复成字符串格式存储 代码：class Solution { public: int zh(string s){ int z = 0; for(int i = 0; i &lt; s.size(); i++){ z = z * 10 + (s[i] - &apos;0&apos;); } return z; } vector&lt;string&gt; invalidTransactions(vector&lt;string&gt;&amp; transactions) { map&lt;string, vector&lt;vector&lt;string&gt;&gt;&gt; m; vector&lt;string&gt; vs; vector&lt;vector&lt;string&gt;&gt; vvs; for(int i = 0; i &lt; transactions.size(); i++){ // 转换成字符串组 vector&lt;string&gt; v; string s = &quot;&quot;; for(int j = 0; j &lt; transactions[i].size(); j++){ if(transactions[i][j] == &apos;,&apos;){ v.push_back(s); s = &quot;&quot;; } else{ s += transactions[i][j]; } } v.push_back(s); vvs.push_back(v); } for(int i = 0; i &lt; vvs.size(); i++){ // 找出交易额大于1000的 m[vvs[i][0]].push_back(vvs[i]); if(zh(vvs[i][2]) &gt; 1000){ string s = &quot;&quot;; for(int j = 0; j &lt; 4; j++){ s += vvs[i][j]; if(j != 3) s += &apos;,&apos;; } vs.push_back(s); } } for(auto a = m.begin(); a != m.end(); a++){ // 找出60分钟内在不同两地交易的 for(int i = 0; i &lt; a-&gt;second.size(); i++){ bool b = true; for(int j = 0; j &lt; a-&gt;second.size(); j++){ if(a-&gt;second[i][3] != a-&gt;second[j][3] &amp;&amp; (zh(a-&gt;second[i][1]) - zh(a-&gt;second[j][1]) &lt;= 60 &amp;&amp; zh(a-&gt;second[i][1]) - zh(a-&gt;second[j][1]) &gt;= -60)){ b = false; break; } } if(b == false){ string s = &quot;&quot;; for(int j = 0; j &lt; 4; j++){ s += a-&gt;second[i][j]; if(j != 3) s += &apos;,&apos;; } vs.push_back(s); } } } set&lt;string&gt; s(vs.begin(), vs.end()); // 去重 vs.assign(s.begin(), s.end()); return vs; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-151/problems/invalid-transactions/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1163. 按字典序排在最后的子串]]></title>
    <url>%2F2019%2F08%2F19%2Fleetcode%201163.%20%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E5%9C%A8%E6%9C%80%E5%90%8E%E7%9A%84%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目：给你一个字符串 s，找出它的所有子串并按字典序排列，返回排在最后的那个子串。 示例：示例 1： 输入：&quot;abab&quot; 输出：&quot;bab&quot; 解释：我们可以找出 7 个子串 [&quot;a&quot;, &quot;ab&quot;, &quot;aba&quot;, &quot;abab&quot;, &quot;b&quot;, &quot;ba&quot;, &quot;bab&quot;]。按字典序排在最后的子串是 &quot;bab&quot;。 示例 2： 输入：&quot;leetcode&quot; 输出：&quot;tcode&quot; 提示： 1 &lt;= s.length &lt;= 10^5 s 仅含有小写英文字符。 分析：一个从0开始，一个从1开始 如果一直相同，取长的 一旦不同，保留大的，将小的的起始位置定义到之前的结尾，这个过程中不会漏掉一个大的字符。因为，要漏掉大的字符，如果两个字符串距离只有1，就不会发生。除非，两个字符串之间有间距，但是要拉开间距需要其中一个字符串一直小于另外的字符串，就证明两个字符串之间没有比前一个字符串更大的字符 代码：class Solution { public: string lastSubstring(string s) { int i = 0; int j = 1; int k = 0; while(i + k != s.size() &amp;&amp; j + k != s.size()){ if(s[i+k] == s[j+k]) k++; else{ if(s[i+k] &lt; s[j+k]) i = i + k + 1; else j = j + k + 1; if(i == j) j++; k = 0; } } return s.substr(min(i, j), s.size()); } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-150/problems/last-substring-in-lexicographical-order/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1162. 地图分析]]></title>
    <url>%2F2019%2F08%2F19%2Fleetcode%201162.%20%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[题目：你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。 我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。 如果我们的地图上只有陆地或者海洋，请返回 -1。 示例：示例 1： 输入：[[1,0,1],[0,0,0],[1,0,1]] 输出：2 解释： 海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。 示例 2： 输入：[[1,0,0],[0,0,0],[0,0,0]] 输出：4 解释： 海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。 提示： 1 &lt;= grid.length == grid[0].length &lt;= 100 grid[i][j] 不是 0 就是 1 分析：统计出所有格子中0的数量 循环遍历，每次对每一个非0字符向四周扩散一个格子，直到0的格子为0为止，返回最后一次扩散的次数 代码：class Solution { public: int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n = 0; int x = 0; int z = 1; for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ if(grid[i][j] == 0){ n++; } } } if(n == 0 || n == grid.size() * grid[0].size()) return -1; while(n &gt; 0){ for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ if(grid[i][j] == z){ if(j + 1 &lt; grid[0].size() &amp;&amp; grid[i][j+1] == 0){ grid[i][j+1] = z+1; n--; } if(j - 1 &gt;= 0 &amp;&amp; grid[i][j-1] == 0) { grid[i][j-1] = z+1; n--; } if(i + 1 &lt; grid.size() &amp;&amp; grid[i+1][j] == 0){ grid[i+1][j] = z+1; n--; } if(i - 1 &gt;= 0 &amp;&amp; grid[i-1][j] == 0){ grid[i-1][j] = z+1; n--; } } } } if(n == 0){ x = z; } z++; } return x; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-150/problems/as-far-from-land-as-possible/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1161. 最大层内元素和]]></title>
    <url>%2F2019%2F08%2F19%2Fleetcode%201161.%20%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。 请你找出层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。 示例：输入：[1,7,0,7,-8,null,null]输出：2解释：第 1 层各元素之和为 1，第 2 层各元素之和为 7 + 0 = 7，第 3 层各元素之和为 7 + -8 = -1，所以我们返回第 2 层的层号，它的层内元素之和最大。 提示： 树中的节点数介于 1 和 10^4 之间 -10^5 &lt;= node.val &lt;= 10^5 分析：使用bfs 使用queue来存储结点，在一行的最后一个结点之后添加一个NULL来判断一行的结束 代码：/** Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} };/class Solution {public: int maxLevelSum(TreeNode root) { queue&lt;TreeNode*&gt; q; q.push(root); q.push(NULL); int x = 0; // 当前遍历到的结点 int m = 0; // 最大层数 int n = INT_MIN; // 最大层的和 int c = 1; // 当前层数 int v = 0; // 当前层结点和 while(q.size() != 0){ if(q.front() == NULL){ cout &lt;&lt; &quot;1&quot;; q.pop(); if(q.size() == 0) break; q.push(NULL); if(n &lt; v){ n = v; m = c; } c++; v = 0; x = 0; continue; } x++; v += q.front()-&gt;val; if(q.front()-&gt;left != NULL){ q.push(q.front()-&gt;left); } if(q.front()-&gt;right != NULL){ q.push(q.front()-&gt;right); } q.pop(); } return m; }}; 题目地址:https://leetcode-cn.com/contest/weekly-contest-150/problems/maximum-level-sum-of-a-binary-tree/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1160. 拼写单词]]></title>
    <url>%2F2019%2F08%2F19%2Fleetcode%201160.%20%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[题目：给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。 假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。 注意：每次拼写时，chars 中的每个字母都只能用一次。 返回词汇表 words 中你掌握的所有单词的 长度之和。 示例：示例 1： 输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot; 输出：6 解释： 可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。 示例 2： 输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot; 输出：10 解释： 可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。 提示： 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length, chars.length &lt;= 100 所有字符串中都仅包含小写英文字母 分析：使用map存储chars中各个字符数量 使用map的方式获取每一个字符串的字符数量，进行比较 代码：class Solution { public: int countCharacters(vector&lt;string&gt;&amp; words, string chars) { map&lt;char, int&gt; mci; int ret = 0; for(int i = 0; i &lt; chars.size(); i++){ mci[chars[i]]++; } for(int i = 0; i &lt; words.size(); i++){ map&lt;char, int&gt; mci1; for(int j = 0; j &lt; words[i].size(); j++){ mci1[words[i][j]]++; } bool b = true; for(auto m = mci1.begin(); m != mci1.end(); m++){ if(m-&gt;second &gt; mci[m-&gt;first]){ b = false; break; } } if(b) ret += words[i].size(); } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-150/problems/find-words-that-can-be-formed-by-characters/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记录程序运行时间]]></title>
    <url>%2F2019%2F08%2F18%2F%E8%AE%B0%E5%BD%95%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[clock_t startTime,endTime; //声明两个clock_t类型变量 startTime = clock();//计时开始 endTime = clock();//计时结束 cout &lt;&lt; (double)endTime - startTime &lt;&lt; &quot;\n&quot;; // 输出间隔时间]]></content>
      <categories>
        <category>c++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1157. 子数组中占绝大多数的元素]]></title>
    <url>%2F2019%2F08%2F12%2Fleetcode%201157.%20%E5%AD%90%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8D%A0%E7%BB%9D%E5%A4%A7%E5%A4%9A%E6%95%B0%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[题目：实现一个 MajorityChecker 的类，它应该具有下述几个 API： MajorityChecker(int[] arr) 会用给定的数组 arr 来构造一个 MajorityChecker 的实例。 int query(int left, int right, int threshold) 有这么几个参数： 0 &lt;= left &lt;= right &lt; arr.length 表示数组 arr 的子数组的长度。 2 * threshold &gt; right - left + 1，也就是说阀值 threshold 始终比子序列长度的一半还要大。 每次查询 query(…) 会返回在 arr[left], arr[left+1], …, arr[right] 中至少出现阀值次数 threshold 的元素，如果不存在这样的元素，就返回 -1。 示例：MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]); majorityChecker.query(0,5,4); // 返回 1 majorityChecker.query(0,3,3); // 返回 -1 majorityChecker.query(2,3,2); // 返回 2 提示： 1 &lt;= arr.length &lt;= 20000 1 &lt;= arr[i] &lt;= 20000 对于每次查询，0 &lt;= left &lt;= right &lt; len(arr) 对于每次查询，2 * threshold &gt; right - left + 1 查询次数最多为 10000 分析：初始化就直接拷贝一份数组 一开始我将区间内所有的数统计起来，但是居然会超时，然后就使用下面的方法 因为需要的数字出现的数量一定是要大于所有数字的一半的。所以遍历区间，遇到相同的数时数量加一，遇到不同的数时数量减一，如果减到0，就换成最新的数，将数量重置为1。 然后统计这个数的数量是否大于threshold即可 代码：class MajorityChecker { private: vector&lt;int&gt; vi; public: MajorityChecker(vector&lt;int&gt;&amp; arr) { vi = arr; } int query(int left, int right, int threshold) { int z = 0; int x = 0; int r = 0; for(int i = left; i &lt;= right; i++){ if(z == 0){ z = 1; x = vi[i]; } else if(x == vi[i]) z++; else z--; } for(int i = left; i &lt;= right; i++){ if(x == vi[i]){ r++; } } if(r &gt;= threshold) return x; return -1; } }; /** * Your MajorityChecker object will be instantiated and called as such: * MajorityChecker* obj = new MajorityChecker(arr); * int param_1 = obj-&gt;query(left,right,threshold); */ 题目地址：https://leetcode-cn.com/contest/weekly-contest-149/problems/online-majority-element-in-subarray/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1156. 单字符重复子串的最大长度]]></title>
    <url>%2F2019%2F08%2F12%2Fleetcode%201156.%20%E5%8D%95%E5%AD%97%E7%AC%A6%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目：如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。 给你一个字符串 text，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。 示例：示例 1： 输入：text = &quot;ababa&quot; 输出：3 示例 2： 输入：text = &quot;aaabaaa&quot; 输出：6 示例 3： 输入：text = &quot;aaabbaaa&quot; 输出：4 示例 4： 输入：text = &quot;aaaaa&quot; 输出：5 示例 5： 输入：text = &quot;abcdef&quot; 输出：1 提示： 1 &lt;= text.length &lt;= 20000 text 仅由小写英文字母组成。 分析：使用两个数组存储每个连续字符段开头出现的位置和数量，将两段只隔了一个字符的连接在一起计算。统计所有字符串中最长的长度 代码：class Solution { public: int maxRepOpt1(string text) { vector&lt;vector&lt;int&gt;&gt; v(26); vector&lt;vector&lt;int&gt;&gt; v1(26); int m[26] = {0}; char c = text[0]; int z = 1; int l = 0; for(int i = 1; i &lt; text.size(); i++){ if(text[i] == c){ z++; } else { v[c - &apos;a&apos;].push_back(l); v1[c - &apos;a&apos;].push_back(z); c = text[i]; l = i; z = 1; } } v[c - &apos;a&apos;].push_back(l); v1[c - &apos;a&apos;].push_back(z); for(int i = 0; i &lt; v.size(); i++){ if(v1[i].size() &gt; 1) m[i] = v1[i][0]+1; else if(v1[i].size() == 1) m[i] = v1[i][0]; for(int j = 1; j &lt; v[i].size(); j++){ if(v[i][j-1] + v1[i][j-1]+1 == v[i][j]){ if(v[i].size() &gt; 2){ m[i] = max(m[i], v1[i][j] + v1[i][j-1] + 1); } else{ m[i] = max(m[i], v1[i][j] + v1[i][j-1]); cout &lt;&lt; v[i].size() &lt;&lt; &quot; &quot; ; } } else{ if(v[i].size() &gt; 1){ m[i] = max(m[i], v1[i][j]+1); cout &lt;&lt; v1[i][j] &lt;&lt; &quot; &quot;; } else m[i] = max(m[i], v1[i][j]); } } } int ret = 0; for(int i = 0; i &lt; 26; i++){ ret = max(ret, m[i]); } return ret; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-149/problems/swap-for-maximum-repeated-substring/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1155. 掷骰子的N种方法]]></title>
    <url>%2F2019%2F08%2F12%2Fleetcode%201155.%20%E6%8E%B7%E9%AA%B0%E5%AD%90%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目：这里有 d 个一样的骰子，每个骰子上都有 f 个面，分别标号为 1, 2, …, f。 我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。 如果需要掷出的总点数为 target，请你计算出有多少种不同的组合情况（所有的组合情况总共有 f^d 种），模 10^9 + 7 后返回。 示例：示例 1： 输入：d = 1, f = 6, target = 3 输出：1 示例 2： 输入：d = 2, f = 6, target = 7 输出：6 示例 3： 输入：d = 2, f = 5, target = 10 输出：1 示例 4： 输入：d = 1, f = 2, target = 3 输出：0 示例 5： 输入：d = 30, f = 30, target = 500 输出：222616187 提示： 1 &lt;= d, f &lt;= 30 1 &lt;= target &lt;= 1000 分析：动态规划 dp[i][k],表示使用i个骰子投出k点的组合情况 dp[i][k] += dp[i-1][k-j],j代表最后一个骰子的点数 代码：class Solution { public: int numRollsToTarget(int d, int f, int target) { int dp[31][1001] = {0}; dp[0][0] = 1; for(int i = 1; i &lt;= d; i++){ for(int j = 1; j &lt;= f; j++){ for(int k = j; k &lt;= d*f; k++){ dp[i][k] += dp[i-1][k-j]; dp[i][k] %= 1000000007; } } } return dp[d][target]; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-149/problems/number-of-dice-rolls-with-target-sum/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1154. 一年中的第几天]]></title>
    <url>%2F2019%2F08%2F12%2Fleetcode%201154.%20%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[题目：给你一个按 YYYY-MM-DD 格式表示日期的字符串 date，请你计算并返回该日期是当年的第几天。 通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。 示例：示例 1： 输入：date = &quot;2019-01-09&quot; 输出：9 示例 2： 输入：date = &quot;2019-02-10&quot; 输出：41 示例 3： 输入：date = &quot;2003-03-01&quot; 输出：60 示例 4： 输入：date = &quot;2004-03-01&quot; 输出：61 提示： date.length == 10 date[4] == date[7] == ‘-‘，其他的 date[i] 都是数字。 date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日。 分析：注意一下闰年 代码：class Solution { public: int ordinalOfDate(string date) { int n = 0; int y = 0; int r = 0; n += date[0] - &apos;0&apos;; cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; r; n *= 10; n += date[1] - &apos;0&apos;; n *= 10; n += date[2] - &apos;0&apos;; n *= 10; n += date[3] - &apos;0&apos;; y += date[5] - &apos;0&apos;; y *= 10; y += date[6] - &apos;0&apos;; r += date[8] - &apos;0&apos;; r *= 10; r += date[9] - &apos;0&apos;; int ret = 0; if(n % 4 == 0 &amp;&amp; n % 100 != 0 || n % 400 == 0) { if(y &gt;= 1){ } if(y &gt;= 2){ ret += 31; } if(y &gt;= 3){ ret += 29; } if(y &gt;= 4){ ret += 31; } if(y &gt;= 5){ ret += 30; } if(y &gt;= 6){ ret += 31; } if(y &gt;= 7){ ret += 30; } if(y &gt;= 8){ ret += 31; } if(y &gt;= 9){ ret += 31; } if(y &gt;= 10){ ret += 30; } if(y &gt;= 11){ ret += 31; } if(y &gt;= 12){ ret += 30; } ret += r; } else { if(y &gt;= 1){ } if(y &gt;= 2){ ret += 31; } if(y &gt;= 3){ ret += 28; } if(y &gt;= 4){ ret += 31; } if(y &gt;= 5){ ret += 30; } if(y &gt;= 6){ ret += 31; } if(y &gt;= 7){ ret += 30; } if(y &gt;= 8){ ret += 31; } if(y &gt;= 9){ ret += 31; } if(y &gt;= 10){ ret += 30; } if(y &gt;= 11){ ret += 31; } if(y &gt;= 12){ ret += 30; } ret += r; } return ret; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-149/problems/ordinal-number-of-date/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android studio安装和使用]]></title>
    <url>%2F2019%2F08%2F05%2FAndroid%20studio%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.下载安装配置Java JDK JDK 下载地址：https://www.oracle.com/technetwork/java/javase/downloads/index.html 配置JAVA环境变量 右键 “此电脑”， 选择 “属性” - &gt; “高级” - &gt; “环境变量” 在系统环境变量里添加一个JAVA_HOME变量，变量值为JDK在你电脑上的安装路径C:\Program Files\Java\jdk-12.0.2。创建好后则可以利用%JAVA_HOME%作为JDK安装目录的统一引用路径。 PATH属性已存在，可新建变量：%JAVA_HOME%\bin; 添加类路径环境变量，如下添加一个CLASSPATH。变量值为:.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar。注意变量值字符串前面有一个”.”表示当前目录，设置CLASSPATH 的目的，在于告诉Java执行环境，在哪些目录下可以找到您所要执行的Java程序所需要的类或者包。 测试JAVA安装 打开CMD终端，输入以下命令，如果能看到JAVA版本信息就说明安装成功了。 java -version 中途因为不知名原因版本号一直不是最新的，然后在path中将%JAVA_HOME%\bin;上移到最高就解决了 2.下载Android Studio下载地址： http://android-studio.org/https://developer.android.google.cn/studio/ (要vpn) http://www.android-studio.org/index.php 3.安装一路next，中途可选安装位置 在首次安装的情况下，选择第二项不导入之前版本的配置Do not import settings 在启动会出现Unable to access Android SDK add-on list，点击Cancel 出现向导界面，点击next 选择安装类型，选择Standard 选择UI主题 会弹窗，提示SDK安装的位置，如果要该路径，前面选择Custom 开始下载SDK组件 本文章参考了 https://www.cnblogs.com/xiaoleiel/p/11160798.htmlhttps://www.cnblogs.com/xifengxiaoma/p/10832997.html]]></content>
      <categories>
        <category>Android studio</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1147. 段式回文]]></title>
    <url>%2F2019%2F08%2F05%2Fleetcode%201147.%20%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87%2F</url>
    <content type="text"><![CDATA[题目：段式回文 其实与 一般回文 类似，只不过是最小的单位是 一段字符 而不是 单个字母。 举个例子，对于一般回文 “abcba” 是回文，而 “volvo” 不是，但如果我们把 “volvo” 分为 “vo”、”l”、”vo” 三段，则可以认为 “(vo)(l)(vo)” 是段式回文（分为 3 段）。 给你一个字符串 text，在确保它满足段式回文的前提下，请你返回 段 的 最大数量 k。 如果段的最大数量为 k，那么存在满足以下条件的 a_1, a_2, …, a_k： 每个 a_i 都是一个非空字符串； 将这些字符串首位相连的结果 a_1 + a_2 + … + a_k 和原始字符串 text 相同； 对于所有1 &lt;= i &lt;= k，都有 a_i = a_{k+1 - i}。 示例：示例 1： 输入：text = &quot;ghiabcdefhelloadamhelloabcdefghi&quot; 输出：7 解释：我们可以把字符串拆分成 &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;。 示例 2： 输入：text = &quot;merchant&quot; 输出：1 解释：我们可以把字符串拆分成 &quot;(merchant)&quot;。 示例 3： 输入：text = &quot;antaprezatepzapreanta&quot; 输出：11 解释：我们可以把字符串拆分成 &quot;(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)&quot;。 示例 4： 输入：text = &quot;aaa&quot; 输出：3 解释：我们可以把字符串拆分成 &quot;(a)(a)(a)&quot;。 提示： text 仅由小写英文字符组成。 1 &lt;= text.length &lt;= 1000 分析：三种方法，DFS，dp，贪心 DFS复杂度最高，但也可以通过 dp复杂度中等 dp[i]表示到i为止最佳的拆分方法 如果字符串第i到第j等于相对的那一组，dp[i] = max(dp[j] + 2, dp[i]),其中的j&lt;i 贪心的复杂度最低 代码：class Solution { private: int len; public: void dg(string text, int z, int x){ for(int i = 1; i &lt;= (text.size() - z*2)/2; i++){ string s1 = text.substr(z, i); string s2 = text.substr(text.size() - z - i, i); // cout &lt;&lt; s1 &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;; if(s1 == s2) { dg(text, z + i, ++x); } if(i * 2 + z * 2 == text.size()){ if(len &lt; x*2){ len = x*2; } } else { if(len &lt; x*2+1){ len = x*2+1; } } } } int longestDecomposition(string text) { len = 1; dg(text, 0, 0); return len; } }; 题目地址: https://leetcode-cn.com/contest/weekly-contest-148/problems/longest-chunked-palindrome-decomposition/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1146. 快照数组]]></title>
    <url>%2F2019%2F08%2F05%2Fleetcode%201146.%20%E5%BF%AB%E7%85%A7%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：实现支持下列接口的「快照数组」- SnapshotArray： SnapshotArray(int length) - 初始化一个与指定长度相等的 类数组 的数据结构。初始时，每个元素都等于 0。 void set(index, val) - 会将指定索引 index 处的元素设置为 val。 int snap() - 获取该数组的快照，并返回快照的编号 snap_id（快照号是调用 snap() 的总次数减去 1）。 int get(index, snap_id) - 根据指定的 snap_id 选择快照，并返回该快照指定索引 index 的值。 示例：输入：[&quot;SnapshotArray&quot;,&quot;set&quot;,&quot;snap&quot;,&quot;set&quot;,&quot;get&quot;] [[3],[0,5],[],[0,6],[0,0]] 输出：[null,null,0,null,5] 解释： SnapshotArray snapshotArr = new SnapshotArray(3); // 初始化一个长度为 3 的快照数组 snapshotArr.set(0,5); // 令 array[0] = 5 snapshotArr.snap(); // 获取快照，返回 snap_id = 0 snapshotArr.set(0,6); snapshotArr.get(0,0); // 获取 snap_id = 0 的快照中 array[0] 的值，返回 5 提示： 1 &lt;= length &lt;= 50000 题目最多进行50000 次set，snap，和 get的调用 。 0 &lt;= index &lt; length 0 &lt;= snap_id &lt; 我们调用 snap() 的总次数 0 &lt;= val &lt;= 10^9 分析：这道题使用vector存储会超内存，所以使用map来存储 代码：class SnapshotArray { private: map&lt;int, int&gt; array; vector&lt;map&lt;int, int&gt;&gt; vii; public: SnapshotArray(int length) { } void set(int index, int val) { array[index] = val; } int snap() { vii.push_back(array); return vii.size()-1; } int get(int index, int snap_id) { return vii[snap_id][index]; } }; /** * Your SnapshotArray object will be instantiated and called as such: * SnapshotArray* obj = new SnapshotArray(length); * obj-&gt;set(index,val); * int param_2 = obj-&gt;snap(); * int param_3 = obj-&gt;get(index,snap_id); */ 题目地址：https://leetcode-cn.com/contest/weekly-contest-148/problems/snapshot-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1145. 二叉树着色游戏]]></title>
    <url>%2F2019%2F08%2F05%2Fleetcode%201145.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9D%80%E8%89%B2%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[题目：有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 root，树上总共有 n 个节点，且 n 为奇数，其中每个节点上的值从 1 到 n 各不相同。 游戏从「一号」玩家开始（「一号」玩家为红色，「二号」玩家为蓝色），最开始时， 「一号」玩家从 [1, n] 中取一个值 x（1 &lt;= x &lt;= n）； 「二号」玩家也从 [1, n] 中取一个值 y（1 &lt;= y &lt;= n）且 y != x。 「一号」玩家给值为 x 的节点染上红色，而「二号」玩家给值为 y 的节点染上蓝色。 之后两位玩家轮流进行操作，每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 未着色 的邻节点（即左右子节点、或父节点）进行染色。 如果当前玩家无法找到这样的节点来染色时，他的回合就会被跳过。 若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌。 现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 y 值可以确保你赢得这场游戏，则返回 true；若无法获胜，就请返回 false。 示例： 输入：root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3 输出：True 解释：第二个玩家可以选择值为 2 的节点。 提示： 二叉树的根节点为 root，树上由 n 个节点，节点上的值从 1 到 n 各不相同。 n 为奇数。 1 &lt;= x &lt;= n &lt;= 100 分析：有三种选择方法可以最大化，选红色结点父节点那一块，选红色结点左子树那一块，选红色结点右子树那一块。 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { private: vector&lt;int&gt; vi; public: void dg(TreeNode* root, int z, int x){ // z==0时，代表x父节点那片；z==1时，代表x左子树；z==2时，代表x右子树 if(root == NULL) return; if(x == root-&gt;val) { dg(root-&gt;left, 1, x); dg(root-&gt;right, 2, x); } else{ if(z == 0) vi[0]++; if(z == 1) vi[1]++; if(z == 2) vi[2]++; dg(root-&gt;left, z, x); dg(root-&gt;right, z, x); } } bool btreeGameWinningMove(TreeNode* root, int n, int x) { vi.push_back(0); vi.push_back(0); vi.push_back(0); dg(root, 0, x); sort(vi.begin(), vi.end()); cout &lt;&lt; vi[0] &lt;&lt; &quot; &quot;&lt;&lt; vi[1] &lt;&lt; &quot; &quot;&lt;&lt; vi[2]; if(vi[2] &gt; n - vi[2]){ return true; } return false; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-148/problems/binary-tree-coloring-game/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5147. 递减元素使数组呈锯齿状]]></title>
    <url>%2F2019%2F08%2F05%2Fleetcode%201144.%20%E9%80%92%E5%87%8F%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%91%88%E9%94%AF%E9%BD%BF%E7%8A%B6%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数数组 nums，每次 操作 会从中选择一个元素并 将该元素的值减少 1。 如果符合下列情况之一，则数组 A 就是 锯齿数组： 每个偶数索引对应的元素都大于相邻的元素，即 A[0] &gt; A[1] &lt; A[2] &gt; A[3] &lt; A[4] &gt; … 或者，每个奇数索引对应的元素都大于相邻的元素，即 A[0] &lt; A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; …返回将数组 nums 转换为锯齿数组所需的最小操作次数。 示例：示例 1： 输入：nums = [1,2,3] 输出：2 解释：我们可以把 2 递减到 0，或把 3 递减到 1。 示例 2： 输入：nums = [9,6,1,6,2] 输出：4 提示： 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 1000 分析：只能减少元素的值，所以要么减少奇数位置的值，要么减少偶数位置的值，选择两种之间需要操作次数少的那个 代码：class Solution { public: int movesToMakeZigzag(vector&lt;int&gt;&amp; nums) { int z1 = 0; int z2 = 0; for(int i = 0; i &lt; nums.size(); i++){ if(i % 2 == 0){ // 偶数小 for(int n = nums[i]; (i+1 &lt; nums.size() &amp;&amp; n &gt;= nums[i+1]) || (i-1 &gt;= 0 &amp;&amp; n &gt;= nums[i-1]); n--) { z1++; } } } for(int i = 1; i &lt; nums.size(); i++){ if(i % 2 == 1){ // 奇数小 for(int n = nums[i]; (i+1 &lt; nums.size() &amp;&amp;n &gt;= nums[i+1]) || (i-1 &gt;= 0 &amp;&amp; n &gt;= nums[i-1]); n--) { z2++; } } } return min(z1, z2); } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-148/problems/decrease-elements-to-make-array-zigzag/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1140. 石子游戏 II]]></title>
    <url>%2F2019%2F07%2F29%2Fleetcode%201140.%20%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%20II%2F</url>
    <content type="text"><![CDATA[题目：亚历克斯和李继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。 亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。 在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 &lt;= X &lt;= 2M。然后，令 M = max(M, X)。 游戏一直持续到所有石子都被拿走。 假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。 示例：输入：piles = [2,7,9,4,4] 输出：10 解释： 如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。 如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。 所以我们返回更大的 10。 提示： 1 &lt;= piles.length &lt;= 100 1 &lt;= piles[i] &lt;= 10 ^ 4 分析：使用dfs来使亚历克斯和李都选择最佳的石子数量 中途使用map来存储已经计算过的情况 代码：class Solution { private: map&lt;int, map&lt;int,int&gt;&gt; mii; // 用来存储已经算过的情况 public: int dfs(vector&lt;int&gt;&amp; piles, int z, int m){ if(z == piles.size()) // 石子全部拿完 return 0; if(z + m * 2 &gt; piles.size()){ // 剩下的石子可以全部拿完 return accumulate(piles.begin() + z, piles.end(), 0); } if(mii[z][m] != 0) // 已经计算过的情况 return mii[z][m]; int q = INT_MIN; for(int i = 1; i &lt;= 2 * m; i++){ // 遍历每种石子的数量 q = max(q, accumulate(piles.begin() + z, piles.begin() + z + i, 0) - dfs(piles, z + i, max(i, m))); } mii[z][m] = q; return q; } int stoneGameII(vector&lt;int&gt;&amp; piles) { return (accumulate(piles.begin(), piles.end(), 0) + dfs(piles, 0, 1)) / 2; } }; 题目地址: https://leetcode-cn.com/contest/weekly-contest-147/problems/stone-game-ii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1139. 最大的以 1 为边界的正方形]]></title>
    <url>%2F2019%2F07%2F29%2Fleetcode%201139.%20%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BB%A5%201%20%E4%B8%BA%E8%BE%B9%E7%95%8C%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[题目：给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。 示例：示例 1： 输入：grid = [[1,1,1],[1,0,1],[1,1,1]] 输出：9 示例 2： 输入：grid = [[1,1,0,0]] 输出：1 提示： 1 &lt;= grid.length &lt;= 100 1 &lt;= grid[0].length &lt;= 100 grid[i][j] 为 0 或 1 分析：存储每一个点往上和往左连续的1 从每个点左侧连续的第一个1开始遍历，判断是否可以构成正方形 代码：class Solution { public: int largest1BorderedSquare(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int g[grid.size()][grid[0].size()] = {0}; int g1[grid.size()][grid[0].size()] = {0}; //cout &lt;&lt; g[0][1] &lt;&lt; &quot;\n&quot;; int m = 1; bool b = true; for(int i = 0; i &lt; grid.size() &amp;&amp; b; i++){ for(int j = 0; j &lt; grid[0].size() &amp;&amp; b; j++){ if(grid[i][j] == 1) b = false; } } for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ g[i][j] = 0; //cout &lt;&lt; g[i][j] &lt;&lt; &quot; &quot;; } //cout &lt;&lt; &quot;\n&quot;; } //cout &lt;&lt; &quot;\n&quot;; if(b) return 0; if(grid.size() == 1 || grid[0].size() == 1) return 1; for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ if(grid[i][j] == 1){ if(j != 0) g[i][j] = g[i][j-1] + 1; else g[i][j] = 1; } } } for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ if(grid[i][j] == 1){ if(i != 0) g1[i][j] = g1[i-1][j] + 1; else g1[i][j] = 1; } } } // for(int i = 0; i &lt; grid.size(); i++){ // for(int j = 0; j &lt; grid[0].size(); j++){ // cout &lt;&lt; g1[i][j] &lt;&lt; &quot; &quot;; // } // cout &lt;&lt; &quot;\n&quot;; // } //cout &lt;&lt; g[0][1] &lt;&lt; &quot;\n&quot;; for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ for(int k = j - g[i][j] + 1; k &lt; j; k++){ //cout &lt;&lt; k &lt;&lt; &quot; &quot;; if(i+j-k &lt; grid.size() &amp;&amp; g[i+j-k][j] &gt;= j - k &amp;&amp; g1[i+j-k][k] &gt;= j - k &amp;&amp; g1[i+j-k][j] &gt;= j - k){ m = max(m, (j - k+1) * (j - k+1)); } } } } return m; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-147/problems/largest-1-bordered-square/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1138. 字母板上的路径]]></title>
    <url>%2F2019%2F07%2F29%2Fleetcode%201138.%20%E5%AD%97%E6%AF%8D%E6%9D%BF%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目：我们从一块字母板上的位置 (0, 0) 出发，该坐标对应的字符为 board[0][0]。 在本题里，字母板为board = [“abcde”, “fghij”, “klmno”, “pqrst”, “uvwxy”, “z”]. 我们可以按下面的指令规则行动： 如果方格存在，’U’ 意味着将我们的位置上移一行； 如果方格存在，’D’ 意味着将我们的位置下移一行； 如果方格存在，’L’ 意味着将我们的位置左移一列； 如果方格存在，’R’ 意味着将我们的位置右移一列； ‘!’ 会把在我们当前位置 (r, c) 的字符 board[r][c] 添加到答案中。 返回指令序列，用最小的行动次数让答案和目标 target 相同。你可以返回任何达成目标的路径。 示例：示例 1： 输入：target = &quot;leet&quot; 输出：&quot;DDR!UURRR!!DDD!&quot; 示例 2： 输入：target = &quot;code&quot; 输出：&quot;RR!DDRR!UUL!R!&quot; 提示： 1 &lt;= target.length &lt;= 100 target 仅含有小写英文字母。 分析：计算坐标，两坐标相减得到移动方向和次数。唯一需要注意的就是z这一排只有一个，所以移动顺序改为先往上再往右，先往左再往下 代码：class Solution { public: int fhx(char c){ return (c - &apos;a&apos;) % 5; } int fhy(char c){ return (c - &apos;a&apos;) / 5; } string alphabetBoardPath(string target) { int x = 0; int y = 0; string str = &quot;&quot;; for(int i = 0; i &lt; target.size(); i++){ int x1 = fhx(target[i]); int y1 = fhy(target[i]); cout &lt;&lt; x1 &lt;&lt; &quot; &quot; &lt;&lt; y1; int xx = x1 - x; int yy = y1 - y; while(xx &lt; 0){ str += &apos;L&apos;; xx++; } while(yy &gt; 0){ str += &apos;D&apos;; yy--; } while(yy &lt; 0){ str += &apos;U&apos;; yy++; } while(xx &gt; 0){ str += &apos;R&apos;; xx--; } str += &apos;!&apos;; x = x1; y = y1; } return str; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-147/problems/alphabet-board-path/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1137. 第 N 个泰波那契数]]></title>
    <url>%2F2019%2F07%2F29%2Fleetcode%201137.%20%E7%AC%AC%20N%20%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n &gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2 给你整数 n，请返回第 n 个泰波那契数 Tn 的值。 示例：示例 1： 输入：n = 4 输出：4 解释： T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 示例 2： 输入：n = 25 输出：1389537 提示： 0 &lt;= n &lt;= 37 答案保证是一个 32 位整数，即 answer &lt;= 2^31 - 1。 分析声明数组存储三位，每次更新 代码：class Solution { public: int tribonacci(int n) { int ret = 1; int z[3] = {0, 1, 1}; if(n == 0) return 0; if(n == 1) return 1; if(n == 2) return 1; for(int i = 3; i &lt;= n; i++){ ret = z[0] + z[1] + z[2]; z[0] = z[1]; z[1] = z[2]; z[2] = ret; cout &lt;&lt; ret &lt;&lt; &quot; &quot;; } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-147/problems/n-th-tribonacci-number/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1130. 叶值的最小代价生成树]]></title>
    <url>%2F2019%2F07%2F22%2Fleetcode%201130.%20%E5%8F%B6%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目：给你一个正整数数组 arr，考虑所有满足以下条件的二叉树： 每个节点都有 0 个或是 2 个子节点。数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。 示例：输入：arr = [6,2,4] 输出：32 解释： 有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。 24 24 / \ / \ 12 4 6 8 / \ / \ 6 2 2 4 提示： 2 &lt;= arr.length &lt;= 40 1 &lt;= arr[i] &lt;= 15 答案保证是一个 32 位带符号整数，即小于 2^31。 分析：第一种是dp，dp[i][j] = min(dp[i][k] + dp[k+1][j] + 左右子树最大的值相乘的结果, dp[i][j]) dp[i][j] 存储从i到j最小的非叶结点的的和，k 是i和j中间的一个数 先遍历所有两个叶节点为一棵树的结果，然后三个叶节点，四个，五个。。。。 第二种办法，每次相乘相当于去掉了两个乘数之间较小的那个乘数，产生了乘积这么多的消耗，为了让消耗的值小，每次遍历找到最小的那个数，从左右选择一个较小的数相乘，将相乘结果记录下来，再去掉这个最小的数 代码：class Solution { public: int mctFromLeafValues(vector&lt;int&gt;&amp; arr) { int m = 100; int m1 = 0; int ret = 0; while(arr.size() &gt; 1){ for(int i = 0; i &lt; arr.size(); i++){ if(arr[i] &lt; m){ m = arr[i]; m1 = i; } } if(m1-1 &gt;= 0 &amp;&amp; m1+1 &lt; arr.size()){ if(arr[m1-1] &lt; arr[m1+1]) ret += arr[m1-1] * arr[m1]; else ret += arr[m1+1] * arr[m1]; } else if(m1-1 &lt; 0) ret += arr[m1+1] * arr[m1]; else ret += arr[m1-1] * arr[m1]; arr.erase(arr.begin()+m1); m1 = 0; m = 100; cout &lt;&lt; arr.size() &lt;&lt; &quot; &quot;; } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-146/problems/minimum-cost-tree-from-leaf-values/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1129. 颜色交替的最短路径]]></title>
    <url>%2F2019%2F07%2F22%2Fleetcode%201129.%20%E9%A2%9C%E8%89%B2%E4%BA%A4%E6%9B%BF%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目：在一个有向图中，节点分别标记为 0, 1, …, n-1。这个图中的每条边不是红色就是蓝色，且存在自环或平行边。 red_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的红色有向边。类似地，blue_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的蓝色有向边。 返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的最短路径的长度，且路径上红色边和蓝色边交替出现。如果不存在这样的路径，那么 answer[x] = -1。 示例：示例 1： 输入：n = 3, red_edges = [[0,1],[1,2]], blue_edges = [] 输出：[0,1,-1] 示例 2： 输入：n = 3, red_edges = [[0,1]], blue_edges = [[2,1]] 输出：[0,1,-1] 示例 3： 输入：n = 3, red_edges = [[1,0]], blue_edges = [[2,1]] 输出：[0,-1,-1] 示例 4： 输入：n = 3, red_edges = [[0,1]], blue_edges = [[1,2]] 输出：[0,1,2] 示例 5： 输入：n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]] 输出：[0,1,1] 提示： 1 &lt;= n &lt;= 100 red_edges.length &lt;= 400 blue_edges.length &lt;= 400 red_edges[i].length == blue_edges[i].length == 2 0 &lt;= red_edges[i][j], blue_edges[i][j] &lt; n 分析：建立两个双重map用来存储两种颜色的有向边 建立两个vector，用来存储用到达每个点每个颜色用的最少的步数 代码：class Solution { public: vector&lt;int&gt; shortestAlternatingPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; red_edges, vector&lt;vector&lt;int&gt;&gt;&amp; blue_edges) { vector&lt;int&gt; rvi(n, 1000); vector&lt;int&gt; bvi(n, 1000); vector&lt;int&gt; ret(n, 0); if(rvi.size() != 0) rvi[0] = 0; if(bvi.size() != 0) bvi[0] = 0; map&lt;int, map&lt;int, int&gt;&gt; red; map&lt;int, map&lt;int, int&gt;&gt; blue; for(int i = 0; i &lt; red_edges.size(); i++){ red[red_edges[i][0]][red_edges[i][1]] = 1; } for(int i = 0; i &lt; blue_edges.size(); i++){ blue[blue_edges[i][0]][blue_edges[i][1]] = 1; } bool b = 1; while(b){ b = 0; for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; n; j++){ if(bvi[j] != 1000 &amp;&amp; red[j][i] == 1 &amp;&amp; rvi[i] &gt; bvi[j] + 1){ // red[j][i]代表上一条有向边为红色的从j到i的最短路径 rvi[i] = bvi[j]+1; b = 1; } if(rvi[j] != 1000 &amp;&amp; blue[j][i] == 1 &amp;&amp; bvi[i] &gt; rvi[j] + 1){ // blue[j][i]代表上一条有向边为蓝色的从j到i的最短路径 bvi[i] = rvi[j]+1; b = 1; } ret[i] = rvi[i] &lt; bvi[i] ? rvi[i] : bvi[i]; if(ret[i] == 1000) ret[i] = -1; } } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-146/problems/shortest-path-with-alternating-colors/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1128. 等价多米诺骨牌对的数量]]></title>
    <url>%2F2019%2F07%2F22%2Fleetcode%201128.%20%E7%AD%89%E4%BB%B7%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：给你一个由一些多米诺骨牌组成的列表 dominoes。 如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。 形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。 在 0 &lt;= i &lt; j &lt; dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。 示例：输入：dominoes = [[1,2],[2,1],[3,4],[5,6]] 输出：1 提示： 1 &lt;= dominoes.length &lt;= 40000 1 &lt;= dominoes[i][j] &lt;= 9 分析：先将骨牌全部翻转成小的在前面，大的在后面的格式，统计相同的骨牌数量，计算对数 代码：class Solution { public: int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) { for(int i = 0 ; i &lt; dominoes.size(); i++){ sort(dominoes[i].begin(), dominoes[i].end()); } sort(dominoes.begin(), dominoes.end()); int a = 0; int b = 0; int z = 1; int x = 0; int ret = 0; for(int i = 0; i &lt; dominoes.size(); i++){ if(dominoes[i][0] == a &amp;&amp; dominoes[i][1] == b){ z++; } else { for(int i = z - 1; i &gt; 0; i--){ ret += i; } a = dominoes[i][0]; b = dominoes[i][1]; z = 1; } } for(int i = z - 1; i &gt; 0; i--) ret += i; return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-146/problems/number-of-equivalent-domino-pairs/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5128. 最深叶节点的最近公共祖先]]></title>
    <url>%2F2019%2F07%2F15%2Fleetcode%205128.%20%E6%9C%80%E6%B7%B1%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[题目：给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。 回想一下： 叶节点 是二叉树中没有子节点的节点 树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1 如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。 示例：示例 1： 输入：root = [1,2,3] 输出：[1,2,3] 示例 2： 输入：root = [1,2,3,4] 输出：[4] 示例 3： 输入：root = [1,2,3,4,5] 输出：[2,4,5] 提示： 给你的树中将有 1 到 1000 个节点。 树中每个节点的值都在 1 到 1000 之间。 分析：先获取最深的深度 递归，如果左子树和右子树都有最深结点或者自身为最深结点，返回1，并且记录下当前结点 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { private: int sd; TreeNode* t; public: void dgqs(TreeNode* root, int s){ if(root-&gt;left != NULL){ dgqs(root-&gt;left, s+1); } if(root-&gt;right != NULL){ dgqs(root-&gt;right, s+1); } if(s &gt; sd) sd = s; } int dg(TreeNode* root, int s){ int l = 0; int r = 0; if(root-&gt;left != NULL){ l = dg(root-&gt;left, s+1); } if(root-&gt;right != NULL){ r = dg(root-&gt;right, s+1); } if(s == sd){ t = root; return 1; } if(root-&gt;left != NULL &amp;&amp; l == 1 &amp;&amp; root-&gt;right != NULL &amp;&amp; r == 1){ t = root; return 1; } if(root-&gt;left != NULL &amp;&amp; l == 1){ return 1; } if(root-&gt;right != NULL &amp;&amp; r == 1){ return 1; } return 0; } TreeNode* lcaDeepestLeaves(TreeNode* root) { sd = 0; dgqs(root, 0); dg(root, 0); return t; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-145/problems/lowest-common-ancestor-of-deepest-leaves/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5127. 数组的相对排序]]></title>
    <url>%2F2019%2F07%2F15%2Fleetcode%205127.%20%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目：给你两个数组，arr1 和 arr2， arr2 中的元素各不相同 arr2 中的每个元素都出现在 arr1 中 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。 示例：输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19] 提示： arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 arr2 中的元素 arr2[i] 各不相同 arr2 中的每个元素 arr2[i] 都出现在 arr1 中 分析：使用map存arr1中每个字符的数量，根据arr2的顺序将arr1中的字符排序 代码：class Solution { public: vector&lt;int&gt; relativeSortArray(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) { map&lt;int, int&gt; mi; vector&lt;int&gt; vi; for(int i = 0; i &lt; arr1.size(); i++){ mi[arr1[i]]++; } for(int i = 0; i &lt; arr2.size(); i++){ while(mi[arr2[i]] &gt; 0){ vi.push_back(arr2[i]); mi[arr2[i]]--; } } for(auto m = mi.begin(); m != mi.end(); m++){ while(m-&gt;second &gt; 0){ vi.push_back(m-&gt;first); m-&gt;second--; } } return vi; } }; 题目地址: https://leetcode-cn.com/contest/weekly-contest-145/problems/relative-sort-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1111. 有效括号的嵌套深度]]></title>
    <url>%2F2019%2F07%2F08%2Fleetcode%201111.%20%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目：有效括号字符串 仅由 “(“ 和 “)” 构成，并符合下述几个条件之一： 空字符串连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串嵌套，可以记作 (A)，其中 A 是有效括号字符串类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)： s 为空时，depth(“”) = 0s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串s 为嵌套情况，depth(“(“ + A + “)”) = 1 + depth(A)，其中 A 是有效括号字符串例如：””，”()()”，和 “()(()())” 都是有效括号字符串，嵌套深度分别为 0，1，2，而 “)(“ 和 “(()” 都不是有效括号字符串。 给你一个有效括号字符串 seq，将其分成两个不相交的子序列 A 和 B，且 A 和 B 满足有效括号字符串的定义（注意：A.length + B.length = seq.length）。 现在，你需要从中选出 任意 一组有效括号字符串 A 和 B，使 max(depth(A), depth(B)) 的可能取值最小。 返回长度为 seq.length 答案数组 answer ，选择 A 还是 B 的编码规则是：如果 seq[i] 是 A 的一部分，那么 answer[i] = 0。否则，answer[i] = 1。即便有多个满足要求的答案存在，你也只需返回 一个。 示例：示例 1： 输入：seq = &quot;(()())&quot; 输出：[0,1,1,1,1,0] 示例 2： 输入：seq = &quot;()(())()&quot; 输出：[0,0,0,1,1,0,1,1] 提示： 1 &lt;= text.size &lt;= 10000 分析：求出最大深度，将最大深度除以2 遍历seq，中途记录深度 当深度超出时，记录为1，否则为0 代码：class Solution { public: vector&lt;int&gt; maxDepthAfterSplit(string seq) { vector&lt;int&gt; vi; int depth = 0; int z = 0; for(int i = 0; i &lt; seq.size(); i++){ if(seq[i] == &apos;(&apos;) z++; else z--; depth = max(depth, z); } depth = (depth + 1) / 2; for(int i = 0; i &lt; seq.size(); i++){ if(seq[i] == &apos;(&apos;){ z++; if(z &gt; depth) vi.push_back(1); else vi.push_back(0); } else{ if(z &gt; depth) vi.push_back(1); else vi.push_back(0); z--; } } return vi; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-144/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1110. 删点成林]]></title>
    <url>%2F2019%2F07%2F08%2Fleetcode%201110.%20%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97%2F</url>
    <content type="text"><![CDATA[题目：给出二叉树的根节点 root，树上每个节点都有一个不同的值。 如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。 返回森林中的每棵树。你可以按任意顺序组织答案。 示例：输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]输出：[[1,2,null,4],[6],[7]] 提示： 树中的节点数最大为 1000。 每个节点都有一个介于 1 到 1000 之间的值，且各不相同。 to_delete.length &lt;= 1000 to_delete 包含一些从 1 到 1000、各不相同的值。 分析：使用递归，如果子节点是to_delete中的一个，就删除这个结点将其添加到树林中 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { private: vector&lt;TreeNode*&gt; vt; public: void dg(TreeNode* root, map&lt;int, int&gt; mi){ if(root-&gt;left != NULL){ dg(root-&gt;left, mi); if(mi[root-&gt;left-&gt;val] == 1){ if(root-&gt;left-&gt;left != NULL) vt.push_back(root-&gt;left-&gt;left); if(root-&gt;left-&gt;right != NULL) vt.push_back(root-&gt;left-&gt;right); root-&gt;left = NULL; } } if(root-&gt;right != NULL){ dg(root-&gt;right, mi); if(mi[root-&gt;right-&gt;val] == 1){ if(root-&gt;right-&gt;left != NULL) vt.push_back(root-&gt;right-&gt;left); if(root-&gt;right-&gt;right != NULL) vt.push_back(root-&gt;right-&gt;right); root-&gt;right = NULL; } } } vector&lt;TreeNode*&gt; delNodes(TreeNode* root, vector&lt;int&gt;&amp; to_delete) { map&lt;int, int&gt; mi; TreeNode* t = new TreeNode(0); t-&gt;left = root; for(int i = 0; i &lt; to_delete.size(); i++){ mi[to_delete[i]] = 1; } dg(t, mi); if(t-&gt;left != NULL){ vt.push_back(t-&gt;left); } return vt; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-144/problems/delete-nodes-and-return-forest/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1109. 航班预订统计]]></title>
    <url>%2F2019%2F07%2F08%2Fleetcode%201109.%20%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[题目：这里有 n 个航班，它们分别从 1 到 n 进行编号。 我们这儿有一份航班预订表，表中第 i 条预订记录 bookings[i] = [i, j, k] 意味着我们在从 i 到 j 的每个航班上预订了 k 个座位。 请你返回一个长度为 n 的数组 answer，按航班编号顺序返回每个航班上预订的座位数。 示例：输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5 输出：[10,55,45,25,25] 提示： 1 &lt;= bookings.length &lt;= 20000 1 &lt;= bookings[i][0] &lt;= bookings[i][1] &lt;= n &lt;= 20000 1 &lt;= bookings[i][2] &lt;= 10000 分析：直接遍历复杂度太大，使用两个map，一个来存储从i开始的航班中所需要添座位的数量，一个用来存储到j为止的航班不需要添加座位的数量 代码：class Solution { public: vector&lt;int&gt; corpFlightBookings(vector&lt;vector&lt;int&gt;&gt;&amp; bookings, int n) { vector&lt;int&gt; vi(n, 0); int z = 0; map&lt;int, int&gt; mi; map&lt;int, int&gt; mi1; for(int i = 0; i &lt; bookings.size(); i++){ mi[bookings[i][0]-1] += bookings[i][2]; mi1[bookings[i][1]] += bookings[i][2]; } for(int i = 0; i &lt; vi.size(); i++){ z += mi[i]; z -= mi1[i]; vi[i] = z; } return vi; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-144/problems/corporate-flight-bookings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1108. IP 地址无效化]]></title>
    <url>%2F2019%2F07%2F08%2Fleetcode%201108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96%2F</url>
    <content type="text"><![CDATA[题目：给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。 所谓无效化 IP 地址，其实就是用 “[.]” 代替了每个 “.”。 示例：示例 1： 输入：address = &quot;1.1.1.1&quot; 输出：&quot;1[.]1[.]1[.]1&quot; 示例 2： 输入：address = &quot;255.100.50.0&quot; 输出：&quot;255[.]100[.]50[.]0&quot; 提示： 给出的 address 是一个有效的 IPv4 地址 分析：直接转换 代码：class Solution { public: string defangIPaddr(string address) { string str = &quot;&quot;; for(int i = 0; i &lt; address.size(); i++){ if(address[i] == &apos;.&apos;){ str += &quot;[.]&quot;; } else str += address[i]; } return str; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-144/problems/defanging-an-ip-address/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1106. 解析布尔表达式]]></title>
    <url>%2F2019%2F07%2F01%2Fleetcode%201106.%20%E8%A7%A3%E6%9E%90%E5%B8%83%E5%B0%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[题目：给你一个以字符串形式表述的 布尔表达式（boolean） expression，返回该式的运算结果。 有效的表达式需遵循以下约定： “t”，运算结果为 True “f”，运算结果为 False “!(expr)”，运算过程为对内部表达式 expr 进行逻辑 非的运算（NOT） “&amp;(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 与的运算（AND） “|(expr1,expr2,…)”，运算过程为对 2 个或以上内部表达式 expr1, expr2, … 进行逻辑 或的运算（OR） 示例：示例 1： 输入：expression = &quot;!(f)&quot; 输出：true 示例 2： 输入：expression = &quot;|(f,t)&quot; 输出：true 示例 3： 输入：expression = &quot;&amp;(t,f)&quot; 输出：false 示例 4： 输入：expression = &quot;|(&amp;(t,f,t),!(t))&quot; 输出：false 提示： 1 &lt;= expression.length &lt;= 20000 expression[i] 由 {‘(‘, ‘)’, ‘&amp;’, ‘|’, ‘!’, ‘t’, ‘f’, ‘,’} 中的字符组成。 expression 是以上述形式给出的有效表达式，表示一个布尔值。 分析：声明两个栈，一个用来存运算符，一个用来存操作数 当遇到右括号时，将从右括号开始到上一个左括号之间的操作数使用最后一个运算符来运算 代码：class Solution { public: bool parseBoolExpr(string expression) { vector&lt;char&gt; vi; vector&lt;char&gt; vi1; for(int i = 0; i &lt; expression.size(); i++){ if(expression[i] == &apos;(&apos;){ vi.push_back(expression[i]); } else if(expression[i] == &apos;)&apos;){ bool b; if(vi[vi.size()-1] == &apos;f&apos;){ b = false; } else{ b = true; } vi.pop_back(); if(vi[vi.size()-1] == &apos;(&apos;){ if(vi1[vi1.size()-1] == &apos;!&apos;){ b = !b; } } for(; vi[vi.size()-1] != &apos;(&apos;;){ if(vi1[vi1.size()-1] == &apos;&amp;&apos;){ if(vi[vi.size()-1] == &apos;t&apos; &amp;&amp; b == true){ b = true; } else{ b = false; } } else if(vi1[vi1.size()-1] == &apos;|&apos;){ if(vi[vi.size()-1] == &apos;t&apos; || b == true){ b = true; } else{ b = false; } } else if(vi1[vi1.size()-1] == &apos;!&apos;){ b = !b; } vi.pop_back(); } vi.pop_back(); if(b) vi.push_back(&apos;t&apos;); else vi.push_back(&apos;f&apos;); vi1.pop_back(); } else if(expression[i] == &apos;&amp;&apos;){ vi1.push_back(expression[i]); } else if(expression[i] == &apos;|&apos;){ vi1.push_back(expression[i]); } else if(expression[i] == &apos;!&apos;){ vi1.push_back(expression[i]); } else if(expression[i] == &apos;t&apos;){ vi.push_back(expression[i]); } else if(expression[i] == &apos;f&apos;){ vi.push_back(expression[i]); } else if(expression[i] == &apos;,&apos;){ } } cout &lt;&lt; vi[0]; if(vi[0] == &apos;t&apos;) return true; else return false; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-143/problems/parsing-a-boolean-expression/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1105. 填充书架]]></title>
    <url>%2F2019%2F07%2F01%2Fleetcode%201105.%20%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[题目：附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。 你把要摆放的书 books 都整理好，叠成一摞：从上往下，第 i 本书的厚度为 books[i][0]，高度为 books[i][1]。 按顺序 将这些书摆放到总宽度为 shelf_width 的书架上。 先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。 需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。 每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。 以这种方式布置书架，返回书架整体可能的最小高度。 示例：输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4 输出：6 解释： 3 层书架的高度和为 1 + 3 + 2 = 6 。 第 2 本书不必放在第一层书架上。 提示： 1 &lt;= books.length &lt;= 1000 1 &lt;= books[i][0] &lt;= shelf_width &lt;= 1000 1 &lt;= books[i][1] &lt;= 1000 分析：使用动态规划 建立一个长度为书籍数量+1，初始值为INT_MAX的数组dp 将dp[0]赋值为0 dp[i]表示到第i-1本书最优摆放方式 定义一个max_height为最大高度 转移方程：dp[i+1] = min(dp[i+1], dp[i] + max_height) 代码：class Solution { public: int minHeightShelves(vector&lt;vector&lt;int&gt;&gt;&amp; books, int shelf_width) { vector&lt;int&gt; dp(books.size()+1, INT_MAX); dp[0] = 0; for(int i = 0; i &lt; books.size(); i++){ int max_height = 0; int width = 0; for(int j = i; j &gt;= 0; j--){ width += books[j][0]; if(width &gt; shelf_width) break; max_height = max(max_height, books[j][1]); dp[i+1] = min(dp[i+1], dp[j] + max_height); } } return dp[books.size()]; } }; 题目地址: https://leetcode-cn.com/contest/weekly-contest-143/problems/filling-bookcase-shelves/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1103. 二叉树寻路]]></title>
    <url>%2F2019%2F07%2F01%2Fleetcode%201103.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[题目：在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。 如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记； 而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。 给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。 示例：示例 1： 输入：label = 14 输出：[1,3,4,14] 示例 2： 输入：label = 26 输出：[1,2,6,10,26] 提示： 1 &lt;= label &lt;= 10^6 分析：每个节点的父节点，就是上一排最大节点-（（当前节点-这一排最小节点）/2） 代码：class Solution { public: vector&lt;int&gt; pathInZigZagTree(int label) { int i = 1; vector&lt;int&gt; vi; vector&lt;int&gt; vi1; vi.push_back(label); while(label != 1){ if(i &lt;= label &amp;&amp; i*2 &gt; label){ int z = label - i; z /= 2; label = i - 1 - z; vi.push_back(label); i /= 2; } else{ i *= 2; } } for(int i = vi.size()-1; i &gt;= 0; i--){ vi1.push_back(vi[i]); } return vi1; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-143/problems/path-in-zigzag-labelled-binary-tree/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1104. 分糖果 II]]></title>
    <url>%2F2019%2F07%2F01%2Fleetcode%201104.%20%E5%88%86%E7%B3%96%E6%9E%9C%20II%2F</url>
    <content type="text"><![CDATA[题目：排排坐，分糖果。 我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。 给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。 然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。 重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。 返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。 示例：示例 1： 输入：candies = 7, num_people = 4 输出：[1,2,3,1] 解释： 第一次，ans[0] += 1，数组变为 [1,0,0,0]。 第二次，ans[1] += 2，数组变为 [1,2,0,0]。 第三次，ans[2] += 3，数组变为 [1,2,3,0]。 第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。 示例 2： 输入：candies = 10, num_people = 3 输出：[5,2,3] 解释： 第一次，ans[0] += 1，数组变为 [1,0,0]。 第二次，ans[1] += 2，数组变为 [1,2,0]。 第三次，ans[2] += 3，数组变为 [1,2,3]。 第四次，ans[0] += 4，最终数组变为 [5,2,3]。 提示： 1 &lt;= candies &lt;= 10^9 1 &lt;= num_people &lt;= 1000 分析：直接一个一个分糖果，最后剩下的一次性给下一个 代码：class Solution { public: vector&lt;int&gt; distributeCandies(int candies, int num_people) { int i = 1; int j = 0; vector&lt;int&gt; vi(num_people, 0); while(candies &gt; 0){ if(i &lt; candies){ vi[j] += i; } else{ vi[j] += candies; return vi;; } candies -= i; i++; j++; j %= num_people; } return vi; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-143/problems/distribute-candies-to-people/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1096. 花括号展开 II]]></title>
    <url>%2F2019%2F06%2F24%2Fleetcode%201096.%20%E8%8A%B1%E6%8B%AC%E5%8F%B7%E5%B1%95%E5%BC%80%20II%2F</url>
    <content type="text"><![CDATA[题目：如果你熟悉 Shell 编程，那么一定了解过花括号展开，它可以用来生成任意字符串。 花括号展开的表达式可以看作一个由 花括号、逗号 和 小写英文字母 组成的字符串，定义下面几条语法规则： 如果只给出单一的元素 x，那么表达式表示的字符串就只有 “x”。 例如，表达式 {a} 表示字符串 “a”。 而表达式 {ab} 就表示字符串 “ab”。 当两个或多个表达式并列，以逗号分隔时，我们取这些表达式中元素的并集。 例如，表达式 {a,b,c} 表示字符串 “a”,”b”,”c”。 而表达式 {a,b},{b,c} 也可以表示字符串 “a”,”b”,”c”。 要是两个或多个表达式相接，中间没有隔开时，我们从这些表达式中各取一个元素依次连接形成字符串。 例如，表达式 {a,b}{c,d} 表示字符串 “ac”,”ad”,”bc”,”bd”。 表达式之间允许嵌套，单一元素与表达式的连接也是允许的。 例如，表达式 a{b,c,d} 表示字符串 “ab”,”ac”,”ad”​​​​​​。 例如，表达式 {a{b,c}}{ {d,e}f{g,h}} 可以代换为 {ab,ac}{dfg,dfh,efg,efh}，表示字符串&quot;abdfg&quot;, &quot;abdfh&quot;, &quot;abefg&quot;, &quot;abefh&quot;, &quot;acdfg&quot;, &quot;acdfh&quot;, &quot;acefg&quot;, &quot;acefh&quot;。 给出表示基于给定语法规则的表达式 expression，返回它所表示的所有字符串组成的有序列表。 假如你希望以「集合」的概念了解此题，也可以通过点击 “显示英文描述” 获取详情。 示例：示例 1： 输入：&quot;{a,b}{c{d,e}}&quot; 输出：[&quot;acd&quot;,&quot;ace&quot;,&quot;bcd&quot;,&quot;bce&quot;] 示例 2： 输入：&quot;{{a,z}, a{b,c}, {ab,z}}&quot; 输出：[&quot;a&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;z&quot;] 解释：输出中 不应 出现重复的组合结果。 提示： 1 &lt;= expression.length &lt;= 50 expression[i] 由 ‘{‘，’}’，’,’ 或小写英文字母组成 给出的表达式 expression 用以表示一组基于题目描述中语法构造的字符串 分析：编写一个函数 当遇到左括号时，将直到对应的右括号交给函数处理。将返回一组字符串，将前面至上一个逗号或开始的字符串集合这组字符串组合。 在遇到右括号时，返回函数所生成的字符串 在遇到逗号时，往当前字符串中添加一个新的空字符串，并将逗号记号移动至最后一个字符串 遇到字母时，将至下一个非字母的字符之前的字符生成一个字符串，和从前一个逗号开始的字符串集组合 代码：class Solution { private: vector&lt;string&gt; vs; public: vector&lt;string&gt; yz(string ex, int&amp; i){ string str = &quot;&quot;; int d = 0; vector&lt;string&gt; v(1, &quot;&quot;); while(i &lt; ex.size()){ if(ex[i] == &apos;{&apos;){ auto v1 = yz(ex, ++i); vector&lt;string&gt; v2; for(int j = d; j &lt; v.size(); j++){ for(int k = 0; k &lt; v1.size(); k++){ v2.push_back(v[j] + v1[k]); } } while(v.size() &gt; d) v.pop_back(); for(int j = 0; j &lt; v2.size(); j++) v.push_back(v2[j]); } else if(ex[i] == &apos;}&apos;){ i++; return v; } else if(ex[i] == &apos;,&apos;){ v.push_back(&quot;&quot;); d = v.size()-1; i++; } else{ while(ex[i] &gt;= &apos;a&apos; &amp;&amp; ex[i] &lt;= &apos;z&apos;){ str += ex[i]; i++; } for(int j = d; j &lt; v.size(); j++){ v[j] += str; } str = &quot;&quot;; } } return v; } vector&lt;string&gt; braceExpansionII(string expression) { int i = 0; auto vs = yz(expression, i); set&lt;string&gt; ss(vs.begin(), vs.end()); vs.assign(ss.begin(), ss.end()); return vs; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-142/problems/brace-expansion-ii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1095. 山脉数组中查找目标值]]></title>
    <url>%2F2019%2F06%2F24%2Fleetcode%201095.%20%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：（这是一个 交互式问题 ） 给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。 如果不存在这样的下标 index，就请返回 -1。 所谓山脉数组，即数组 A 假如是一个山脉数组的话，需要满足如下条件： 首先，A.length &gt;= 3 其次，在 0 &lt; i &lt; A.length - 1 条件下，存在 i 使得： A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1] 你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据： MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始） MountainArray.length() - 会返回该数组的长度 注意： 对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。 为了帮助大家更好地理解交互式问题，我们准备了一个样例 “答案”：https://leetcode-cn.com/playground/RKhe3ave，请注意这 不是一个正确答案。 示例：示例 1： 输入：array = [1,2,3,4,5,3,1], target = 3 输出：2 解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。 示例 2： 输入：array = [0,1,2,4,2,1], target = 3 输出：-1 解释：3 在数组中没有出现，返回 -1。 提示： 3 &lt;= mountain_arr.length() &lt;= 10000 0 &lt;= target &lt;= 10^9 0 &lt;= mountain_arr.get(index) &lt;= 10^9 分析：使用二分查找先找到最大的数，然后先判断左边是否有需要的数，最后判断右边是否有需要的数 代码：/** * // This is the MountainArray&apos;s API interface. * // You should not implement it, or speculate about its implementation * class MountainArray { * public: * int get(int index); * int length(); * }; */ class Solution { public: int findInMountainArray(int target, MountainArray &amp;mountainArr) { int l = 0; int r = mountainArr.length()-1; int z = 0; int max = 0; map&lt;int, int&gt; mii; while(l+1 != r){ z = (r + l) / 2; if(!mii.count(z+1)) mii[z+1] = mountainArr.get(z+1); if(!mii.count(z)) mii[z] = mountainArr.get(z); if(mii[z+1] &gt; mii[z]) l = z; else r = z; } if(!mii.count(l)) mii[l] = mountainArr.get(l); if(!mii.count(r)) mii[r] = mountainArr.get(r); if(mii[l] &gt; mii[r]) max = l; else max = r; l = 0; r = max; while(l+1 != r){ z = (r + l) / 2; if(!mii.count(z)) mii[z] = mountainArr.get(z); if(target &gt; mii[z]) l = z; else r = z; } if(!mii.count(l)) mii[l] = mountainArr.get(l); if(!mii.count(r)) mii[r] = mountainArr.get(r); if(mii[l] == target) return l; else if(mii[r] == target) return r; l = max; r = mountainArr.length()-1; while(l+1 != r){ z = (r + l) / 2; cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot;\n&quot;; if(!mii.count(z)) mii[z] = mountainArr.get(z); if(target &lt; mii[z]) l = z; else r = z; } if(mountainArr.get(l) == target) return l; else if(mountainArr.get(r) == target) return r; return -1; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-142/problems/find-in-mountain-array/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1094. 拼车]]></title>
    <url>%2F2019%2F06%2F24%2Fleetcode%201094.%20%E6%8B%BC%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[题目：假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。由于道路的限制，车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。 这儿有一份行程计划表 trips[][]，其中 trips[i] = [num_passengers, start_location, end_location] 包含了你的第 i 次行程信息： 必须接送的乘客数量；乘客的上车地点；以及乘客的下车地点。这些给出的地点位置是从你的 初始 出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。 请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所用乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false）。 示例：示例 1： 输入：trips = [[2,1,5],[3,3,7]], capacity = 4 输出：false 示例 2： 输入：trips = [[2,1,5],[3,3,7]], capacity = 5 输出：true 示例 3： 输入：trips = [[2,1,5],[3,5,7]], capacity = 3 输出：true 示例 4： 输入：trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11 输出：true 提示： 你可以假设乘客会自觉遵守 “先下后上” 的良好素质 trips.length &lt;= 1000 trips[i].length == 3 1 &lt;= trips[i][0] &lt;= 100 0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000 1 &lt;= capacity &lt;= 100000 分析：使用两个map来记录上下车的人数和地点 根据行进的距离，来统计车内的人数 ### 代码： class Solution { public: bool carPooling(vector&lt;vector&lt;int&gt;&gt;&amp; trips, int capacity) { int chenei = 0; map&lt;int, int&gt; xiache; map&lt;int, int&gt; shangche; for(int i = 0; i &lt; trips.size(); i++){ xiache[trips[i][2]] += trips[i][0]; shangche[trips[i][1]] += trips[i][0]; } for(int i = 0; i &lt; 1001; i++){ if(xiache[i] != 0) chenei -= xiache[i]; if(shangche[i] != 0){ chenei += shangche[i]; if(chenei &gt; capacity) return false; } } return true; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-142/problems/car-pooling/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1093. 大样本统计]]></title>
    <url>%2F2019%2F06%2F24%2Fleetcode%201093.%20%E5%A4%A7%E6%A0%B7%E6%9C%AC%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[题目：我们对 0 到 255 之间的整数进行采样，并将结果存储在数组 count 中：count[k] 就是整数 k 的采样个数。 我们以 浮点数 数组的形式，分别返回样本的最小值、最大值、平均值、中位数和众数。其中，众数是保证唯一的。 我们先来回顾一下中位数的知识： 如果样本中的元素有序，并且元素数量为奇数时，中位数为最中间的那个元素； 如果样本中的元素有序，并且元素数量为偶数时，中位数为中间的两个元素的平均值。 示例：示例 1： 输入：count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 输出：[1.00000,3.00000,2.37500,2.50000,3.00000] 示例 2： 输入：count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 输出：[1.00000,4.00000,2.18182,2.00000,1.00000] 提示：1.count.length == 2562.1 &lt;= sum(count) &lt;= 10^93.计数表示的众数是唯一的4.答案与真实值误差在 10^-5 以内就会被视为正确答案 分析： 最小值：第一个非零的整数 最大值：最后一个非零的整数 平均值：将所有数相加，直接求平均值 中位数：先统计总数，然后根据奇数偶数来判断中位数 众数：遍历一遍，取出现次数最多的那个数 代码：class Solution { public: vector&lt;double&gt; sampleStats(vector&lt;int&gt;&amp; count) { vector&lt;double&gt; vd(5, -1); double zongzhi = 0; int zongshu = 0; int zuidashu = 0; double zuidashuzhi = 0; for(int i = 0; i &lt; 256; i++){ zongzhi += count[i] * i; zongshu += count[i]; if(zuidashu &lt; count[i]){ zuidashu = count[i]; zuidashuzhi = i; } if(count[i] != 0 &amp;&amp; vd[0] == -1) vd[0] = i; if(count[i] != 0) vd[1] = i; } vd[2] = zongzhi / zongshu; for(int i = 0, j = 0; i &lt; 256; i++){ j += count[i]; if(zongshu % 2 == 0){ if(j &gt;= zongshu / 2) { if(j == zongshu / 2){ vd[3] = i; while(count[i] != 0){ vd[3] = (vd[3] + i) / 2; i++; } } else{ vd[3] = i; } break; } } else{ if(j &gt;= zongshu / 2 + 1) { vd[3] = i; break; } } } vd[4] = zuidashuzhi; return vd; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-142/problems/statistics-from-a-large-sample/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1092. 最短公共超序列]]></title>
    <url>%2F2019%2F06%2F17%2Fleetcode%201092.%20%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：给出两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。 （如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 任意位置），可以得到字符串 S，那么 S 就是 T 的子序列） 示例：输入：str1 = &quot;abac&quot;, str2 = &quot;cab&quot; 输出：&quot;cabac&quot; 解释： str1 = &quot;abac&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 的第一个 &quot;c&quot;得到 &quot;abac&quot;。 str2 = &quot;cab&quot; 是 &quot;cabac&quot; 的一个子串，因为我们可以删去 &quot;cabac&quot; 末尾的 &quot;ac&quot; 得到 &quot;cab&quot;。 最终我们给出的答案是满足上述属性的最短字符串。 提示： 1 &lt;= str1.length, str2.length &lt;= 1000 str1 和 str2 都由小写英文字母组成。 分析：使用动态规划，来选出最长的公共子字符串 使用双指针，按照题目要求构成最短字符串 代码：bool comp(string a, string b){ return a.size() &lt; b.size(); } class Solution { public: string dp(string str1, string str2){ vector&lt;vector&lt;string&gt;&gt; vvs(str1.size()+1, vector&lt;string&gt;(str2.size()+1, &quot;&quot;)); for(int i = 1; i &lt;= str1.size(); i++){ for(int j = 1; j &lt;= str2.size(); j++){ if(str1[i-1] == str2[j-1]) vvs[i][j] = vvs[i-1][j-1] + str1[i-1]; else vvs[i][j] = max(vvs[i-1][j], vvs[i][j-1], comp); } } return vvs[vvs.size()-1][vvs[0].size()-1]; } string shortestCommonSupersequence(string str1, string str2) { string ret = &quot;&quot;; string lcs = dp(str1, str2); int s1 = 0; int s2 = 0; for(int i = 0; i &lt; lcs.size(); i++){ while(str1[s1] != lcs[i]){ ret += str1[s1]; s1++; } while(str2[s2] != lcs[i]){ ret += str2[s2]; s2++; } ret += lcs[i]; s1++; s2++; } while(s1 &lt; str1.size()){ ret += str1[s1]; s1++; } while(s2 &lt; str2.size()){ ret += str2[s2]; s2++; } return ret; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-141/problems/shortest-common-supersequence/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1091. 二进制矩阵中的最短路径]]></title>
    <url>%2F2019%2F06%2F17%2Fleetcode%201091.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目：在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。 一条从左上角到右下角、长度为 k 的畅通路径，由满足下述条件的单元格 C_1, C_2, …, C_k 组成： 相邻单元格 C_i 和 C_{i+1} 在八个方向之一上连通（此时，C_i 和 C_{i+1} 不同且共享边或角）C_1 位于 (0, 0)（即，值为 grid[0][0]）C_k 位于 (N-1, N-1)（即，值为 grid[N-1][N-1]）如果 C_i 位于 (r, c)，则 grid[r][c] 为空（即，grid[r][c] == 0）返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。 示例：示例 1： 输入：[[0,1],[1,0]] 输出：2 示例 2： 输入：[[0,0,0],[1,1,0],[1,1,0]] 输出：4 提示： 1 &lt;= grid.length == grid[0].length &lt;= 100 grid[i][j] 为 0 或 1 分析：动态规划，若是发生改变重新遍历 将每个格子的步数初始化为0，第一个初始化为1。 遍历时，每次从八个方向判断是否有除0外更小的步数 代码：class Solution { private: bool b = true; public: void bj(vector&lt;vector&lt;int&gt;&gt;&amp; vvi, int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; grid){ if(grid[x][y] != 0) return; int z = vvi[x][y]; if(x - 1 &gt;= 0 &amp;&amp; vvi[x-1][y] != 0){ if(vvi[x][y] == 0){ vvi[x][y] = vvi[x-1][y]; } else{ vvi[x][y] = min(vvi[x][y], vvi[x-1][y]); } } if(x - 1 &gt;= 0 &amp;&amp; y - 1 &gt;= 0 &amp;&amp; vvi[x-1][y-1] != 0){ if(vvi[x][y] == 0){ vvi[x][y] = vvi[x-1][y-1]; } else{ vvi[x][y] = min(vvi[x][y], vvi[x-1][y-1]); } } if(y - 1 &gt;= 0 &amp;&amp; vvi[x][y-1] != 0){ if(vvi[x][y] == 0){ vvi[x][y] = vvi[x][y-1]; } else{ vvi[x][y] = min(vvi[x][y], vvi[x][y-1]); } } if(x + 1 &lt; vvi.size() &amp;&amp; y - 1 &gt;= 0 &amp;&amp; vvi[x+1][y-1] != 0){ if(vvi[x][y] == 0){ vvi[x][y] = vvi[x+1][y-1]; } else{ vvi[x][y] = min(vvi[x][y], vvi[x+1][y-1]); } } if(x + 1 &lt; vvi.size() &amp;&amp; vvi[x+1][y] != 0){ if(vvi[x][y] == 0){ vvi[x][y] = vvi[x+1][y]; } else{ vvi[x][y] = min(vvi[x][y], vvi[x+1][y]); } } if(x + 1 &lt; vvi.size() &amp;&amp; y + 1 &lt; vvi[0].size() &amp;&amp; vvi[x+1][y+1] != 0){ if(vvi[x][y] == 0){ vvi[x][y] = vvi[x+1][y+1]; } else{ vvi[x][y] = min(vvi[x][y], vvi[x+1][y+1]); } } if(y + 1 &lt; vvi[0].size() &amp;&amp; vvi[x][y+1] != 0){ if(vvi[x][y] == 0){ vvi[x][y] = vvi[x][y+1]; } else{ vvi[x][y] = min(vvi[x][y], vvi[x][y+1]); } } if(x - 1 &gt;= 0 &amp;&amp; y + 1 &lt; vvi[0].size() &amp;&amp; vvi[x-1][y+1] != 0){ if(vvi[x][y] == 0){ vvi[x][y] = vvi[x-1][y+1]; } else{ vvi[x][y] = min(vvi[x][y], vvi[x-1][y+1]); } } if(z == 0 &amp;&amp; vvi[x][y] != 0){ vvi[x][y]++; b = true; } else if(vvi[x][y]+1 &lt; z) { vvi[x][y]++; b = true; } else{ vvi[x][y] = z; } } int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { if(grid[0][0] == 1 || grid[grid.size()-1][grid[0].size()-1] == 1){ return -1; } vector&lt;vector&lt;int&gt;&gt; vvi = grid; for(int i = 0; i &lt; vvi.size(); i++){ for(int j = 0; j &lt; vvi[0].size(); j++){ vvi[i][j] = 0; } } vvi[0][0] = 1; while(b == true){ b = false; for(int i = 0; i &lt; vvi.size(); i++){ for(int j = 0; j &lt; vvi[0].size(); j++){ if(vvi[i][j] == 1){ continue; } bj(vvi, i, j, grid); } } } if(vvi[vvi.size()-1][vvi[0].size()-1] == 0){ return -1; } return vvi[vvi.size()-1][vvi[0].size()-1]; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-141/problems/shortest-path-in-binary-matrix/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1090. 受标签影响的最大值]]></title>
    <url>%2F2019%2F06%2F17%2Fleetcode%201090.%20%E5%8F%97%E6%A0%87%E7%AD%BE%E5%BD%B1%E5%93%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：我们有一个项的集合，其中第 i 项的值为 values[i]，标签为 labels[i]。 我们从这些项中选出一个子集 S，这样一来： |S| &lt;= num_wanted对于任意的标签 L，子集 S 中标签为 L 的项的数目总满足 &lt;= use_limit。返回子集 S 的最大可能的 和。 示例：示例 1： 输入：values = [5,4,3,2,1], labels = [1,1,2,2,3], num_wanted = 3, use_limit = 1 输出：9 解释：选出的子集是第一项，第三项和第五项。 示例 2： 输入：values = [5,4,3,2,1], labels = [1,3,3,3,2], num_wanted = 3, use_limit = 2 输出：12 解释：选出的子集是第一项，第二项和第三项。 示例 3： 输入：values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 1 输出：16 解释：选出的子集是第一项和第四项。 示例 4： 输入：values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 2 输出：24 解释：选出的子集是第一项，第二项和第四项。 提示： 1 &lt;= values.length == labels.length &lt;= 20000 0 &lt;= values[i], labels[i] &lt;= 20000 1 &lt;= num_wanted, use_limit &lt;= 4. values.length 分析：直接根据values的大小进行排序，同时带着labels一起排序，最后根据顺序，在labels的限制下计算最大的值 代码：bool paixu(vector&lt;int&gt; a, vector&lt;int&gt; b){ return a[0] &gt; b[0]; } class Solution { public: int largestValsFromLabels(vector&lt;int&gt;&amp; values, vector&lt;int&gt;&amp; labels, int num_wanted, int use_limit) { vector&lt;vector&lt;int&gt;&gt; vvi; map&lt;int, int&gt; mii; int ret = 0; for(int i = 0; i &lt; values.size(); i++){ vector&lt;int&gt; vi; vi.push_back(values[i]); vi.push_back(labels[i]); vvi.push_back(vi); } sort(vvi.begin(), vvi.end(), paixu); for(int i = 0, j = 0; j &lt; num_wanted &amp;&amp; i &lt; vvi.size(); i++){ if(mii[vvi[i][1]] &lt; use_limit){ mii[vvi[i][1]]++; ret += vvi[i][0]; j++; } } return ret; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-141/problems/largest-values-from-labels/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1089. 复写零]]></title>
    <url>%2F2019%2F06%2F17%2Fleetcode%201089.%20%E5%A4%8D%E5%86%99%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[题目：给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。 注意：请不要在超过该数组长度的位置写入元素。 要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。 示例：示例 1： 输入：[1,0,2,3,0,4,5,0] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4] 示例 2： 输入：[1,2,3] 输出：null 解释：调用函数后，输入的数组将被修改为：[1,2,3] 提示： 1 &lt;= arr.length &lt;= 10000 0 &lt;= arr[i] &lt;= 9 分析：直接再用另一个数组来存储新的数组，结束后赋值给原数组 代码：class Solution { public: void duplicateZeros(vector&lt;int&gt;&amp; arr) { vector&lt;int&gt; vi; for(int i = 0; vi.size() != arr.size(); i++){ if(arr[i] == 0){ vi.push_back(0); cout &lt;&lt; vi.size() &lt;&lt; &quot; &quot; &lt;&lt; arr.size() &lt;&lt; &quot; &quot;; if(vi.size() &lt; arr.size()){ vi.push_back(0); } } else vi.push_back(arr[i]); } for(int i = 0; i &lt; vi.size(); i++) arr[i] = vi[i]; } }; /* int zero = 0; for(int i = 0; i &lt; arr.size() - zero; i++){ if(arr[i] == 0 &amp;&amp; i + 1 + zero &lt; arr.size()) zero++; } int j = arr.size()-1; for(int i = arr.size()-1-zero; i &gt;= 0; i--){ if(arr[i] == 0){ arr[j] = 0; j--; if(j &lt; 0){ return; } arr[j] = 0; } else{ arr[j] = arr[i]; } j--; } }*/ 题目地址：https://leetcode-cn.com/contest/weekly-contest-141/problems/duplicate-zeros/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1081. 不同字符的最小子序列]]></title>
    <url>%2F2019%2F06%2F10%2Fleetcode%201081.%20%E4%B8%8D%E5%90%8C%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：返回字符串 text 中按字典序排列最小的子序列，该子序列包含 text 中所有不同字符一次。 示例：示例 1： 输入：&quot;cdadabcc&quot; 输出：&quot;adbc&quot; 示例 2： 输入：&quot;abcd&quot; 输出：&quot;abcd&quot; 示例 3： 输入：&quot;ecbacba&quot; 输出：&quot;eacb&quot; 示例 4： 输入：&quot;leetcode&quot; 输出：&quot;letcod&quot; 提示： 1 &lt;= text.length &lt;= 1000 text 由小写英文字母组成 分析：将所有字符的数量统计出来，然后遍历text，每遍历一个字符，就将当前字符数量减一，直到减到0时，从第一个字符或者上次加入字符串的地址开始寻找这一段最小的字符，再将这个字符数量设为一个很大的数。重复以上步骤 代码：class Solution { public: string smallestSubsequence(string text) { string ret = &quot;&quot;; map&lt;char, int&gt; mci; int l = 0; int r = 0; for(int i = 0; i &lt; text.size(); i++){ mci[text[i]]++; } int size = mci.size(); while(ret.size() != size){ for(int i = r; i &lt; text.size(); i++){ if(mci[text[i]] == 1){ r = i; break; } mci[text[i]]--; } int min = INT_MAX; char minc = &apos;z&apos;+1; for(int i = l; i &lt;= r; i++){ if(text[i] &lt; minc &amp;&amp; mci[text[i]] &lt; 50000){ minc = text[i]; min = i; } } ret += minc; l = min+1; mci[minc] = 99999; } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-140/problems/smallest-subsequence-of-distinct-characters/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1080. 根到叶路径上的不足节点]]></title>
    <url>%2F2019%2F06%2F10%2Fleetcode%201080.%20%E6%A0%B9%E5%88%B0%E5%8F%B6%E8%B7%AF%E5%BE%84%E4%B8%8A%E7%9A%84%E4%B8%8D%E8%B6%B3%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：给定一棵二叉树的根 root，请你考虑它所有 从根到叶的路径：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点） 假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为「不足节点」，需要被删除。 请你删除所有不足节点，并返回生成的二叉树的根。 示例：示例 1： 输入：root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1 输出：[1,2,3,4,null,null,7,8,9,null,14] 示例 2： 输入：root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22 输出：[5,4,8,11,null,17,4,7,null,null,null,5] 示例 3： 输入：root = [5,-6,-6], limit = 0 输出：[] 提示： 给定的树有 1 到 5000 个节点 -10^5 &lt;= node.val &lt;= 10^5 -10^9 &lt;= limit &lt;= 10^9 分析：递归，每个节点的路径总和为左子树或右子树路径总和中大的那个，叶节点为从根节点到叶节点的路径和 对每个节点进行判断如果左子树或右子树的路径和如果小于limit，就删除不足的子树 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int dg(TreeNode* root, int limit, int h){ int left = INT_MIN; int right = INT_MIN; if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL){ // 遇到叶节点，返回从根到此节点所有节点的和 h += root-&gt;val; return h; } if(root-&gt;left != NULL){ left = dg(root-&gt;left, limit, h + root-&gt;val); if(left &lt; limit){ //如果左子树返回小于limit，删除左子树 delete(root-&gt;left); root-&gt;left = NULL; } } if(root-&gt;right != NULL){ right = dg(root-&gt;right, limit, h + root-&gt;val); if(right &lt; limit){ //如果右子树返回小于limit，删除右子树 delete(root-&gt;right); root-&gt;right = NULL; } } cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; right &lt;&lt; &quot;\n&quot;; if(left == INT_MIN){ return max(right, h + root-&gt;val); } if(right == INT_MIN){ return max(left, h + root-&gt;val); } if(left &gt; right){ return left; } else{ return right; } } TreeNode* sufficientSubset(TreeNode* root, int limit) { int z = dg(root, limit, 0); if(z &lt; limit){ return NULL; } return root; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-140/problems/insufficient-nodes-in-root-to-leaf-paths/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1079. 活字印刷]]></title>
    <url>%2F2019%2F06%2F10%2Fleetcode%201079.%20%E6%B4%BB%E5%AD%97%E5%8D%B0%E5%88%B7%2F</url>
    <content type="text"><![CDATA[题目：你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。 示例：示例 1： 输入：&quot;AAB&quot; 输出：8 解释：可能的序列为 &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;。 示例 2： 输入：&quot;AAABBC&quot; 输出：188 提示： 1 &lt;= tiles.length &lt;= 7 tiles 由大写英文字母组成 分析：数据不大，直接使用递归统计出可能的数 代码：class Solution { private: set&lt;string&gt; ss; public: void dg(string tiles, set&lt;int&gt; si, string str){ if(str.size() != 0){ ss.insert(str); } for(int j = 0; j &lt; tiles.size(); j++){ if(si.count(j) != 1){ string s = str; set&lt;int&gt; si1 = si; s += tiles[j]; si1.insert(j); dg(tiles, si1, s); } } } int numTilePossibilities(string tiles) { set&lt;int&gt; si; string str = &quot;&quot;; dg(tiles, si, str); return ss.size(); } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-140/problems/letter-tile-possibilities/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1078. Bigram 分词]]></title>
    <url>%2F2019%2F06%2F10%2Fleetcode%201078.%20Bigram%20%E5%88%86%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[题目：给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 “first second third” 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。 对于每种这样的情况，将第三个词 “third” 添加到答案中，并返回答案。 示例：示例 1： 输入：text = &quot;alice is a good girl she is a good student&quot;, first = &quot;a&quot;, second = &quot;good&quot; 输出：[&quot;girl&quot;,&quot;student&quot;] 示例 2： 输入：text = &quot;we will we will rock you&quot;, first = &quot;we&quot;, second = &quot;will&quot; 输出：[&quot;we&quot;,&quot;rock&quot;] 提示： 1 &lt;= text.length &lt;= 1000 text 由一些用空格分隔的单词组成，每个单词都由小写英文字母组成 1 &lt;= first.length, second.length &lt;= 10 first 和 second 由小写英文字母组成 分析：以空格为分隔符，直接遍历搜索字符串first，判断此字符串后面是否有second字符串，如有，将下一个字符串放入队列 代码：class Solution { public: string jq(string text, int &amp;i){ string str = &quot;&quot;; for(; i &lt; text.size() &amp;&amp; text[i] != &apos; &apos;; i++){ str += text[i]; } i++; return str; } vector&lt;string&gt; findOcurrences(string text, string first, string second) { vector&lt;string&gt; vs; for(int i = 0; i &lt; text.size();){ string str = jq(text, i); if(str == first){ int z = i; str = jq(text, i); if(str == second){ str = &quot;&quot;; if(i &gt; text.size()-1){ return vs; } for(int j = i ; j &lt; text.size() &amp;&amp; text[j] != &apos; &apos;; j++){ str += text[j]; } vs.push_back(str); } else{ i = z; } } } return vs; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-140/problems/occurrences-after-bigram/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5078. 负二进制数相加]]></title>
    <url>%2F2019%2F06%2F03%2Fleetcode%205078.%20%E8%B4%9F%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[题目：给出基数为 -2 的两个数 arr1 和 arr2，返回两数相加的结果。 数字以 数组形式 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，arr = [1,1,0,1] 表示数字 (-2)^3 + (-2)^2 + (-2)^0 = -3。数组形式 的数字也同样不含前导零：以 arr 为例，这意味着要么 arr == [0]，要么 arr[0] == 1。 返回相同表示形式的 arr1 和 arr2 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。 示例：输入：arr1 = [1,1,1,1,1], arr2 = [1,0,1] 输出：[1,0,0,0,0] 解释：arr1 表示 11，arr2 表示 5，输出表示 16 。 提示： 1 &lt;= arr1.length &lt;= 1000 1 &lt;= arr2.length &lt;= 1000 arr1 和 arr2 都不含前导零 arr1[i] 为 0 或 1 arr2[i] 为 0 或 1 分析：分析两个负二进制相加的特点 两个数相加，加上前面来的进位，记为z z如果等于0，那么就将当前位置为0，进位为0 z如果大于0，那么就将当前位置为z%2，进位为-1(因为下一位的符号是相反的) z如果小于0，那么就将当前位置为1，进位为1 代码：class Solution { public: vector&lt;int&gt; addNegabinary(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) { int i = arr1.size()-1; int j = arr2.size()-1; int jw = 0; vector&lt;int&gt; vi; while(i &gt;= 0 || j &gt;= 0){ int z; if(i &lt; 0){ z = arr2[j] + jw; } else if(j &lt; 0){ z = arr1[i] + jw; } else{ z = arr1[i] + arr2[j] + jw; } if(z == 0){ vi.insert(vi.begin(), 0); jw = 0; } else if(z &gt; 0){ vi.insert(vi.begin(), z % 2); if(z &gt; 1){ jw = -1; } else{ jw = 0; } } else{ vi.insert(vi.begin(), 1); jw = 1; } i--; j--; } while(jw != 0){ if(jw == -1){ vi.insert(vi.begin(), 1); jw = 1; } else if(jw == 1){ vi.insert(vi.begin(), 1); jw = 0; } } vector&lt;int&gt; ret; bool b = true; for(int i = 0; i &lt; vi.size(); i++){ if(vi[i] == 0 &amp;&amp; b &amp;&amp; i != vi.size()-1){ } else{ ret.push_back(vi[i]); b = false; } } return ret; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-139/problems/adding-two-negabinary-numbers/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5077. 按列翻转得到最大值等行数]]></title>
    <url>%2F2019%2F06%2F03%2Fleetcode%205077.%20%E6%8C%89%E5%88%97%E7%BF%BB%E8%BD%AC%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%AD%89%E8%A1%8C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给定由若干 0 和 1 组成的矩阵 matrix，从中选出任意数量的列并翻转其上的 每个 单元格。翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。 返回经过一些翻转后，行上所有值都相等的最大行数。 示例：示例 1： 输入：[[0,1],[1,1]] 输出：1 解释：不进行翻转，有 1 行所有值都相等。 示例 2： 输入：[[0,1],[1,0]] 输出：2 解释：翻转第一列的值之后，这两行都由相等的值组成。 示例 3： 输入：[[0,0,0],[0,0,1],[1,1,0]] 输出：2 解释：翻转前两列的值之后，后两行由相等的值组成。 提示： 1 &lt;= matrix.length &lt;= 300 1 &lt;= matrix[i].length &lt;= 300 所有 matrix[i].length 都相等 matrix[i][j] 为 0 或 1 分析：因为所有反转同一列就可以使一行相同的数列，他们的格式一定是相同的，所以将所有的数列都反转为以0开头的数列，通过map进行统计，就可以得出反转后最长的数列数量 代码：class Solution { public: int maxEqualRowsAfterFlips(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { int max = 0; map&lt;vector&lt;int&gt;, int&gt; m; for(int i = 0; i &lt; matrix.size(); i++){ if(matrix[i][0] == 1){ for(int j = 0; j &lt; matrix[i].size(); j++){ matrix[i][j] = (matrix[i][j] + 1) % 2; } } m[matrix[i]]++; } for(auto a : m){ max = a.second &gt; max ? a.second : max; } return max; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-139/problems/flip-columns-for-maximum-number-of-equal-rows/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5076. 字符串的最大公因子]]></title>
    <url>%2F2019%2F06%2F03%2Fleetcode%205076.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目：对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。 返回字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。 示例：示例 1： 输入：str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot; 输出：&quot;ABC&quot; 示例 2： 输入：str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot; 输出：&quot;AB&quot; 示例 3： 输入：str1 = &quot;LEET&quot;, str2 = &quot;CODE&quot; 输出：&quot;&quot; 提示： 1 &lt;= str1.length &lt;= 1000 1 &lt;= str2.length &lt;= 1000 str1[i] 和 str2[i] 为大写英文字母 分析：从一个字符串开头开始截取一段字符串，去尝试是否可以除尽字符串str1和str2 代码：class Solution { public: bool pd(string str1, string str2){ if(str1.size() &gt; str2.size()){ return false; } int i = 0; int j = 0; for(; j &lt; str2.size(); i++, j++){ if(i == str1.size()) i = 0; if(str1[i] != str2[j]){ return false; } } if(i != str1.size() || j != str2.size()){ cout &lt;&lt; str1.size() &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;; return false; } return true; } string gcdOfStrings(string str1, string str2) { string str = &quot;&quot;; string max = &quot;&quot;; for(int i = 0; i &lt; str1.size(); i++){ str += str1[i]; if(pd(str, str1) &amp;&amp; pd(str, str2)){ max = str; } } return max; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-139/problems/greatest-common-divisor-of-strings/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1054. 距离相等的条形码]]></title>
    <url>%2F2019%2F05%2F27%2Fleetcode%201054.%20%E8%B7%9D%E7%A6%BB%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9D%A1%E5%BD%A2%E7%A0%81%2F</url>
    <content type="text"><![CDATA[题目：在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。 请你重新排列这些条形码，使其中两个相邻的条形码 不能 相等。 你可以返回任何满足该要求的答案，此题保证存在答案。 示例：示例 1： 输入：[1,1,1,2,2,2] 输出：[2,1,2,1,2,1] 示例 2： 输入：[1,1,1,1,2,2,3,3] 输出：[1,3,1,3,2,1,2,1] 提示： 1 &lt;= barcodes.length &lt;= 10000 1 &lt;= barcodes[i] &lt;= 10000 分析：将数组存入map，找出里面相同数量最多的字符，从这种字符开始排列（目的是为了防止字符串数量为单数，并且当前字符所占长度为字符串一半以上），两个字符之间空一格，当排列到字符串长度时，从1开始填入之前的空格 代码：class Solution {public: vector rearrangeBarcodes(vector&amp; barcodes) { vector ret(barcodes.size()); map&lt;int, int&gt; mii; for(int i = 0; i &lt; barcodes.size(); i++){ mii[barcodes[i]]++; } int max = 0; int z = 0; for(auto m = mii.begin(); m != mii.end(); m++){ if(max &lt; m-&gt;second){ max = m-&gt;second; z = m-&gt;first; } } int x = 0; for(int i = 0; i &lt; mii[z]; i++){ ret[x] = z; x += 2; if(x &gt;= barcodes.size()){ x = 1; } } mii[z] = 0; for(auto m = mii.begin(); m != mii.end(); m++){ for(int i = 0; i &lt; m-&gt;second; i++){ ret[x] = m-&gt;first; x += 2; if(x &gt;= barcodes.size()){ x = 1; } } } return ret; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-138/problems/distant-barcodes/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1053. 交换一次的先前排列]]></title>
    <url>%2F2019%2F05%2F27%2Fleetcode%201053.%20%E4%BA%A4%E6%8D%A2%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%88%E5%89%8D%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。 如果无法这么操作，就请返回原数组。 示例：示例 1： 输入：[3,2,1] 输出：[3,1,2] 解释： 交换 2 和 1 示例 2： 输入：[1,1,5] 输出：[1,1,5] 解释： 这已经是最小排列 示例 3： 输入：[1,9,4,6,7] 输出：[1,7,4,6,9] 解释： 交换 9 和 7 示例 4： 输入：[3,1,1,3] 输出：[1,3,1,3] 解释： 交换 1 和 3 提示： 1 &lt;= A.length &lt;= 10000 1 &lt;= A[i] &lt;= 10000 分析：从后往前遍历找到第一个大于前一个的数字，然后从当前数字向后遍历，找到小于这个数字的最大的一个数，将两个数交换 代码：class Solution { public: vector&lt;int&gt; prevPermOpt1(vector&lt;int&gt;&amp; A) { for(int i = A.size()-2; i &gt;= 0; i--){ if(A[i] &gt; A[i+1]){ cout &lt;&lt; i &lt;&lt; &quot;\n&quot;; for(int j = i+1; i &lt; A.size(); j++){ if(j == A.size() || A[j] &gt;= A[i]){ int z = A[i]; A[i] = A[j-1]; A[j-1] = z; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j; return A; } } } } return A; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-138/problems/previous-permutation-with-one-swap/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1052. 爱生气的书店老板]]></title>
    <url>%2F2019%2F05%2F27%2Fleetcode%201052.%20%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[题目：今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。 在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。 书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。 请你返回这一天营业下来，最多有多少客户能够感到满意的数量。 示例：输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3 输出：16 解释： 书店老板在最后 3 分钟保持冷静。 感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16. 提示： 1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000 0 &lt;= customers[i] &lt;= 1000 0 &lt;= grumpy[i] &lt;= 1 分析：先计算不使用秘密技巧时的满意数量，然后使用满意技巧，计算每次使用满意技巧后最多的满意数量 代码：class Solution { public: int maxSatisfied(vector&lt;int&gt;&amp; customers, vector&lt;int&gt;&amp; grumpy, int X) { int z = 0; int max = 0; for(int i = 0; i &lt; customers.size(); i++){ if(grumpy[i] == 0){ z += customers[i]; } } max = z; for(int i = 0; i &lt; customers.size(); i++){ if(i &lt; X){ if(grumpy[i] == 1){ z += customers[i]; } } else{ if(grumpy[i] == 1){ z += customers[i]; } if(grumpy[i - X] == 1){ z -= customers[i-X]; } } max = max &gt; z ? max : z; } return max; } }; 题目地址https://leetcode-cn.com/contest/weekly-contest-138/problems/grumpy-bookstore-owner/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1051. 高度检查器]]></title>
    <url>%2F2019%2F05%2F27%2Fleetcode%201051.%20%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目：学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。 请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。 示例：输入：[1,1,4,2,1,3] 输出：3 解释： 高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。 提示： 1 &lt;= heights.length &lt;= 100 1 &lt;= heights[i] &lt;= 100 分析：直接排序，将排序后的列表和排序前的列表进行比较，统计不同的数量 代码：class Solution { public: int heightChecker(vector&lt;int&gt;&amp; heights) { vector&lt;int&gt; vi = heights; sort(vi.begin(), vi.end()); int ret = 0; for(int i = 0; i &lt; heights.size(); i++){ if(vi[i] != heights[i]){ ret++; } } return ret; } }; 题目地址:https://leetcode-cn.com/contest/weekly-contest-138/problems/height-checker/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1048. 最长字符串链]]></title>
    <url>%2F2019%2F05%2F20%2Fleetcode%201048.%20%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE%2F</url>
    <content type="text"><![CDATA[题目：给出一个单词列表，其中每个单词都由小写英文字母组成。 如果我们可以在 word1 的任何地方添加一个字母使其变成 word2，那么我们认为 word1 是 word2 的前身。例如，”abc” 是 “abac” 的前身。 词链是单词 [word_1, word_2, …, word_k] 组成的序列，k &gt;= 1，其中 word_1 是 word_2 的前身，word_2 是 word_3 的前身，依此类推。 从给定单词列表 words 中选择单词组成词链，返回词链的最长可能长度。 示例：输入：[&quot;a&quot;,&quot;b&quot;,&quot;ba&quot;,&quot;bca&quot;,&quot;bda&quot;,&quot;bdca&quot;] 输出：4 解释：最长单词链之一为 &quot;a&quot;,&quot;ba&quot;,&quot;bda&quot;,&quot;bdca&quot;。 提示： 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 16 words[i] 仅由小写英文字母组成。 分析：先将字符串按长度排列 设计一个函数，判断是否两个字符串有前后关系 使用动态规划 w[i] 和 w[j] 为前后关系 初始全部赋值为0 转移方程为 w[j] = w[j] 和 w[i]+1 中大的那个数 代码：bool cmp(string str1, string str2){ return str2.size() &gt; str1.size(); } class Solution { public: bool isFront(string str1, string str2){ if(str2.size() - str1.size() != 1){ return false; } int i = 0; int j = 0; while(i &lt; str1.size() &amp;&amp; j &lt; str2.size() &amp;&amp; str1[i] == str2[i]){ i++; j++; } j++; while(i &lt; str1.size() &amp;&amp; j &lt; str2.size()){ if(str1[i] != str2[j]){ return false; } i++; j++; } return true; } int longestStrChain(vector&lt;string&gt;&amp; words) { int max = 0; int w[words.size()] = {0}; sort(words.begin(), words.end(), cmp); for(int i = 0; i &lt; words.size(); i++){ for(int j = i + 1; j &lt; words.size(); j++){ if(words[j].size() - words[i].size() &lt; 1){ continue; } else if(words[j].size() - words[i].size() &gt; 1){ break; } if(isFront(words[i], words[j])){ w[j] = w[j] &gt; w[i]+1 ? w[j] : w[i]+1; max = max &gt; w[j] ? max : w[j]; } } } return max+1; } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5064. 删除字符串中的所有相邻重复项]]></title>
    <url>%2F2019%2F05%2F20%2Fleetcode%205064.%20%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[题目：给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例：输入：&quot;abbaca&quot; 输出：&quot;ca&quot; 解释： 例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。 提示： 1 &lt;= S.length &lt;= 20000 S 仅由小写英文字母组成。 分析：使用栈，当遇到和栈顶相同的字符，就pop，继续读取下一个字符 代码：class Solution { public: string removeDuplicates(string S) { string str = &quot;&quot;; str += S[0]; for(int i = 1; i &lt; S.size(); i++){ if(S[i] == str[str.size()-1]){ str.erase(str.end()-1); } else{ str += S[i]; } } return str; } }; 题目地址： https://leetcode-cn.com/contest/weekly-contest-137/problems/remove-all-adjacent-duplicates-in-string/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5063. 最后一块石头的重量]]></title>
    <url>%2F2019%2F05%2F20%2Fleetcode%205063.%20%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F%2F</url>
    <content type="text"><![CDATA[题目：有一堆石头，每块石头的重量都是正整数。 每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。 提示： 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 1000 分析：因为数据不大，每次都sort一下然后对最大的两块石头进行操作 代码：class Solution { public: int lastStoneWeight(vector&lt;int&gt;&amp; stones) { while(stones.size() &gt; 1){ sort(stones.begin(), stones.end()); if(stones[stones.size()-1] == stones[stones.size()-2]){ stones.pop_back(); stones.pop_back(); } else{ int z = stones[stones.size()-1] - stones[stones.size()-2]; stones.pop_back(); stones.pop_back(); stones.push_back(z); } } if(stones.size() &gt; 0){ return stones[0]; } return 0; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-137/problems/last-stone-weight]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5057. 分隔数组以得到最大和]]></title>
    <url>%2F2019%2F05%2F13%2Fleetcode%205057.%20%E5%88%86%E9%9A%94%E6%95%B0%E7%BB%84%E4%BB%A5%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给出整数数组 A，将该数组分隔为长度最多为 K 的几个（连续）子数组。分隔完成后，每个子数组的中的值都会变为该子数组中的最大值。 返回给定数组完成分隔后的最大和。 示例：输入：A = [1,15,7,9,2,5,10], K = 3 输出：84 解释：A 变为 [15,15,15,9,10,10,10] 提示： 1 &lt;= K &lt;= A.length &lt;= 500 0 &lt;= A[i] &lt;= 10^6 分析：使用动态规划 i为到第i-1个数为止最大的分隔方式 j为将第i-1个数往前数j个数（包含i-1）修改为j个数中最大的数 dp[i] = dp[i-j] + j * m 或者 原来的dp[i] 代码：class Solution { public: int maxSumAfterPartitioning(vector&lt;int&gt;&amp; A, int K) { int dp[A.size()+1] = {0}; for(int i = 1; i &lt;= A.size(); i++){ int m = 0; for(int j = 1; j &lt;= K; j++){ if(i - 1 - j + 1 &lt; 0){ break; } m = m &gt; A[i-1-j+1] ? m : A[i-1-j+1]; dp[i] = dp[i] &gt; dp[i-j] + j * m ? dp[i] : dp[i-j] + j * m; } } return dp[A.size()]; } }; 题目链接：https://leetcode-cn.com/contest/weekly-contest-136/problems/partition-array-for-maximum-sum/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5056. 不邻接植花]]></title>
    <url>%2F2019%2F05%2F13%2Fleetcode%205056.%20%E4%B8%8D%E9%82%BB%E6%8E%A5%E6%A4%8D%E8%8A%B1%2F</url>
    <content type="text"><![CDATA[题目：有 N 个花园，按从 1 到 N 标记。在每个花园中，你打算种下四种花之一。 paths[i] = [x, y] 描述了花园 x 到花园 y 的双向路径。 另外，没有花园有 3 条以上的路径可以进入或者离开。 你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。 以数组形式返回选择的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。花的种类用 1, 2, 3, 4 表示。保证存在答案。 示例：示例 1： 输入：N = 3, paths = [[1,2],[2,3],[3,1]] 输出：[1,2,3] 示例 2： 输入：N = 4, paths = [[1,2],[3,4]] 输出：[1,2,1,2] 示例 3： 输入：N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]] 输出：[1,2,3,4] 提示： 1 &lt;= N &lt;= 10000 0 &lt;= paths.size &lt;= 20000 不存在花园有 4 条或者更多路径可以进入或离开。 保证存在答案。 分析：建立两个双重map，一个用来记录两个花园之间的关系，另一个用来记录每个花园不该用的种类 代码：class Solution { public: vector&lt;int&gt; gardenNoAdj(int N, vector&lt;vector&lt;int&gt;&gt;&amp; paths) { map&lt;int, map&lt;int, int&gt;&gt; mmi; map&lt;int, map&lt;int, int&gt;&gt; mmi1; vector&lt;int&gt; vi; for(int i = 0; i &lt; paths.size(); i++){ mmi[paths[i][0]][paths[i][1]] = 1; mmi[paths[i][1]][paths[i][0]] = 1; } for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt; 5; j++){ if(mmi1[i][j] != 1){ vi.push_back(j); for(auto a = mmi[i].begin(); a != mmi[i].end(); a++){ mmi1[a-&gt;first][j] = 1; } break; } } } return vi; } }; 题目链接：https://leetcode-cn.com/contest/weekly-contest-136/problems/flower-planting-with-no-adjacent/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5055. 困于环中的机器人]]></title>
    <url>%2F2019%2F05%2F13%2Fleetcode%205055.%20%E5%9B%B0%E4%BA%8E%E7%8E%AF%E4%B8%AD%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[题目：在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。机器人可以接受下列三条指令之一： “G”：直走 1 个单位 “L”：左转 90 度 “R”：右转 90 度 机器人按顺序执行指令 instructions，并一直重复它们。 只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。 示例：示例 1： 输入：&quot;GGLLGG&quot; 输出：true 解释： 机器人从 (0,0) 移动到 (0,2)，转 180 度，然后回到 (0,0)。 重复这些指令，机器人将保持在以原点为中心，2 为半径的环中进行移动。 示例 2： 输入：&quot;GG&quot; 输出：false 解释： 机器人无限向北移动。 示例 3： 输入：&quot;GL&quot; 输出：true 解释： 机器人按 (0, 0) -&gt; (0, 1) -&gt; (-1, 1) -&gt; (-1, 0) -&gt; (0, 0) -&gt; ... 进行移动。 提示： 1 &lt;= instructions.length &lt;= 100 instructions[i] 在 {‘G’, ‘L’, ‘R’} 中 分析：如果可以回到原点，机器人最多需要4遍指令 代码：class Solution { public: bool isRobotBounded(string instructions) { int x = 0; int y = 0; int z = 0; for(int i = 0; i &lt; 5; i++){ for(int j = 0; j &lt; instructions.size(); j++){ if(instructions[j] == &apos;G&apos;){ if(z == 0){ y--; } else if(z == 1){ x++; } else if(z == 2){ y++; } else{ x--; } } else if(instructions[j] == &apos;L&apos;){ if(z == 0){ z = 3; } else{ z--; } } else if(instructions[j] == &apos;R&apos;){ if(z == 3){ z = 0; } else{ z++; } } if(j == instructions.size()-1){ if(x == 0 &amp;&amp; y == 0){ return true; } } } } return false; } }; 题目链接：https://leetcode-cn.com/contest/weekly-contest-136/problems/partition-array-for-maximum-sum/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5047. 多边形三角剖分的最低得分]]></title>
    <url>%2F2019%2F05%2F06%2Fleetcode%205047.%20%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86%2F</url>
    <content type="text"><![CDATA[题目：给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], …, A[N-1]。 假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。 返回多边形进行三角剖分后可以得到的最低分。 示例：示例 1： 输入：[1,2,3] 输出：6 解释：多边形已经三角化，唯一三角形的分数为 6。 示例 2： 输入：[3,7,4,5] 输出：144 解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。 示例 3： 输入：[1,3,1,4,1,5] 输出：13 解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。 提示： 3 &lt;= A.length &lt;= 50 1 &lt;= A[i] &lt;= 100 分析：dp[i][j] 表示从点i到点j所组成的多边形的最低分数 初始状态为dp[i][i+2] = A[i] A[i+1] A[i+2] 和 dp[i][j] = 0 转移方程为dp[i][j] = min(A[i] A[k] A[j] + dp[i][k] + dp[k][j]) 就是使用k将多边形分为三块，中间一块三角形，两边两块多边形 代码：class Solution { public: int minScoreTriangulation(vector&lt;int&gt;&amp; A) { int dp[A.size()][A.size()]; for(int j = 1; j &lt; A.size(); j++){ for(int i = 0; i+j &lt; A.size(); i++){ if(j == 1){ dp[i][i+1] = 0; } else if(j == 2){ dp[i][i+2] = A[i] * A[i+1] * A[i+2]; } else{ int min = INT_MAX; for(int k = i + 1; k &lt; i + j; k++){ if(k == i + 1 || dp[i][k] + dp[k][i+j] + A[i] * A[k] * A[i+j] &lt; min){ min = dp[i][k] + dp[k][i+j] + A[i] * A[k] * A[i+j]; } } dp[i][i+j] = min; } } } return dp[0][A.size()-1]; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-135/problems/minimum-score-triangulation-of-polygon/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5049. 移动石子直到连续 II]]></title>
    <url>%2F2019%2F05%2F05%2Fleetcode%205049-%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD%20II%2F</url>
    <content type="text"><![CDATA[题目：在一个长度无限的数轴上，第 i 颗石子的位置为 stones[i]。如果一颗石子的位置最小/最大，那么该石子被称作端点石子。 每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。 值得注意的是，如果石子像 stones = [1,2,5] 这样，你将无法移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。 当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。 要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。 示例：示例 1： 输入：[7,4,9] 输出：[1,2] 解释： 我们可以移动一次，4 -&gt; 8，游戏结束。 或者，我们可以移动两次 9 -&gt; 5，4 -&gt; 6，游戏结束。 示例 2： 输入：[6,5,4,3,10] 输出：[2,3] 解释： 我们可以移动 3 -&gt; 8，接着是 10 -&gt; 7，游戏结束。 或者，我们可以移动 3 -&gt; 7, 4 -&gt; 8, 5 -&gt; 9，游戏结束。 注意，我们无法进行 10 -&gt; 2 这样的移动来结束游戏，因为这是不合要求的移动。 示例 3： 输入：[100,101,104,102,103] 输出：[0,0] 提示： 3 &lt;= stones.length &lt;= 10^4 1 &lt;= stones[i] &lt;= 10^9 stones[i] 的值各不相同。 分析：最小的移动次数。遍历，寻找在连续的数中已经包含石子的段落，然后有三种可能： 只剩一个端点还没有并到一起，需要将已经排列好的一颗石子移动到中间给未排列的石子腾位置 还有一个以上的端点未合并，需要将为合并的一个端点移动到刚好够所有石子连在一起的位置，再将别的石子一个个放入中间 刚好有一个长度为石子总量，两边已经有石子，将别的石子一次放入即可 记录所有可能中最小的数 最大的移动次数，判断离两边端点最近的石子的长度哪个少，先移动少的哪个，然后就一步一步移动 代码：class Solution { public: vector&lt;int&gt; numMovesStonesII(vector&lt;int&gt;&amp; stones) { vector&lt;int&gt; vi; sort(stones.begin(), stones.end()); int l = 0; int r = 0; int z = 1; int min = INT_MAX; while(r &lt; stones.size()){ if(stones[r] - stones[l]+1 &lt; stones.size()){ z++; r++; } else if(stones[r] - stones[l]+1 == stones.size()){ if(stones.size() - z &lt; min){ min = stones.size() - z; } r++; l++; } else{ if(z == stones.size()){ if(2 &lt; min){ min = 2; } } else{ if(stones.size() - z + 1 &lt; min){ min = stones.size() - z + 1; } } l++; z--; } } int max = stones[stones.size()-1] - stones[0]+1-stones.size(); if(stones[1] - stones[0] &lt; stones[stones.size()-1] - stones[stones.size()-2]){ max = max - stones[1] + stones[0] + 1; } else{ max = max - stones[stones.size()-1] + stones[stones.size()-2] + 1; } vi.push_back(min); vi.push_back(max); return vi; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-135/problems/moving-stones-until-consecutive-ii/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5050. 从二叉搜索树到更大和树]]></title>
    <url>%2F2019%2F05%2F05%2Fleetcode%205050-%E4%BB%8E%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%88%B0%E6%9B%B4%E5%A4%A7%E5%92%8C%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目：给出二叉搜索树的根节点，该二叉树的节点值各不相同，修改二叉树，使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键小于节点键的节点。 节点的右子树仅包含键大于节点键的节点。 左右子树也必须是二叉搜索树。 示例：输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 提示： 树中的节点数介于 1 和 100 之间。 每个节点的值介于 0 和 100 之间。 给定的树为二叉搜索树。 分析：将二叉搜索树转换成一维数组，计算，在转换回去 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { vector&lt;int&gt; vi; int z; public: void tv(TreeNode* root){ if(root-&gt;left != NULL){ tv(root-&gt;left); } vi.push_back(root-&gt;val); if(root-&gt;right != NULL){ tv(root-&gt;right); } } void vt(TreeNode* root){ if(root-&gt;left != NULL){ vt(root-&gt;left); } root-&gt;val = vi[z]; z++; if(root-&gt;right != NULL){ vt(root-&gt;right); } } TreeNode* bstToGst(TreeNode* root) { z = 0; tv(root); for(int i = vi.size()-2; i &gt;= 0; i--){ vi[i] = vi[i] + vi[i+1]; } vt(root); return root; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-135/problems/binary-search-tree-to-greater-sum-tree/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 5051. 有效的回旋镖]]></title>
    <url>%2F2019%2F05%2F05%2Fleetcode%205051-%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%97%8B%E9%95%96%2F</url>
    <content type="text"><![CDATA[题目：回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。 给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。 示例：示例 1： 输入：[[1,1],[2,3],[3,2]] 输出：true 示例 2： 输入：[[1,1],[2,2],[3,3]] 输出：false 提示： points.length == 3 points[i].length == 2 0 &lt;= points[i][j] &lt;= 100 分析：以其中一个坐标为原点，若是一条直线，另外坐标的x和y互乘就会相同 代码：class Solution { public: bool isBoomerang(vector&lt;vector&lt;int&gt;&gt;&amp; points) { int x1 = points[1][0] - points[0][0]; int y1 = points[1][1] - points[0][1]; int x2 = points[2][0] - points[0][0]; int y2 = points[2][1] - points[0][1]; if(x1*y2 == x2*y1){ return false; } return true; } }; 题目地址：https://leetcode-cn.com/contest/weekly-contest-135/problems/valid-boomerang/]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1036. 逃离大迷宫]]></title>
    <url>%2F2019%2F04%2F29%2Fleetcode%201036.%20%E9%80%83%E7%A6%BB%E5%A4%A7%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[题目：在一个 10^6 x 10^6 的网格中，每个网格块的坐标为 (x, y)，其中 0 &lt;= x, y &lt; 10^6。 我们从源方格 source 开始出发，意图赶往目标方格 target。每次移动，我们都可以走到网格中在四个方向上相邻的方格，只要该方格不在给出的封锁列表 blocked 上。 只有在可以通过一系列的移动到达目标方格时才返回 true。否则，返回 false。 示例：示例 1： 输入：blocked = [[0,1],[1,0]], source = [0,0], target = [0,2] 输出：false 解释： 从源方格无法到达目标方格，因为我们无法在网格中移动。 示例 2： 输入：blocked = [], source = [0,0], target = [999999,999999] 输出：true 解释： 因为没有方格被封锁，所以一定可以到达目标方格。 提示： 0 &lt;= blocked.length &lt;= 200 blocked[i].length == 2 0 &lt;= blocked[i][j] &lt; 10^6 source.length == target.length == 2 0 &lt;= source[i][j], target[i][j] &lt; 10^6 source != target 分析：只要求出两个点周围是否有大于封锁点数*封锁点数/2的空白即可 代码：class Solution { public: bool isEscapePossible(vector&lt;vector&lt;int&gt;&gt;&amp; blocked, vector&lt;int&gt;&amp; source, vector&lt;int&gt;&amp; target) { int x = blocked.size()*blocked.size()/2; map&lt;int, map&lt;int, int&gt;&gt; si; map&lt;int, map&lt;int, int&gt;&gt; si1; vector&lt;int&gt; vi; // 栈顶-1为方向 1为上，2为下，3为左，4为右 栈顶-3为x 栈顶-2为y bool ret = false; vi.push_back(source[0]); vi.push_back(source[1]); vi.push_back(1); int z1 = 0; int z2 = 0; for(int i = 0; i &lt; blocked.size(); i++){ si1[blocked[i][0]][blocked[i][1]] = 1; } while(vi.size() != 0){ if(z1 &gt; x){ cout &lt;&lt; &quot;!&quot;; break; } if(vi[vi.size()-1] == 1) // 方向为上 { vector&lt;int&gt; v; v.push_back(vi[vi.size()-3]); v.push_back(vi[vi.size()-2]-1); vi[vi.size()-1] = 2; // 修改方向 if(vi[vi.size()-2]-1 &gt;= 0 &amp;&amp; si1[v[0]][v[1]] == 0 &amp;&amp; si[v[0]][v[1]] == 0){ // 坐标不溢出 是否在封锁列表上 是否已经经过 if(v[0] == target[0] &amp;&amp; v[1] == target[1]){ // 如果等于终点, 返回true return true; } z1++; si[v[0]][v[1]]=1; //向经过的点中添加当前点 vi.push_back(v[0]); // 添加到栈中 vi.push_back(v[1]); vi.push_back(1); } } else if(vi[vi.size()-1] == 2){ // 方向为下 vector&lt;int&gt; v; v.push_back(vi[vi.size()-3]); v.push_back(vi[vi.size()-2]+1); vi[vi.size()-1] = 3; // 修改方向 if(vi[vi.size()-2]+1 &lt; 1000000 &amp;&amp; si1[v[0]][v[1]] == 0 &amp;&amp; si[v[0]][v[1]] == 0){ // 坐标不溢出 是否在封锁列表上 是否已经经过 if(v[0] == target[0] &amp;&amp; v[1] == target[1]){ // 如果等于终点, 返回true return true; } z1++; si[v[0]][v[1]]=1; //向经过的点中添加当前点 vi.push_back(v[0]); // 添加到栈中 vi.push_back(v[1]); vi.push_back(1); } } else if(vi[vi.size()-1] == 3){ // 方向为左 vector&lt;int&gt; v; v.push_back(vi[vi.size()-3]-1); v.push_back(vi[vi.size()-2]); vi[vi.size()-1] = 4; // 修改方向 if(vi[vi.size()-3]-1 &gt;= 0 &amp;&amp; si1[v[0]][v[1]] == 0 &amp;&amp; si[v[0]][v[1]] == 0){ // 坐标不溢出 是否在封锁列表上 是否已经经过 if(v[0] == target[0] &amp;&amp; v[1] == target[1]){ // 如果等于终点, 返回true return true; } z1++; si[v[0]][v[1]]=1; //向经过的点中添加当前点 vi.push_back(v[0]); // 添加到栈中 vi.push_back(v[1]); vi.push_back(1); } } else if(vi[vi.size()-1] == 4){ // 方向为右 vector&lt;int&gt; v; v.push_back(vi[vi.size()-3]+1); v.push_back(vi[vi.size()-2]); vi.pop_back(); // 从栈中删除这个节点 vi.pop_back(); vi.pop_back(); if(v[0] &lt; 1000000 &amp;&amp; si1[v[0]][v[1]] == 0 &amp;&amp; si[v[0]][v[1]] == 0){ // 坐标不溢出 是否在封锁列表上 是否已经经过 if(v[0] == target[0] &amp;&amp; v[1] == target[1]){ // 如果等于终点, 返回true return true; } z1++; si[v[0]][v[1]]=1; //向经过的点中添加当前点 vi.push_back(v[0]); // 添加到栈中 vi.push_back(v[1]); vi.push_back(1); } } } if(z1 &lt; x){ return false; } vi.clear(); si.clear(); vi.push_back(target[0]); vi.push_back(target[1]); vi.push_back(1); while(vi.size() != 0){ if(z2 &gt; x){ break; } if(vi[vi.size()-1] == 1) // 方向为上 { vector&lt;int&gt; v; v.push_back(vi[vi.size()-3]); v.push_back(vi[vi.size()-2]-1); vi[vi.size()-1] = 2; // 修改方向 if(vi[vi.size()-2]-1 &gt;= 0 &amp;&amp; si1[v[0]][v[1]] == 0 &amp;&amp; si[v[0]][v[1]] == 0){ // 坐标不溢出 是否在封锁列表上 是否已经经过 // if(v[0] == target[0] &amp;&amp; v[1] == target[1]){ // 如果等于终点, 返回true // return true; // } z2++; si[v[0]][v[1]]=1; //向经过的点中添加当前点 vi.push_back(v[0]); // 添加到栈中 vi.push_back(v[1]); vi.push_back(1); } } else if(vi[vi.size()-1] == 2){ // 方向为下 vector&lt;int&gt; v; v.push_back(vi[vi.size()-3]); v.push_back(vi[vi.size()-2]+1); vi[vi.size()-1] = 3; // 修改方向 if(vi[vi.size()-2]+1 &lt; 1000000 &amp;&amp; si1[v[0]][v[1]] == 0 &amp;&amp; si[v[0]][v[1]] == 0){ // 坐标不溢出 是否在封锁列表上 是否已经经过 // if(v[0] == target[0] &amp;&amp; v[1] == target[1]){ // 如果等于终点, 返回true // return true; // } z2++; si[v[0]][v[1]]=1; //向经过的点中添加当前点 vi.push_back(v[0]); // 添加到栈中 vi.push_back(v[1]); vi.push_back(1); } } else if(vi[vi.size()-1] == 3){ // 方向为左 vector&lt;int&gt; v; v.push_back(vi[vi.size()-3]-1); v.push_back(vi[vi.size()-2]); vi[vi.size()-1] = 4; // 修改方向 if(vi[vi.size()-3]-1 &gt;= 0 &amp;&amp; si1[v[0]][v[1]] == 0 &amp;&amp; si[v[0]][v[1]] == 0){ // 坐标不溢出 是否在封锁列表上 是否已经经过 // if(v[0] == target[0] &amp;&amp; v[1] == target[1]){ // 如果等于终点, 返回true // return true; // } z2++; si[v[0]][v[1]]=1; //向经过的点中添加当前点 vi.push_back(v[0]); // 添加到栈中 vi.push_back(v[1]); vi.push_back(1); } } else if(vi[vi.size()-1] == 4){ // 方向为右 vector&lt;int&gt; v; v.push_back(vi[vi.size()-3]+1); v.push_back(vi[vi.size()-2]); vi.pop_back(); // 从栈中删除这个节点 vi.pop_back(); vi.pop_back(); if(v[0] &lt; 1000000 &amp;&amp; si1[v[0]][v[1]] == 0 &amp;&amp; si[v[0]][v[1]] == 0){ // 坐标不溢出 是否在封锁列表上 是否已经经过 // if(v[0] == target[0] &amp;&amp; v[1] == target[1]){ // 如果等于终点, 返回true // return true; // } z2++; si[v[0]][v[1]]=1; //向经过的点中添加当前点 vi.push_back(v[0]); // 添加到栈中 vi.push_back(v[1]); vi.push_back(1); } } } if(z2 &lt; x){ return false; } else { return true; } } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1035.不相交的线]]></title>
    <url>%2F2019%2F04%2F29%2Fleetcode%201035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[题目：我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。 现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。 以这种方法绘制线条，并返回我们可以绘制的最大连线数。 示例：示例 1： 输入：A = [1,4,2], B = [1,2,4] 输出：2 解释： 我们可以画出两条不交叉的线，如上图所示。 我们无法画出第三条不相交的直线，因为从 A[1]=4 到 B[2]=4 的直线将与从 A[2]=2 到 B[1]=2 的直线相交。 示例 2： 输入：A = [2,5,1,2,5], B = [10,5,2,1,5,2] 输出：3 示例 3： 输入：A = [1,3,7,1,7,5], B = [1,9,2,5,1] 输出：2 提示： 1 &lt;= A.length &lt;= 500 1 &lt;= B.length &lt;= 500 1 &lt;= A[i], B[i] &lt;= 2000 分析：动态规划 z[A][B]存储遍历到每两个点的线的数量 如果两点相等，就从当前两个点的值为z[A][B]值加1，如果两点不等，当前两个点的值为z[A-1][B]和z[A][B-1]两个值中较大的一个 代码：class Solution { public: int maxUncrossedLines(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) { int z[A.size()+1][B.size()+1]; memset(z, 0, (A.size()+1) * (B.size()+1) * sizeof(int)); for(int i = 1; i &lt;= A.size(); i++){ for(int j = 1; j &lt;= B.size(); j++){ if(A[i-1] == B[j-1]){ z[i][j] = z[i-1][j-1] + 1; } else{ z[i][j] = max(z[i-1][j], z[i][j-1]); } cout &lt;&lt; z[i][j] &lt;&lt; &quot; &quot; ; } } return z[A.size()][B.size()]; } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1034.边框着色]]></title>
    <url>%2F2019%2F04%2F29%2Fleetcode%201034-%E8%BE%B9%E6%A1%86%E7%9D%80%E8%89%B2%2F</url>
    <content type="text"><![CDATA[题目：给出一个二维整数网格 grid，网格中的每个值表示该位置处的网格块的颜色。 只有当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一连通分量。 连通分量的边界是指连通分量中的所有与不在分量中的正方形相邻（四个方向上）的所有正方形，或者在网格的边界上（第一行/列或最后一行/列）的所有正方形。 给出位于 (r0, c0) 的网格块和颜色 color，使用指定颜色 color 为所给网格块的连通分量的边界进行着色，并返回最终的网格 grid 。 示例：示例 1： 输入：grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3 输出：[[3, 3], [3, 2]] 示例 2： 输入：grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3 输出：[[1, 3, 3], [2, 3, 3]] 示例 3： 输入：grid = [[1,1,1],[1,1,1],[1,1,1]], r0 = 1, c0 = 1, color = 2 输出：[[2, 2, 2], [2, 1, 2], [2, 2, 2]] 提示： 1 &lt;= grid.length &lt;= 50 1 &lt;= grid[0].length &lt;= 50 1 &lt;= grid[i][j] &lt;= 1000 0 &lt;= r0 &lt; grid.length 0 &lt;= c0 &lt; grid[0].length 1 &lt;= color &lt;= 1000 分析：使用递归寻找相连同色方块，取其中有一条或多条边和别色方块或边框相邻的方块将其着色 代码：class Solution { private: int c; vector&lt;int&gt; vi; public: bool pd(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y){ if(x + 1 == grid.size() || y + 1 == grid[0].size() || x == 0 || y == 0){ return true; } if(grid[x + 1][y] != c &amp;&amp; grid[x + 1][y] != -1){ return true; } if(grid[x - 1][y] != c &amp;&amp; grid[x - 1][y] != -1){ return true; } if(grid[x][y+1] != c &amp;&amp; grid[x][y+1] != -1){ return true; } if(grid[x][y-1] != c &amp;&amp; grid[x][y-1] != -1){ return true; } return false; } void dg(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y){ if(grid[x][y] == c){ grid[x][y] = -1; if(pd(grid, x, y)){ vi.push_back(x); vi.push_back(y); } if(x - 1 &gt;= 0) dg(grid, x - 1, y); if(y + 1 &lt; grid[0].size()) dg(grid, x, y + 1); if(y - 1 &gt;= 0) dg(grid, x, y - 1); if(x + 1 &lt; grid.size()) dg(grid, x + 1, y); } } vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r0, int c0, int color) { c = grid[r0][c0]; dg(grid, r0, c0); for(int i = 0; i &lt; vi.size(); i+=2){ grid[vi[i]][vi[i+1]] = color; } for(int i = 0; i &lt; grid.size(); i++){ for(int j = 0; j &lt; grid[0].size(); j++){ if(grid[i][j] == -1){ grid[i][j] = c; } } } return grid; } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1033.移动石子直到继续]]></title>
    <url>%2F2019%2F04%2F29%2Fleetcode%201033-%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E7%BB%A7%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[题目：三枚石子放置在数轴上，位置分别为 a，b，c。 每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z 且 k != y。 当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。 要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 示例：示例 1： 输入：a = 1, b = 2, c = 5 输出：[1, 2] 解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。 示例 2： 输入：a = 4, b = 3, c = 2 输出：[0, 0] 解释：我们无法进行任何移动。 提示： 1 &lt;= a &lt;= 100 1 &lt;= b &lt;= 100 1 &lt;= c &lt;= 100 a != b, b != c, c != a 分析：石头最多的移法就是一格一格移，石头最少的移法，如果两个石头中间刚好空一格，就将另一块石头移过来，不然就移动两次 代码：class Solution { public: vector&lt;int&gt; numMovesStones(int a, int b, int c) { vector&lt;int&gt; vi; vi.push_back(a); vi.push_back(b); vi.push_back(c); sort(vi.begin(), vi.end()); vector&lt;int&gt; ret; ret.push_back(0); ret.push_back(vi[1]-vi[0]-1 + vi[2]-vi[1]-1); if(vi[0] + 1 == vi[1] &amp;&amp; vi[1] + 1 == vi[2]){ return ret; } if(vi[0] + 1 == vi[1] || vi[1] + 1 == vi[2] || vi[0] + 2 == vi[1] || vi[1] + 2 == vi[2]){ ret[0]++; return ret; } ret[0]+= 2; return ret; } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1031-两个非重叠子数组的最大和]]></title>
    <url>%2F2019%2F04%2F25%2Fleetcode%201031-%E4%B8%A4%E4%B8%AA%E9%9D%9E%E9%87%8D%E5%8F%A0%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[题目：给出非负整数数组 A ，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为 L 和 M。（这里需要澄清的是，长为 L 的子数组可以出现在长为 M 的子数组之前或之后。） 从形式上看，返回最大的 V，而 V = (A[i] + A[i+1] + … + A[i+L-1]) + (A[j] + A[j+1] + … + A[j+M-1]) 并满足下列条件之一： 0 &lt;= i &lt; i + L - 1 &lt; j &lt; j + M - 1 &lt; A.length, 或 0 &lt;= j &lt; j + M - 1 &lt; i &lt; i + L - 1 &lt; A.length. 示例：示例 1： 输入：A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2 输出：20 解释：子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。 示例 2： 输入：A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2 输出：29 解释：子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。 示例 3： 输入：A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3 输出：31 解释：子数组的一种选择中，[5,6,0,9] 长度为 4，[0,3,8] 长度为 3。 提示： L &gt;= 1 M &gt;= 1 L + M &lt;= A.length &lt;= 1000 0 &lt;= A[i] &lt;= 1000 分析：直接遍历 代码：class Solution { public: int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; A, int L, int M) { int max = 0; for(int i = 0; i + L - 1 &lt; A.size(); i++){ for(int j = 0; j + M - 1 &lt; A.size(); j++){ int z = 0; if(!(j + M - 1 &lt; i || j &gt; i + L-1)){ continue; } for(int k = 0; k &lt; L; k++){ z += A[i+k]; } for(int k = 0; k &lt; M; k++){ z += A[j+k]; } max = max &gt; z ? max : z; } } return max; } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1030.距离顺序排列矩阵单元格]]></title>
    <url>%2F2019%2F04%2F25%2Fleetcode%201030-%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[题目：给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 &lt;= r &lt; R 且 0 &lt;= c &lt; C。 另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。 返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。） 示例：示例 1： 输入：R = 1, C = 2, r0 = 0, c0 = 0 输出：[[0,0],[0,1]] 解释：从 (r0, c0) 到其他单元格的距离为：[0,1] 示例 2： 输入：R = 2, C = 2, r0 = 0, c0 = 1 输出：[[0,1],[0,0],[1,1],[1,0]] 解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2] [[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。 示例 3： 输入：R = 2, C = 3, r0 = 1, c0 = 2 输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]] 解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3] 其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。 提示： 1 &lt;= R &lt;= 100 1 &lt;= C &lt;= 100 0 &lt;= r0 &lt; R 0 &lt;= c0 &lt; C 分析：直接按照单元格之间的距离排序 代码：int r; int c; class Solution { public: static bool px(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b){ int a1 = a[0] - r &gt; r - a[0] ? a[0] - r : r - a[0]; a1 += a[1] - c &gt; c - a[1] ? a[1] - c : c - a[1]; int b1 = b[0] - r &gt; r - b[0] ? b[0] - r : r - b[0]; b1 += b[1] - c &gt; c - b[1] ? b[1] - c : c - b[1]; return a1 &lt; b1; } vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0) { r = r0; c = c0; vector&lt;vector&lt;int&gt;&gt; vvi; for(int i = 0; i &lt; R; i++){ for(int j = 0; j &lt; C; j++){ vector&lt;int&gt; vi; vi.push_back(i); vi.push_back(j); vvi.push_back(vi); } } sort(vvi.begin(), vvi.end(), px); return vvi; } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1029.两地调度]]></title>
    <url>%2F2019%2F04%2F25%2Fleetcode%201029-%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[题目：公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。 返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。 示例：输入：[[10,20],[30,200],[400,50],[30,20]]输出：110解释：第一个人去 A 市，费用为 10。第二个人去 A 市，费用为 30。第三个人去 B 市，费用为 50。第四个人去 B 市，费用为 20。 最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。 提示： 1 &lt;= costs.length &lt;= 100 costs.length 为偶数 1 &lt;= costs[i][0], costs[i][1] &lt;= 1000 分析：将每个人飞往两地的费用相减，取绝对值，然后按照这个绝对值从大到小排列，按照这个顺序安排前往两地的人，直到其中一个人数达到N，剩下的全部前往另一地 代码：class Solution { public: static bool px(vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b){ int a1 = a[0] - a[1]; int b1 = b[0] - b[1]; if(a1 &lt; 0){ a1 *= (-1); } if(b1 &lt; 0){ b1 *= (-1); } return a1 &gt; b1; } int twoCitySchedCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) { sort(costs.begin(), costs.end(), px); int a = 0; int b = 0; int m = 0; for(int i = 0; i &lt; costs.size(); i++){ cout &lt;&lt; costs[i][0] - costs[i][1] &lt;&lt; &quot;\n&quot;; if(costs[i][0] &lt; costs[i][1]){ if(a &lt; costs.size()/2){ a++; m += costs[i][0]; } else{ b++; m += costs[i][1]; } } else if(costs[i][0] &gt;= costs[i][1]){ if(b &lt; costs.size()/2){ b++; m += costs[i][1]; } else{ a++; m += costs[i][0]; } } } return m; } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1028.从先序遍历还原二叉树]]></title>
    <url>%2F2019%2F04%2F18%2Fleetcode%201028-%E4%BB%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目：我们从二叉树的根节点 root 开始进行深度优先搜索。 在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。 如果节点只有一个子节点，那么保证该子节点为左子节点。 给出遍历输出 S，还原树并返回其根节点 root。 示例：示例 1： 输入：&quot;1-2--3--4-5--6--7&quot; 输出：[1,2,5,3,4,6,7] 示例 2： 输入：&quot;1-2--3---4-5--6---7&quot; 输出：[1,2,5,3,null,6,null,4,null,7] 示例 3： 输入：&quot;1-401--349---90--88&quot; 输出：[1,401,null,349,88,90] 提示： 原始树中的节点数介于 1 和 1000 之间。 每个节点的值介于 1 和 10 ^ 9 之间。 分析：定义一个数组，指向每个深度最右边的那个节点的地址。 遍历字符串S，获得每个节点的深度和值。 判段当前所需添加节点的深度-1的位置是否有左节点： 若有，就将当前节点添加到深度-1节点的右节点，并且将数组中当前深度替换为当前的结点； 若没有，就将当前节点添加到深度-1结点的左节点，并且将数组中当前深度替换为当前的结点 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* recoverFromPreorder(string S) { TreeNode* sd[1000]; for(int i = 0; i &lt; 1000; i++){ sd[i] = NULL; } int z = 0; int i = 0; while(i &lt; S.size() &amp;&amp; S[i] != &apos;-&apos;){ z = z*10 + int(S[i] - &apos;0&apos;); i++; } sd[0] = new TreeNode(z); for(; i &lt; S.size();){ int q = 0; // 记录‘-’的数量 int p = 0; // 记录当前节点数字 while(i &lt; S.size() &amp;&amp; S[i] == &apos;-&apos;){ i++; q++; } while(i &lt; S.size() &amp;&amp; S[i] != &apos;-&apos;){ p = p*10 + int(S[i] - &apos;0&apos;); i++; } if(sd[q-1]-&gt;left == NULL){ sd[q-1]-&gt;left = new TreeNode(p); sd[q] = sd[q-1]-&gt;left; } else{ sd[q-1]-&gt;right = new TreeNode(p); sd[q] = sd[q-1]-&gt;right; } } return sd[0]; } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1027.最长等差数列]]></title>
    <url>%2F2019%2F04%2F18%2Fleetcode%201027-%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目：给定一个整数数组 A，返回 A 中最长等差子序列的长度。 回想一下，A 的子序列是列表 A[i_1], A[i_2], ..., A[i_k] 其中0 &lt;= i_1 &lt; i_2 &lt; ... &lt; i_k &lt;= A.length - 1。并且如果 B[i+1] - B[i]( 0 &lt;= i &lt; B.length - 1) 的值都相同，那么序列 B 是等差的。 示例：示例 1： 输入：[3,6,9,12] 输出：4 解释： 整个数组是公差为 3 的等差数列。 示例 2： 输入：[9,4,7,2,10] 输出：3 解释： 最长的等差子序列是 [4,7,10]。 示例 3： 输入：[20,1,15,3,10,5,8] 输出：4 解释： 最长的等差子序列是 [20,15,10,5]。 提示： 2 &lt;= A.length &lt;= 2000 0 &lt;= A[i] &lt;= 10000 分析：动态规划：vi[i][A[i] - A[j]] = vi[j][A[i] - A[j]]+1 对每个数记录向前所有的数的差值的数量 代码：class Solution { public: int longestArithSeqLength(vector&lt;int&gt;&amp; A) { vector&lt;map&lt;int, int&gt;&gt; vi(A.size()); int max = 0; for(int i = 0; i &lt; A.size(); i++){ for(int j = 0; j &lt; i; j++){ vi[i][A[i] - A[j]] = vi[j][A[i] - A[j]]+1; max = max &gt; vi[i][A[i] - A[j]] ? max : vi[i][A[i] - A[j]]; } } return max+1; } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1026.节点与祖先之间的最大差值]]></title>
    <url>%2F2019%2F04%2F18%2Fleetcode%201026-%E8%8A%82%E7%82%B9%E4%B8%8E%E7%A5%96%E5%85%88%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目：给定二叉树的根节点 root，找出存在于不同节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。 （如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先） 示例：输入：[8,3,10,1,6,null,14,null,null,4,7,13] 输出：7 解释： 我们有大量的节点与其祖先的差值，其中一些如下： |8 - 3| = 5 |3 - 7| = 4 |8 - 1| = 7 |10 - 13| = 3 在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。 提示： 树中的节点数在 2 到 5000 之间。 每个节点的值介于 0 到 100000 之间。 分析：递归遍历二叉树，每次递归时，传递从当前结点到根结点路径中最大和最小的值，和当前节点比较，存储最大的差值 代码：/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { private: int max; public: void dg(TreeNode* root, int b, int s){ max = max &gt; root-&gt;val - s ? max : root-&gt;val - s; max = max &gt; b - root-&gt;val ? max : b - root-&gt;val; b = b &gt; root-&gt;val ? b : root-&gt;val; s = s &lt; root-&gt;val ? s : root-&gt;val; if(root-&gt;left != NULL){ dg(root-&gt;left, b, s); } if(root-&gt;right != NULL){ dg(root-&gt;right, b, s); } } int maxAncestorDiff(TreeNode* root) { max = 0; dg(root, root-&gt;val, root-&gt;val); return max; } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 1025.除数博弈]]></title>
    <url>%2F2019%2F04%2F18%2Fleetcode%201025-%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[题目：爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例：示例 1： 输入：2 输出：true 解释：爱丽丝选择 1，鲍勃无法进行操作。 示例 2： 输入：3 输出：false 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 分析：因为奇数的因子只能是奇数，偶数的因子可以是奇数或偶数。 当爱丽丝遇到的N是偶数时，她可以选择一个奇数因子，使得传给对方的是奇数，导致对面只能选择奇数因子，传给爱丽丝的就又会是偶数，最终，爱丽丝遇到2，获胜 当爱丽丝遇到的是奇数时，只能选择奇数，传给对方偶数，所以必输 代码：class Solution { public: bool divisorGame(int N) { if(N % 2 == 0){ return true; } else{ return false; } } };]]></content>
      <categories>
        <category>leetcode题目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo的安装和使用]]></title>
    <url>%2F2019%2F04%2F15%2FHexo%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.安装Git官网下载，在下载后会有一个Git Bash的命令行工具，之后就用这个工具使用git 安装好后，可以用git --version来查看版本 2.安装nodejs官网下载:https://nodejs.org/en/download/ 安装后，打开命令行 node -v npm -v 检查是否安装成功 3.安装hexo新建一个文件夹，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。 输入命令 npm install -g hexo-cli 可以使用hexo -v来查看版本 接下来初始化hexo hexo init myblog # 此处myblog可以使用任何名字代替 然后 cd myblog //进入这个myblog文件夹 npm install 新建完成后，指定文件夹目录下有： node_modules: 依赖包 public：存放生成的页面 scaffolds：生成文章的模板 source：用来存放文章 themes：主题 _config.yml: 博客的配置文件 使用 hexo g hexo server # 可以使用 hexo s 来代替 打开hexo的服务，在浏览器输入localhost:4000就可以看到生成的博客了 使用ctrl+c可以把服务关掉。 GitHub创建个人仓库注册GitHub账户 注册完登录后，在GitHub.com中看到New repository，新建仓库 创建和用户名相同的仓库，后面加.github.io。 也就是xxxx.github.io，其中xxx就是注册GitHub的用户名。 点击create repository。 5.生成SSH添加到GitHub回到git bash中，输入： git config --global user.name &quot;yourname&quot; # yourname输入GitHub用户名 git config --global user.email &quot;youremail&quot; # youremail输入你GitHub的邮箱 可以用以下两条，检查一下有没有输对 git config user.name git config user.email 然后创建SSH,一路回车 ssh-keygen -t rsa -C &quot;youremail&quot; 这个时候它会提示已经生成了.ssh的文件夹。在此电脑中找到此文件夹 C:\Users\电脑用户名\.ssh id_rsa是这台电脑的私人秘钥，不能给别人看的， id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当链接GitHub自己的账户时，它就会根据公钥匹配私钥，当能够相互匹配时，才能够顺利的通过git上传文件到GitHub上。 而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key把id_rsa.pub里面的信息复制进去。 在git bash中，查看是否成功 ssh -T git@github.com 6.将hexo部署到GitHub打开站点配置文件 _config.yml，翻到最后，修改为: deploy: type: git repo: repo: git@github.com:YourgithubName/YourgithubName.github.io.git # YourgithubName就是GitHub账户 branch: master 这个时候需要先安装deploy-git ，也就是部署的命令,这样才能用命令部署到GitHub。 npm install hexo-deployer-git --save 然后 hexo clean # 清除之前生成的内容，可不加 hexo generate # 生成静态文章，可用 hexo g 缩写 hexo deploy # 部署文章，可用 hexo d 缩写 部署成功后，过一会儿就可以在http://yourname.github.io 这个网站看到博客了 在这一步中可能会要求安装eslint，安装方法见：https://blog.csdn.net/zz__zzmomo/article/details/83659578 7.设置个人域名现在个人网站的地址是 yourname.github.io 注册一个阿里云账户，在阿里云上面买一个域名 进入域名控制台，在域名控制台中看到购买的域名，点击解析 点击添加记录添加三条解析 其中，192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。 登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入域名flyingkw.com 然后在博客文件source中创建一个名为CNAME文件，不要后缀。写上域名。 最后，还是老样子 hexo clean hexo g hexo d 过一会儿，打开浏览器，输入域名，就可以看到搭建的网站了 8.写文章在git bash中输入： hexo new newpapername # 文章名 然后在source/_post中打开markdown文件，就可以开始编辑了。写完后在上传，就可以看到更新了。 9.更改主题在git bash中输入 git clone https://github.com/theme-next/hexo-theme-next themes/next 完成后在根目录下打开“_config.yml”文件，修改主题信息（将theme中的landscape修改为next） theme： next 然后可以修改next主题的界面风格，打开“站点根目录 /themes/next/_congig.yml 文件，修改next主题的配置信息 scheme: Pisces 10.设置语言打开站点目录下的“_config.yml”文件，修改“language”的值 title: # 博客名 subtitle: description: # 站点描述 keywords: author: # 设置昵称 language: zh-CN # 语言 timezone: 11.添加评论系统Next主题集成了valine，那就使用valine评论系统吧 注册Leancloud 评论系统是放在Leancloud上的，先注册一个账号 https://leancloud.cn/ 注册完后创建一个应用，名字随意， 接下来 进入应用-&gt;设置-&gt;安全中心 将服务开关中的数据存储打开，别的全部关掉 在下面的Web 安全域名 中填入自己的域名 然后 进入应用-&gt;设置-&gt;应用key 获取appid 和 appkey 然后打开主题配置文件搜索valine，填入appid和appkey valine: enable: true appid: your app id appkey: your app key notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: ヾﾉ≧∀≦)o写点啥呗 guest_info: nick,mail,link pageSize: 10 就可以啦 12.添加搜索功能在git bash中输入 npm install hexo-generator-searchdb –save 在根目录下的/theme/next/_config.yml文件中添加配置： search: path: search.xml field: post format: html limit: 1000 在根目录下的/theme/next/_config.yml文件中搜索local_search，将enable改为true local_search: enable: true 13.添加图片格式为：![图片未显示时的文字](路径/图片.jpg) 注意，图片格式为jpg 14.分类在文章头部指定一个categories属性即可 --- title: Hexo的安装和使用 date: 2019-04-15 16:35:26 tags: categories: Hexo --- 然后打开主题配置文件_config.yml，添加要添加的分类名到menu中： menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat leetcode题目: /categories/leetcode题目/ || th Hexo: /categories/Hexo || th ||之后的是图标 本文章参考了 https://www.jianshu.com/p/202c9e789c8f https://www.jianshu.com/p/728a9594bb6c https://blog.csdn.net/qq_35117024/article/details/81390430 https://blog.csdn.net/sinat_37781304/article/details/82729029 https://blog.csdn.net/qq_29347295/article/details/79005193 https://blog.csdn.net/u011240016/article/details/79422462]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
